//#region  Helps and shourcut
/* Ù„Ø§ Ø§Ù‡Ù„ Ø§Ù„Ø§ Ø§Ù„Ù„Ù‡ */
//#region Comments Color
// ! #region app-Started
/*
// ! #region Start-Database
?  Start-Database
&  Start-Database
^  Start-Database
*  Start-Database
TODO #region Start-Database
~  Start-Database
// removed code
*/
//#endregion  End / Comments Color

//#region shourcuts
/*
1 : collapse ( Fold ) Current region : CTRL + Shift + {
2 : extended ( Unfold ) Current region : CTRL + Shift + }
3 : collapse ( Fold ) All region : CTRL + K , CTRL + Zero  in top of keyboard
3 : extended ( Unfold ) All region : CTRL + K , CTRL + j 
*/

//#endregion End / shourcut

//#endregion End / Helps and shourcut

//#region Guid
//===================

/*
open Terminal vscode 
 npm init -y
 npm install express pg-promise body-parser dotenv express-session node-cron ws socket.io
 use this command always to resolve the problems : 
 create a file named (.env) in root put in it any variables to secure it like pass  for example put this in .env file ( pass="123" ) then call it here like ( password : env.pass)
 this page is name server.js put it in root file
 index.html put it in root file
 make folder named views put it in root file you should put all html files expept index.html file  in it
 make folder named public put it in root file you should make folders in it for  css and scripts
*/

//#endregion End-Guid


let today = new Date().toISOString().split("T")[0];
let deafultErrorMessage = 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'

function getYear(dateString) {
  
  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø³Ù„Ø³Ù„Ø© ØªØªØ¨Ø¹ Ø§Ù„ØµÙŠØºØ© Ø§Ù„ØµØ­ÙŠØ­Ø©
  const datePattern = /^\d{4}-\d{2}-\d{2}$/;
  
  if (!datePattern.test(dateString)) {
      throw new Error("Invalid date format. Please use YYYY-MM-DD. code S-getYear01");
  }

  // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† Date Ù…Ø¹ Ø§Ù„ØªØ¹Ø§Ù…Ù„ ÙƒÙ€ UTC
  const date = new Date(`${dateString}T00:00:00.000Z`); // Ø¥Ø¶Ø§ÙØ© "Z" ÙŠØ¬Ø¹Ù„ Ø§Ù„ØªØ§Ø±ÙŠØ® ÙŠØ¹Ø§Ù…Ù„ ÙƒÙ€ UTC
  return date.getUTCFullYear();
}

function timeNow(){
  const now = new Date();

let hours = now.getHours();
const minutes = String(now.getMinutes()).padStart(2, '0');
const seconds = String(now.getSeconds()).padStart(2, '0');

const ampm = hours >= 12 ? 'PM' : 'AM';
hours = hours % 12;
hours = hours ? String(hours).padStart(2, '0') : '12'; // ØªØ­ÙˆÙŠÙ„ 0 Ø¥Ù„Ù‰ 12

// const result = `${hours}:${minutes}:${seconds} ${ampm}`;
const result = `${hours}:${minutes} ${ampm}`;
return result
}


//#region app-Started
const http = require('http');
const express = require("express");
const rateLimit = require('express-rate-limit');
const socketIo = require('socket.io');
const app = express();
const server = http.createServer(app);
const { performance } = require('perf_hooks'); // Ø§Ø³ØªÙŠØ±Ø§Ø¯ performance
const io = socketIo(server);

io.on('connection', (socket) => {
  console.log('New client connected');
  // Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ù‡Ù†Ø§
});



const path = require("path"); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ù…ÙƒØªØ¨Ø© path
const bodyParser = require("body-parser");
const cron = require("node-cron");
const port = 3000;
const bcrypt = require("bcryptjs"); // Ù…ÙƒØªØ¨Ù‡ ØªØ´ÙÙŠØ± Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯ Ø§Ù„Ù…Ø±Ø³Ù„ Ø§Ù„Ù‰ Ù‚Ø§Ø¹Ø¯Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
const fs = require("fs");
const crypto = require("crypto");
const multer = require("multer");
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use("/public", express.static("public")); // ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª ÙÙŠ Ù…Ø¬Ù„Ø¯ 'public' > Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù€ CSS ÙˆØ§Ù„Ø¬Ø§ÙØ§ Ø³ÙƒØ±ÙŠØ¨Øª
app.set("views", path.join(__dirname, "views")); // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¬Ù„Ø¯ 'views' ÙƒÙ…Ø¬Ù„Ø¯ Ù„Ù„Ù‚ÙˆØ§Ù„Ø¨

app.set("view engine", "ejs"); // ØªØ¹ÙŠÙŠÙ† Ù…Ø­Ø±Ùƒ Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù€ EJS


//! Database
const pgp = require("pg-promise")();
const dotenv = require("dotenv");
const { log, table, error } = require("console");
dotenv.config();

// Ù‚Ø±Ø§Ø¡Ø© Ù‚ÙŠÙ…Ø© DB_SSL Ù…Ù† Ù…Ù„Ù .env ÙˆØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø¥Ù„Ù‰ Ù‚ÙŠÙ…Ø© Ø¨ÙˆÙ„ÙŠØ§Ù†ÙŠØ©
const sslEnabled = process.env.DB_SSL === "true";

const connection = {
  connectionString: process.env.DB_CONNECTION_STRING,
  ssl: sslEnabled
    ? {
        rejectUnauthorized: true, // ØªØ£ÙƒÙŠØ¯ ØµØ­Ø© Ø´Ù‡Ø§Ø¯Ø© SSL
      }
    : false, // ØªØ¹Ø·ÙŠÙ„ ØªÙ‚Ù†ÙŠØ© SSL
};

const db = pgp(connection);

// ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
db.connect()
  .then((obj) => {
    console.log("Connected to the database"); // ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¬Ø§Ø­
    obj.done();
  })
  .catch((error) => {
    console.error("Error connecting to the database:", error); // ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
    console.log(`check the internet or database connection`);
    
    process.exit();
  });

// ! Lazem el code da yt7t Befor routes definition
const session_time = 15
const session = require("express-session");
app.use(
  session({
    secret: "Allahis14ever.500@4Ever#",
    resave: false,
    saveUninitialized: false,
    rolling: true,
    httpOnly: true, // ÙŠÙ…Ù†Ø¹ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù…Ù„Ù ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ù…Ù† Ø¬Ø§ÙØ§ Ø³ÙƒØ±ÙŠØ¨Øª
    secure: true, // ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† true Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹Ù…Ù„ Ø¹Ù„Ù‰ HTTPS
    sameSite: "lax", // Ø£Ùˆ 'strict' Ù„Ø¶Ù…Ø§Ù† Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· ÙÙ‚Ø· Ø¹Ø¨Ø± Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø£ØµÙ„
    cookie: { maxAge: 1000 * 60 * session_time }, // Ù…Ø¯Ø© ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø© (60 Ø¯Ù‚Ø§Ø¦Ù‚)
  })
);

// Middleware Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø©
app.use((req, res, next) => {
  if (!req.session) {
    return next(); // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø©ØŒ Ø§Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ Ø§Ù„ÙˆØ³ÙŠØ· Ø§Ù„ØªØ§Ù„ÙŠ
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ø¯Ø© ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø©
  if (req.session.cookie._expires && Date.now() > req.session.cookie._expires) {

    req.session.destroy((error) => {
      if (error) {
        console.error('Failed to destroy session:', error);
      }
      // ÙŠÙ…ÙƒÙ†Ùƒ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ Ø§ØªØ®Ø§Ø° Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø£Ø®Ø±Ù‰
      res.redirect('/login'); // Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ø¥Ù„Ù‰ ØµÙØ­Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
    });
  } else {
    next(); // Ø§Ù„Ø¬Ù„Ø³Ø© Ù„Ø§ ØªØ²Ø§Ù„ ØµØ§Ù„Ø­Ø©ØŒ Ø§Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ Ø§Ù„ÙˆØ³ÙŠØ· Ø§Ù„ØªØ§Ù„ÙŠ
  }
});
// ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠØ¹Ù…Ù„



//! lazem el code da to7to ba3d tahy2t el session
const routes = require("./routes/routes");
const { truncate } = require('fs');
app.use("/", routes);

// Start the server


//#endregion End / App-Started

//#region cron

//#region Cron Functions
async function check_last_activity_fn() {
  // Ø§Ø­Ø³Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ

  
  const now = new Date();

  // Ø§Ø­Ø³Ø¨ ÙˆÙ‚Øª Ø§Ù„Ø­Ø¯ Ø§Ù„ÙØ§ØµÙ„ (5 Ø¯Ù‚Ø§Ø¦Ù‚)
  const sessionTime = new Date(now.getTime() - 1000 * 60 * session_time);

  try {
    // Ù‚Ù… Ø¨ØªÙ†ÙÙŠØ° Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… `db.none`
    await db.none(
      `
      UPDATE users
      SET is_active = null
      WHERE last_activity < $1;
  `,
      [sessionTime]
    );
    console.log(
      `Users updated based on last_activity older than ${sessionTime}`
    );
  } catch (error) {
    console.error("Error cron check_last_activity_fn:", error);
  }
}

//#endregion End Cron Functions

//#region cron schedule
// Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ù‡Ù…Ø© Ù„ØªØ¹Ù…Ù„ ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
cron.schedule("*/5 * * * *", async () => {
  //Ø§Ù„ÙƒÙˆØ¯ Ø¯Ø§ ÙŠØ¹Ù†Ù‰ Ø§Ù† Ø§Ù„ÙƒÙˆØ¯ Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ°Ù‡ Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ù‡ ØªÙ‚Ø¨Ù„ Ø§Ù„Ù‚Ø³Ù…Ù‡ Ø¹Ù„Ù‰ Ø®Ù…Ø³Ù‡ Ø¨ØºØ¶ Ø§Ù„Ù†Ø¸Ø± Ø§Ø° ÙƒØ§Ù† Ø´Ù‡Ø± ÙŠÙˆÙ… Ø³Ø§Ø¹Ù‡  Ø¯Ù‚ÙŠÙ‚Ù‡
  check_last_activity_fn();
  io.emit('ozkrAllah', { Alzekr: 'Ø§Ø°ÙƒØ± Ø§Ù„Ù„Ù‡'});
});



//#endregionEnd - cron schedule

//#endregion end cron

//#endregion end-cron




app.post("/backup_company", async (req, res) => {
  try {

    posted_elements = req.body
    let pass =  posted_elements.password
    if (!pass){
      return res.status(404).json({ message: "âŒ Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ø­Ù…Ø§ÙŠÙ‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ." });
      // return res.json({
      //   success: false,
      //   message_ar: 'Too many login attempts from this IP, please try again after 1 minute',
      // });
    }
    
    pass = await bcrypt.hash(pass, 12);

    

    const companyId = req.session.company_id;
    const ownerId = req.session.owner_id;
   // const companyName = req.session.company_name;

    if (!companyId || !ownerId) {
      return res.status(400).json({ message: "Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø© ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©" });
    }

    console.log(`ğŸ”¹ Starting backup for company: ${companyId}`);

    // 1ï¸âƒ£ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø´Ø±ÙƒØ©
    const password = pass;
    const companies = await db.any(`SELECT c.* FROM companies c WHERE c.id = $1 ORDER BY c.id ASC;`, [companyId]);
    const user_company = await db.any(`SELECT * FROM user_company WHERE company_id = $1;`, [companyId]);
    const settings = await db.any(`SELECT * FROM settings WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const accounts_header = await db.any(`SELECT * FROM accounts_header WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const accounts_body = await db.any(`SELECT ab.* FROM accounts_body ab JOIN accounts_header ah ON ah.id = ab.account_id WHERE ah.company_id = $1 ORDER BY ab.id ASC;`, [companyId]);
    const production_forms_header = await db.any(`SELECT * FROM production_forms_header WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const production_forms_body = await db.any(`SELECT pfb.* FROM production_forms_body pfb JOIN production_forms_header pfh ON pfh.id = pfb.production_forms_header_id WHERE pfh.company_id = $1 ORDER BY pfb.id ASC;`, [companyId]);    
    const settings_tax_header = await db.any(`SELECT * FROM settings_tax_header WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const settings_tax_body = await db.any(`SELECT stb.* FROM settings_tax_body stb JOIN settings_tax_header sth ON sth.id = stb.settings_tax_header_id WHERE sth.company_id = $1 ORDER BY stb.id ASC;`, [companyId]);    
    const befor_invoice_header = await db.any(`SELECT * FROM befor_invoice_header WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const befor_invoce_body = await db.any(`SELECT bib.* FROM befor_invoce_body bib JOIN befor_invoice_header bih ON bih.id = bib.header_id WHERE bih.company_id = $1 ORDER BY bib.id ASC;`, [companyId]);
    const transaction_header = await db.any(`SELECT * FROM transaction_header WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const transaction_body = await db.any(`SELECT tb.* FROM transaction_body tb JOIN transaction_header th ON th.id = tb.transaction_header_id WHERE th.company_id = $1 ORDER BY tb.id ASC;`, [companyId]);    
    const effects = await db.any(`SELECT * FROM effects WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const todo = await db.any(`SELECT * FROM todo WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);
    const history = await db.any(`SELECT * FROM history WHERE company_id = $1 ORDER BY id ASC;`, [companyId]);

    //! for check owner data when restore only
    const owner = await db.any(`select * from owners where id = $1;`, [ownerId]);

    // 2ï¸âƒ£ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙØ¹Ù„ÙŠØ©
    const totalRecords = [
      password.length,
      accounts_header.length,
      accounts_body.length,
      befor_invoice_header.length,
      befor_invoce_body.length,
      companies.length,
      effects.length,
      history.length,
      production_forms_header.length,
      production_forms_body.length,
      settings.length,
      settings_tax_header.length,
      settings_tax_body.length,
      todo.length,
      transaction_header.length,
      transaction_body.length,
      user_company.length,
      owner.length
    ].reduce((acc, val) => acc + val, 0);

    if (totalRecords === 0) {
      return res.status(404).json({ message: "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø´Ø±ÙƒØ©." });
    }

    // 3ï¸âƒ£ ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙƒÙ€ JSON
    const backupData = {
      password,
      accounts_header,
      accounts_body,
      befor_invoice_header,
      befor_invoce_body,
      companies,
      effects,
      history,
      production_forms_header,
      production_forms_body,
      settings,
      settings_tax_header,
      settings_tax_body,
      todo,
      transaction_header,
      transaction_body,
      user_company,
      owner
    };
    const jsonData = JSON.stringify(backupData, null, 2);

    // 4ï¸âƒ£ Ø§Ù„ØªØ´ÙÙŠØ± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… AES-256-CBC
    const secretKey = process.env.SECRET_KEY;
    const hmacKey = process.env.HMAC_KEY;

    if (!secretKey || secretKey.length !== 32) {
      throw new Error("âŒ Ø®Ø·Ø£: Ù…ÙØªØ§Ø­ Ø§Ù„ØªØ´ÙÙŠØ± ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ Ù…ÙÙ‚ÙˆØ¯!");
    }

    if (!hmacKey || hmacKey.length !== 32) {
      throw new Error("âŒ Ø®Ø·Ø£: Ù…ÙØªØ§Ø­ HMAC ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ Ù…ÙÙ‚ÙˆØ¯!");
    }

    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv("aes-256-cbc", Buffer.from(secretKey), iv);
    let encrypted = cipher.update(jsonData, "utf8", "hex");
    encrypted += cipher.final("hex");

    // Ø¥Ù†Ø´Ø§Ø¡ HMAC Ù„Ø¶Ù…Ø§Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const hmac = crypto.createHmac("sha256", Buffer.from(hmacKey));
    hmac.update(encrypted);
    const signature = hmac.digest("hex");

    const encryptedBackupData = JSON.stringify({
      iv: iv.toString("base64"),
      data: encrypted,
      hmac: signature
    });

    console.log("âœ… Backup is ready to be sent.");

     
    // 5ï¸âƒ£ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙƒÙ…Ù„Ù ØªÙ†Ø²ÙŠÙ„ Ø¯ÙˆÙ† ØªØ®Ø²ÙŠÙ†Ù‡Ø§
    res.setHeader("Content-Disposition", `attachment; filename="backup_${today}.SIM"`);
    res.setHeader("Content-Type", "application/octet-stream");
    res.send(Buffer.from(encryptedBackupData, "utf-8"));
    
  } catch (error) {
    console.error("âŒ Error during backup:", error);
    res.status(500).json({ message: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©." });
  }
});





const upload = multer({ storage: multer.memoryStorage() }); // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ù„Ù ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©


app.post("/restore_backup", upload.single("backupFile"), async (req, res) => {
  try {


    
    if (!req.file) {
      return res.status(400).json({ error: "Ù„Ù… ÙŠØªÙ… Ø±ÙØ¹ Ø£ÙŠ Ù…Ù„Ù." });
    }

    const fileName = req.file.originalname;
    if (!fileName.endsWith(".SIM")) {
      return res.status(400).json({ error: "ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ù…ØªØ¯Ø§Ø¯ .SIM" });
    }

    const company_id = req.session.company_id; // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø±ÙƒØ© Ù…Ù† Ø§Ù„Ø¬Ù„Ø³Ø©
    if (!company_id) {
      return res.status(403).json({ error: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª." });
    }

    // ğŸ”µ 1ï¸âƒ£ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ± ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    console.log("ğŸ”„ Decrypting data in progress...");

    
    const secretKey = process.env.SECRET_KEY;
    const hmacKey = process.env.HMAC_KEY;

    if (!secretKey || secretKey.length !== 32) {
      throw new Error("âŒ Ø®Ø·Ø£: Ù…ÙØªØ§Ø­ Ø§Ù„ØªØ´ÙÙŠØ± ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ Ù…ÙÙ‚ÙˆØ¯!");
    }

    if (!hmacKey || hmacKey.length !== 32) {
      throw new Error("âŒ Ø®Ø·Ø£: Ù…ÙØªØ§Ø­ HMAC ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ Ù…ÙÙ‚ÙˆØ¯!");
    }

    const encryptedBackupData = req.file.buffer.toString("utf8"); // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ù†Øµ
    const { iv, data, hmac } = JSON.parse(encryptedBackupData);

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… HMAC
    const hmacVerifier = crypto.createHmac("sha256", Buffer.from(hmacKey));
    hmacVerifier.update(data);
    const calculatedHmac = hmacVerifier.digest("hex");

    if (calculatedHmac !== hmac) {
      return res.status(400).json({ error: "âŒ Ø®Ø·Ø£: ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!" });
    }

    // ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
    const decipher = crypto.createDecipheriv("aes-256-cbc", Buffer.from(secretKey), Buffer.from(iv, "base64"));
    let decrypted = decipher.update(data, "hex", "utf8");
    decrypted += decipher.final("utf8");

    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙÙƒÙ‘Ùƒ Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† JSON
    const backupData = JSON.parse(decrypted);

    console.log("âœ… Decryption successful, data is ready for restoration.");

    //! Ø§Ù„ØªØ§ÙƒØ¯ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    const password = req.body.password;
    const isMatch = await bcrypt.compare(password, backupData.password);    
    
    if (!isMatch){
      console.log(`âŒâš ï¸ wrnog Password : Srb010`);
      return res.json({ message: "âš ï¸ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©." });
    }
    console.log(`âœ… Password is Ok!`);




    //! âš ï¸ Ù‡Ø§Ø§Ù… Ø¬Ø¯Ø§ Ù„Ù„ØªØ­Ù‚ Ù…Ù† Ø§Ù…ØªÙ„Ø§Ùƒ Ø§Ù„Ø´Ø®Øµ Ù„Ù„Ù†Ø³Ø®Ù‡ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠÙ‡
    if (backupData.owner[0].id !== req.session.owner_id) {
      console.log(`âŒâš ï¸   YOU ARE NOT THE OWNER OF THIS BACKUP : Srb011`);
      return res.json({ message: "âš ï¸ Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ù‡Ø°Ù‡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©" });
    }
    
  
    const pgp = require("pg-promise")({ capSQL: true }); // Ø¶Ø±ÙˆØ±ÙŠ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… bulk insert

    // ğŸ”µ 2ï¸âƒ£ Ø¨Ø¯Ø¡ Ù…Ø¹Ø§Ù…Ù„Ø© (Transaction) Ù„Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø«Ù… Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡Ø§
    await db.tx(async (tx) => {
      console.log(`ğŸ”´ Deleting company data (ID: ${company_id})...`);

      await tx.none("DELETE FROM companies WHERE id = $1", [company_id]);
      console.log(`âœ… Successfully deleted all company data (ID: ${company_id}).`);

      // ğŸ”µ 3ï¸âƒ£ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ Ù†ÙØ³ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
      console.log("ğŸ”„ Restoring data from the backup...");

      //! get current Users in database
      let users = await tx.any(`SELECT id FROM users WHERE owner_id = $1`, [req.session.owner_id]);
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù€ users Ø¥Ù„Ù‰ Set Ù„Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„Ø¨Ø­Ø«
      const existingUserIds = new Set(users.map(user => user.id));


// 1ï¸âƒ£ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª `companies` Ø¯ÙØ¹Ø© ÙˆØ§Ø­Ø¯Ø©
  let companyIdMap = {}; // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯
  if (backupData.companies.length > 0) {
    const queryCompanies = pgp.helpers.insert(
      backupData.companies.map(c => ({
        company_name: c.company_name,
        owner_id: c.owner_id
      })),
      ["company_name", "owner_id"],
      "companies"
    ) + " RETURNING id, owner_id";
  
    const insertedCompany = await tx.one(queryCompanies); // Ù„Ø£Ù† Ù‡Ù†Ø§Ùƒ Ø´Ø±ÙƒØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
    
    // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† ID Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¨Ø§Ø´Ø±Ø©Ù‹
    companyIdMap[backupData.companies[0].id] = insertedCompany.id;
  }

  // ğŸŸ¡ new company_id
   const newCompanyId = companyIdMap[backupData.companies[0].id]; // ID Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¨Ø§Ø´Ø±Ø©Ù‹
  
// 2ï¸âƒ£ insert settings
  if (backupData.settings.length > 0) {
    const settingsData = backupData.settings.map(s => ({
      company_id: newCompanyId, // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯
      setting_type_id: s.setting_type_id,
      setting_type_name: s.setting_type_name,
      datex1: s.datex1,
      boolean1: s.boolean1
    }));
  
    const querySettings = pgp.helpers.insert(
      settingsData,
      ["company_id", "setting_type_id", "setting_type_name", "datex1", "boolean1"],
      "settings"
    );
  
    await tx.none(querySettings);
  }
  
// 3ï¸âƒ£ insert accounts_header
let accountIdMap = {};
if (backupData.accounts_header.length > 0) {
    
  const accounts_headerData = backupData.accounts_header.map(x => ({
    restore_old_id: x.id,
    company_id: newCompanyId, // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯
    account_name: x.account_name,
    is_final_account: x.is_final_account,
    account_no: x.account_no,
    finance_statement: x.finance_statement,
    cashflow_statement: x.cashflow_statement,
    account_type_id: x.account_type_id,
    account_name_en: x.account_name_en,
    global_id: x.global_id,
    main_account_id: x.main_account_id,
    item_sales_price: x.item_sales_price,
    item_purshas_price: x.item_purshas_price,
    item_amount_reorder_point: x.item_amount_reorder_point,
    item_unite: x.item_unite,
    item1: x.item1,
    item2: x.item2,
    item3: x.item3,
    is_salesman: x.is_salesman,
    is_allow_to_buy_and_sell: x.is_allow_to_buy_and_sell,
    is_inactive: x.is_inactive,
    str50_column1: x.str50_column1,
    str50_column2: x.str50_column2,
    str50_column3: x.str50_column3,
    str10_data_column1: x.str10_data_column1,
    str10_data_column2: x.str10_data_column2,
    str10_data_column3: x.str10_data_column3,
    str_textarea_column1: x.str_textarea_column1,
    str_textarea_column2: x.str_textarea_column2,
    str_textarea_column3: x.str_textarea_column3,
    int2_column1: x.int2_column1,
    int2_column2: x.int2_column2,
    int2_column3: x.int2_column3,
    numeric_column1: x.numeric_column1,
    numeric_column2: x.numeric_column2,
    numeric_column3: x.numeric_column3,
    is_column1: x.is_column1,
    is_column2: x.is_column2,
    str20_column1: x.str20_column1,
    str_textarea_column4: x.str_textarea_column4,
    str_textarea_column5: x.str_textarea_column5,
  }));

  const query_accounts_headerData = pgp.helpers.insert(
    accounts_headerData,
    [
      "restore_old_id", "company_id", "account_name", "is_final_account", "account_no", "finance_statement",
      "cashflow_statement", "account_type_id", "account_name_en", "global_id", "main_account_id",
      "item_sales_price", "item_purshas_price",
      "item_amount_reorder_point", "item_unite", "item1", "item2", "item3", "is_salesman",
      "is_allow_to_buy_and_sell", "is_inactive", "str50_column1", "str50_column2", "str50_column3",
      "str10_data_column1", "str10_data_column2", "str10_data_column3", "str_textarea_column1",
      "str_textarea_column2", "str_textarea_column3", "int2_column1", "int2_column2", "int2_column3",
      "numeric_column1", "numeric_column2", "numeric_column3", "is_column1", "is_column2",
      "str20_column1", "str_textarea_column4", "str_textarea_column5"
    ],
    "accounts_header"
  ) + " RETURNING id, restore_old_id";

  const insertedAccounts = await tx.many(query_accounts_headerData);

  insertedAccounts.forEach(row => {
    accountIdMap[row.restore_old_id] = row.id;
  });
  await tx.none(`UPDATE accounts_header SET restore_old_id = NULL WHERE restore_old_id IS NOT NULL;`)



  //! ğŸŸ  ØªØ¬Ù…ÙŠØ¹ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø¯ÙØ¹Ø© ÙˆØ§Ø­Ø¯Ø©
  const updates = backupData.accounts_header
    .filter(account => account.item_revenue_account || account.item_expense_account)
    .map(account => ({
      id: accountIdMap[account.id],
      item_revenue_account: accountIdMap[account.item_revenue_account] || null,
      item_expense_account: accountIdMap[account.item_expense_account] || null
    }))
    .filter(update => update.id); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ id Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø­Ø³Ø§Ø¨

    if (updates.length > 0) {
      // 1ï¸ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ ØµÙŠØºØ© VALUES (id, item_revenue_account, item_expense_account)
      const valuesList = updates
        .map(u => `(${u.id}, ${u.item_revenue_account || 'NULL'}, ${u.item_expense_account || 'NULL'})`)
        .join(", ");
    
      // 2 Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… UPDATE ... FROM VALUES
      const updateQuery = `
        UPDATE accounts_header AS t
        SET item_revenue_account = v.item_revenue_account,
            item_expense_account = v.item_expense_account
        FROM (VALUES ${valuesList}) AS v(id, item_revenue_account, item_expense_account)
        WHERE t.id = v.id;
      `;
    
      // 3 ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…
      await tx.none(updateQuery);
    }
    
}


// 4ï¸âƒ£ insert accounts_body
if (backupData.accounts_body.length > 0) {
  // console.table(accountIdMap)
  const accounts_bodyData = backupData.accounts_body.map(x => {
    const newParentId = accountIdMap[x.parent_id] ?? null; // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø£Ùˆ ØªØ¹ÙŠÙŠÙ† null
    const newAccountId = accountIdMap[x.account_id]; // ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§

    if (!newAccountId) {
      throw new Error(`Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¥Ø¯Ø±Ø§Ø¬: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ID Ø¬Ø¯ÙŠØ¯ Ù„Ù€ account_id: ${x.account_id}`);
    }

    return {
      parent_id: newParentId,
      account_id: newAccountId
    };
  });

  const query_accounts_bodyData = pgp.helpers.insert(
    accounts_bodyData,
    ["parent_id", "account_id"],
    "accounts_body"
  );

  await tx.none(query_accounts_bodyData);
}

//! Global Code permissions500 S-0
// 5ï¸âƒ£ insert into user_company 
if (backupData.user_company.length > 0) {

  // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† user_id Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ users
  const user_companyData = backupData.user_company
    .filter(x => existingUserIds.has(x.user_id)) // ØªØµÙÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ†
    .map(x => ({
      company_id: newCompanyId, // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯
      user_id: x.user_id,
      general_permission: x.general_permission,
      employees_permission: x.employees_permission,
      effects_permission: x.effects_permission,
      users_permission: x.users_permission,
      production_permission: x.production_permission,
      bread_permission: x.bread_permission,
      acounts_permission: x.acounts_permission,
      transaction_permission: x.transaction_permission,
      items_permissions: x.items_permissions,
      customers_permission: x.customers_permission,
      vendors_permission: x.vendors_permission,
      departments_permission: x.departments_permission,
      items_permission: x.items_permission,
      itemslocations_permission: x.itemslocations_permission,
      salesman_permission: x.salesman_permission,
      sales_qutation_permission: x.sales_qutation_permission,
      sales_order_permission: x.sales_order_permission,
      sales_invoice_permission: x.sales_invoice_permission,
      purshases_qutation_permission: x.purshases_qutation_permission,
      purshases_order_permission: x.purshases_order_permission,
      purshases_invoice_permission: x.purshases_invoice_permission,
      services_permission: x.services_permission,
      sales_returns_permission: x.sales_returns_permission,
      purshases_returns_permission: x.purshases_returns_permission,
      fixed_assests_permission: x.fixed_assests_permission,
      accumulated_depreciation_permission: x.accumulated_depreciation_permission,
      disposed_fixed_asset_permission: x.disposed_fixed_asset_permission,
      items_transfer_permission: x.items_transfer_permission,
      cash_accounts_permission: x.cash_accounts_permission,
      cash_transaction_permission: x.cash_transaction_permission
    }));

  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª ÙØ§Ø±ØºØ©
  if (user_companyData.length > 0) {
    const query_user_company = pgp.helpers.insert(
      user_companyData,
      [
        "company_id", "user_id", "general_permission", "employees_permission", "effects_permission", "users_permission", "production_permission", "bread_permission", "acounts_permission", "transaction_permission",
        "items_permissions", "customers_permission", "vendors_permission", "departments_permission", "items_permission", "itemslocations_permission", "salesman_permission", "sales_qutation_permission", "sales_order_permission",
        "sales_invoice_permission", "purshases_qutation_permission", "purshases_order_permission", "purshases_invoice_permission", "services_permission",  "sales_returns_permission",
        "purshases_returns_permission", "fixed_assests_permission", "accumulated_depreciation_permission", "disposed_fixed_asset_permission", "items_transfer_permission", "cash_accounts_permission", "cash_transaction_permission"
      ],
      "user_company"
    );

    await tx.none(query_user_company);
  } else {
    console.log("ğŸš¨ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª ØµØ§Ù„Ø­Ø© Ù„Ù„Ø¥Ø¯Ø±Ø§Ø¬ ÙÙŠ user_company.");
  }
}


// 6ï¸âƒ£ insert production_forms_header
let productionFormsMap = {}; // Ø®Ø±ÙŠØ·Ø© Ù„Ø±Ø¨Ø· Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¨Ø§Ù„Ø¬Ø¯ÙŠØ¯
if (backupData.production_forms_header.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const productionFormsData = backupData.production_forms_header.map(x => ({
    restore_old_id: x.id,
    company_id: newCompanyId,
    account_no: x.account_no,
    form_name: x.form_name,
    production_item_id: accountIdMap[x.production_item_id] || x.production_item_id, // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
    location_from: accountIdMap[x.location_from] || x.location_from, // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
    value: x.value,
  }));

  // Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…
  const query_production_forms_header = pgp.helpers.insert(
    productionFormsData,
    ["restore_old_id", "company_id", "account_no", "form_name", "production_item_id", "location_from", "value"],
    "production_forms_header"
  ) + " RETURNING id, restore_old_id";

  const insertedForms = await tx.many(query_production_forms_header);

  // Ø­ÙØ¸ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙ‡Ø±Ø³
  insertedForms.forEach(row => {
    productionFormsMap[row.restore_old_id] = row.id;
  });
  await tx.none(`UPDATE production_forms_header SET restore_old_id = NULL WHERE restore_old_id IS NOT NULL;`)


}


// 7ï¸âƒ£ insert production_forms_body
if (backupData.production_forms_body.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const production_forms_body_Data = backupData.production_forms_body.map(x => ({
      production_forms_header_id: productionFormsMap[x.production_forms_header_id], // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯
      account_id: accountIdMap[x.account_id] || x.account_id, // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ ID Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¥Ø°Ø§ ÙˆØ¬Ø¯
      value: x.value,
    }));

  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù‡Ù†Ø§Ùƒ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙŠØªÙ… Ø¥Ø¯Ø®Ø§Ù„Ù‡Ø§
  if (production_forms_body_Data.length > 0) {
    const query_production_forms_body = pgp.helpers.insert(
      production_forms_body_Data,
      ["production_forms_header_id", "account_id", "value"],
      "production_forms_body"
    );

    await tx.none(query_production_forms_body); // ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª
  }
}


// 8ï¸âƒ£ insert settings_tax_header
let settings_tax_header_Map = {}; // Ø®Ø±ÙŠØ·Ø© Ù„Ø±Ø¨Ø· Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¨Ø§Ù„Ø¬Ø¯ÙŠØ¯
if (backupData.settings_tax_header.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const settings_tax_header_Data = backupData.settings_tax_header.map(x => ({
    restore_old_id: x.id,
    company_id: newCompanyId,
    taxe_package_name: x.taxe_package_name,
    is_inactive: x.is_inactive,
  }));

  // Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…
  const query_settings_tax_header = pgp.helpers.insert(
    settings_tax_header_Data,
    ["restore_old_id", "company_id", "taxe_package_name", "is_inactive"],
    "settings_tax_header"
  ) + " RETURNING id, restore_old_id";

  const insertedForms = await tx.many(query_settings_tax_header);

  // Ø­ÙØ¸ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙ‡Ø±Ø³
  insertedForms.forEach(row => {
    settings_tax_header_Map[row.restore_old_id] = row.id;
  });
  await tx.none(`UPDATE settings_tax_header SET restore_old_id = NULL WHERE restore_old_id IS NOT NULL;`)


}




// ğŸ”Ÿ insert production_forms_body
let settings_tax_body_Map = {}; // Ø®Ø±ÙŠØ·Ø© Ù„Ø±Ø¨Ø· Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¨Ø§Ù„Ø¬Ø¯ÙŠØ¯
if (backupData.settings_tax_body.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const settings_tax_body_Data = backupData.settings_tax_body.map(x => ({
      restore_old_id: x.id,
      tax_name: x.tax_name,
      tax_rate: x.tax_rate,
      is_tax_reverse: x.is_tax_reverse,
      tax_account_id: accountIdMap[x.tax_account_id] || x.tax_account_id, // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ ID Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¥Ø°Ø§ ÙˆØ¬Ø¯
      settings_tax_header_id: settings_tax_header_Map[x.settings_tax_header_id], // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯
    }));

  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù‡Ù†Ø§Ùƒ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙŠØªÙ… Ø¥Ø¯Ø®Ø§Ù„Ù‡Ø§
  if (settings_tax_body_Data.length > 0) {
    const query_settings_tax_body = pgp.helpers.insert(
      settings_tax_body_Data,
      ["restore_old_id", "tax_name", "tax_rate", "is_tax_reverse", "tax_account_id", "settings_tax_header_id"],
      "settings_tax_body"
    ) + " RETURNING id, restore_old_id";

    const insertedForms = await tx.many(query_settings_tax_body); // ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª

        // Ø­ÙØ¸ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙ‡Ø±Ø³
        insertedForms.forEach(row => {
          settings_tax_body_Map[row.restore_old_id] = row.id;
        });
        await tx.none(`UPDATE settings_tax_body SET restore_old_id = NULL WHERE restore_old_id IS NOT NULL;`);
      
  }
}


// 1ï¸âƒ£1ï¸âƒ£ insert befor_invoice_header
let befor_invoice_header_Map = {};
if (backupData.befor_invoice_header.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø¥Ø¶Ø§ÙØ© old_id Ù„Ø¶Ù…Ø§Ù† ØµØ­Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø©
  const befor_invoice_header_Data = backupData.befor_invoice_header.map(x => ({
    restore_old_id: x.id, // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ Ù„Ø¶Ù…Ø§Ù† ØµØ­Ø© Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
    company_id: newCompanyId,
    reference: x.reference,
    transaction_type: x.transaction_type,
    total_value: x.total_value,
    general_note: x.general_note,
    datex: x.datex,
    is_deleted: x.is_deleted,
    account_id: accountIdMap[x.account_id] || x.account_id,
    salesman_id: accountIdMap[x.salesman_id] || x.salesman_id,
    expire_offer_datex: x.expire_offer_datex,
    is_delivered: x.is_delivered,
    items_location_id: accountIdMap[x.items_location_id] || x.items_location_id, // ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ù‡Ø°Ø§ Ø§Ù„ØªØ­ÙˆÙŠÙ„
    is_column2: x.is_column2,
    is_column1: x.is_column1,
    qutation_status: x.qutation_status,
    is_invoiced: x.is_invoiced,
    is_qutation_status: x.item3,
    is_column3: x.is_column3,
  }));

  // Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ø±Ø¬Ø§Ø¹ id Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ old_id
  const query_befor_invoice_header = pgp.helpers.insert(
    befor_invoice_header_Data,
    [
      "restore_old_id", "company_id", "reference", "transaction_type", "total_value", 
      "general_note", "datex", "is_deleted", "account_id", "salesman_id", 
      "expire_offer_datex", "is_delivered", "items_location_id", 
      "is_column2", "is_column1", "qutation_status", "is_invoiced", "is_qutation_status", "is_column3"
    ],
    "befor_invoice_header"
  ) + " RETURNING id, restore_old_id";

  const inserted_query = await tx.many(query_befor_invoice_header);

  // Ø­ÙØ¸ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙ‡Ø±Ø³
  inserted_query.forEach(row => {
    befor_invoice_header_Map[row.restore_old_id] = row.id;
  });
  await tx.none(`UPDATE befor_invoice_header SET restore_old_id = NULL WHERE restore_old_id IS NOT NULL;`)



  //! ğŸŸ  ØªØ¬Ù…ÙŠØ¹ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø¯ÙØ¹Ø© ÙˆØ§Ø­Ø¯Ø©
  const updates = backupData.befor_invoice_header
    .filter(x => x.qutation_id)
    .map(x => ({
      id: befor_invoice_header_Map[x.id], // ØªØµØ­ÙŠØ­ Ø§Ù„Ø®Ø·Ø£ Ù‡Ù†Ø§
      qutation_id: befor_invoice_header_Map[x.qutation_id] || null, // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ qutation_id Ø¨Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯
    }))
    .filter(update => update.id); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ id Ø¬Ø¯ÙŠØ¯

  if (updates.length > 0) {
    // 1ï¸ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ ØµÙŠØºØ© VALUES (id, qutation_id)
    const valuesList = updates
      .map(u => `(${u.id}, ${u.qutation_id || 'NULL'})`)
      .join(", ");

    // 2 Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… UPDATE ... FROM VALUES
    const updateQuery = `
      UPDATE befor_invoice_header AS t
      SET qutation_id = v.qutation_id
      FROM (VALUES ${valuesList}) AS v(id, qutation_id)
      WHERE t.id = v.id;
    `;

    // 3 ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…
    await tx.none(updateQuery);
  }

}


// 1ï¸âƒ£2ï¸âƒ£ insert production_forms_body
if (backupData.befor_invoce_body.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const befor_invoce_body_Data = backupData.befor_invoce_body.map(x => ({
        header_id: befor_invoice_header_Map[x.header_id],
        item_type_id: x.item_type_id,
        item_id: accountIdMap[x.item_id] || x.item_id,
        amount: x.amount,
        unite_price: x.unite_price,
        row_note: x.row_note,
        is_discount_percentage: x.is_discount_percentage,
        dicount_value: x.dicount_value,
        tax_header_id: settings_tax_header_Map[x.tax_header_id] || x.tax_header_id,
    }));

  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù‡Ù†Ø§Ùƒ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙŠØªÙ… Ø¥Ø¯Ø®Ø§Ù„Ù‡Ø§
  if (befor_invoce_body_Data.length > 0) {
    const query_befor_invoce_body = pgp.helpers.insert(
      befor_invoce_body_Data,
      ["header_id", "item_type_id", "item_id", "amount", "unite_price", "row_note", "is_discount_percentage", "dicount_value", "tax_header_id"],
      "befor_invoce_body"
    );

    await tx.none(query_befor_invoce_body); // ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª
  }
}


// 1ï¸âƒ£3ï¸âƒ£ insert settings_tax_header
let transaction_header_Map = {}; // Ø®Ø±ÙŠØ·Ø© Ù„Ø±Ø¨Ø· Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¨Ø§Ù„Ø¬Ø¯ÙŠØ¯
if (backupData.transaction_header.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const transaction_header_Data = backupData.transaction_header.map(x => ({
    restore_old_id: x.id,
    company_id: newCompanyId,
    reference: x.reference,
    transaction_type: x.transaction_type,
    total_value: x.total_value,
    general_note: x.general_note,
    datex: x.datex,
    is_deleted: x.is_deleted,
    account_id: accountIdMap[x.account_id] || x.account_id,
    salesman_id: accountIdMap[x.salesman_id] || x.salesman_id,
    due_date: x.due_date,
    is_column1: x.is_column1,
    is_column2: x.is_column2,
    items_location_id: accountIdMap[x.items_location_id] || x.items_location_id,
    is_delivered: x.is_delivered,
    order_id: befor_invoice_header_Map[x.order_id] || x.order_id,
    qutation_id: befor_invoice_header_Map[x.qutation_id] || x.qutation_id,
    general_reference: x.general_reference,
    is_including_items: x.is_including_items,
    str10_date_column1: x.str10_date_column1,
    str10_date_column2: x.str10_date_column2,
    items_location_id2: accountIdMap[x.items_location_id2] || x.items_location_id2,
    is_column3: x.is_column3,
  }));

  // Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…
  const query_transaction_header = pgp.helpers.insert(
    transaction_header_Data,
    [
      "restore_old_id", "company_id", "reference", "transaction_type", "total_value", "general_note", "datex", "is_deleted",
      "account_id", "salesman_id", "due_date", "is_column1", "is_column2", "items_location_id", "is_delivered", "order_id",
      "qutation_id", "general_reference", "is_including_items", "str10_date_column1", "str10_date_column2", "items_location_id2",
      "is_column3"
    ],
    "transaction_header"
  ) + " RETURNING id, restore_old_id";

  const insertedForms = await tx.many(query_transaction_header);

  // Ø­ÙØ¸ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙ‡Ø±Ø³
  insertedForms.forEach(row => {
    transaction_header_Map[row.restore_old_id] = row.id;
  });
  await tx.none(`UPDATE transaction_header SET restore_old_id = NULL WHERE restore_old_id IS NOT NULL;`)


    //! ğŸŸ  ØªØ¬Ù…ÙŠØ¹ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø¯ÙØ¹Ø© ÙˆØ§Ø­Ø¯Ø©
    const updates = backupData.transaction_header
    .filter(x => x.invoice_id)
    .map(x => ({
      id: transaction_header_Map[x.id], // ØªØµØ­ÙŠØ­ Ø§Ù„Ø®Ø·Ø£ Ù‡Ù†Ø§
      invoice_id: transaction_header_Map[x.invoice_id] || null, // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ invoice_id Ø¨Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯
    }))
    .filter(update => update.id); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ id Ø¬Ø¯ÙŠØ¯

  if (updates.length > 0) {
    // 1ï¸ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ ØµÙŠØºØ© VALUES (id, qutation_id)
    const valuesList = updates
      .map(u => `(${u.id}, ${u.invoice_id || 'NULL'})`)
      .join(", ");

    // 2 Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… UPDATE ... FROM VALUES
    const updateQuery = `
      UPDATE transaction_header AS t
      SET invoice_id = v.invoice_id
      FROM (VALUES ${valuesList}) AS v(id, invoice_id)
      WHERE t.id = v.id;
    `;

    // 3 ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…
    await tx.none(updateQuery);
  }

}




// 1ï¸âƒ£4ï¸âƒ£ insert production_forms_body
if (backupData.transaction_body.length > 0) {
  
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const transaction_body_Data = backupData.transaction_body.map(x => ({
    transaction_header_id: transaction_header_Map[x.transaction_header_id],
    debit: x.debit,
    credit: x.credit,
    row_note: x.row_note,
    item_amount: x.item_amount,
    item_price: x.item_price,
    account_id: accountIdMap[x.account_id] || x.account_id,
    settings_tax_header_id: settings_tax_header_Map[x.settings_tax_header_id] || x.settings_tax_header_id,
    settings_tax_body_id: settings_tax_body_Map[x.settings_tax_body_id] || x.settings_tax_body_id,
    is_tax: x.is_tax,
    dicount_value: x.dicount_value,
    is_discount_percentage: x.is_discount_percentage,
    item_id: accountIdMap[x.item_id] || x.item_id,
    cogs: x.cogs,
    item_location_id_tb: accountIdMap[x.item_location_id_tb] || x.item_location_id_tb,
    is_accumulated_depreciation: x.is_accumulated_depreciation,
    is_production_item: x.is_production_item,
    }));

  // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù‡Ù†Ø§Ùƒ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙŠØªÙ… Ø¥Ø¯Ø®Ø§Ù„Ù‡Ø§
  if (transaction_body_Data.length > 0) {
    const query_transaction_body = pgp.helpers.insert(
      transaction_body_Data,
      ["transaction_header_id", "debit", "credit", "row_note", "item_amount", "item_price", "account_id", "settings_tax_header_id", "settings_tax_body_id",
        "is_tax", "dicount_value", "is_discount_percentage", "item_id", "cogs", "item_location_id_tb", "is_accumulated_depreciation", "is_production_item"
      ],
      "transaction_body"
    );

    await tx.none(query_transaction_body); // ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª
  }
}


// 1ï¸âƒ£5ï¸âƒ£ insert settings_tax_header
if (backupData.effects.length > 0) {
  // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù€ ID Ø¥Ø°Ø§ ÙˆØ¬Ø¯
  const effects_Data = backupData.effects.map(x => ({
    employee_id: accountIdMap[x.employee_id] || x.employee_id,
    company_id: newCompanyId,
    datex: x.datex,
    days: x.days,
    note: x.note,
    last_update: x.last_update,
    user_id: x.user_id,
    hours: x.hours,
    values: x.values,
    reference: x.reference,
  }));

  // Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù€ ID Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…
  const query_effects = pgp.helpers.insert(
    effects_Data,
    ["employee_id", "company_id", "datex", "days", "note", "last_update", "user_id", "hours", "values", "reference"],
    "effects"
  );

  await tx.none(query_effects);
}


// 1ï¸âƒ£6ï¸âƒ£ insert settings_tax_header
if (backupData.todo.length > 0) {
  const todo_Data = backupData.todo
    .filter(x => existingUserIds.has(x.user_id))
    .map(x => ({
      company_id: newCompanyId,
      user_id: x.user_id,
      datex: x.datex,
      is_done: x.is_done,
      text: x.text,
    }));

  if (todo_Data.length > 0) {
    const query_todo = pgp.helpers.insert(
      todo_Data,
      ["company_id", "user_id", "datex", "is_done", "text"],
      "todo"
    );

    await tx.none(query_todo);
  }
}



// 1ï¸âƒ£7ï¸âƒ£ insert production_forms_body
if (backupData.history.length > 0) {
  const history_Data = backupData.history
    .filter(x => existingUserIds.has(x.user_id))
    .map(x => ({
      company_id: newCompanyId,
      user_id: x.user_id,
      datex: x.datex,
      history_type: x.history_type,
      timex: x.timex,
      transactiontype_id: x.transactiontype_id,
      transaction_id: transaction_header_Map[x.transaction_id] || x.transaction_id,
      year: x.year,
      reference: x.reference,
    }));

  if (history_Data.length > 0) {
    const query_history = pgp.helpers.insert(
      history_Data,
      ["company_id", "user_id", "datex", "history_type", "timex", "transactiontype_id", "transaction_id", "year", "reference"],
      "history"
    );

    await tx.none(query_history);
  }
}

//clear restore_old_id befor the end


      // ğŸ‘‡ Ø£Ø¶Ù Ù‡Ù†Ø§ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø¨Ù†ÙØ³ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©...

    });

    res.json({ message: "âœ… ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­!" });

  } catch (error) {
    console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:", error);
    res.status(500).json({ error: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ù„Ù… ÙŠØªÙ… Ø­Ø°Ù Ø£Ùˆ ØªØ¹Ø¯ÙŠÙ„ Ø£ÙŠ Ø´ÙŠØ¡." });
  }
});



function formatFromFiveDigits(num) {
  try {

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø±Ù‚Ù… Ù„ÙŠØ³ Ø³Ø§Ù„Ø¨Ù‹Ø§
  if (num < 0) {
      throw new Error("Ø§Ù„Ø±Ù‚Ù… Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ø³Ø§Ù„Ø¨Ù‹Ø§");
  }
  
  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø±Ù‚Ù… Ù„Ø§ ÙŠØªØ¬Ø§ÙˆØ² 5 Ø£Ø±Ù‚Ø§Ù…
  if (num > 99999) {
      throw new Error("Ø§Ù„Ø±Ù‚Ù… Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØªØ¬Ø§ÙˆØ² 5 Ø£Ø±Ù‚Ø§Ù…");
  }
  
  // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø±Ù‚Ù… Ø¥Ù„Ù‰ ØµÙŠØºØ© Ù…ÙƒÙˆÙ†Ø© Ù…Ù† 5 Ø£Ø±Ù‚Ø§Ù… Ù…Ø¹ Ø£ØµÙØ§Ø± Ø¨Ø§Ø¯Ø¦Ø©
  return num.toString().padStart(5, '0');
      
} catch (error) {
  throw new Error('Error formatFromFiveDigits')
}
}



async function history(int_transactionTypeId, int_1Add_2Update_3Delete , transaction_id, reference, req, tx) {
  // Ø§Ø­Ø³Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ
  try {


    
    const timex = timeNow();
    // const id = await newId_fn('history', 'id');

    // Ù‚Ù… Ø¨ØªÙ†ÙÙŠØ° Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… `db.none`
    const query = `
      INSERT INTO history (user_id, transactionType_id, history_type, datex, timex, transaction_id, reference, company_id)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8);
    `;

    const params = [
                    req.session.userId,
                    int_transactionTypeId,
                    int_1Add_2Update_3Delete,
                    today,
                    timex,
                    transaction_id,
                    reference,
                    req.session.company_id];

    await tx.none(query, params);
  } catch (error) {
    console.error("Error while inserting history:", error);
    throw new Error("Error while inserting history Code-S-history1"); // Ø¥Ù„Ù‚Ø§Ø¡ Ø®Ø·Ø£ Ù…Ø¹ Ø±Ø³Ø§Ù„Ø© Ù…Ø®ØµØµØ©
  }
}






//#region global variables
const is_forbidden_adding_branches = [1, 2, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 8, 19, 20, 21, 22, 23];
const is_accumulated_account = [9, 10, 11, 12, 13, 14, 15, 20];
//#endregion



function checkPasswordStrength(password) {
  const length = password.length; // Ø­Ø³Ø§Ø¨ Ø·ÙˆÙ„ Ø§Ù„Ù†Øµ
  const hasLetters = /[a-zA-Z]/.test(password); // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø­Ø±ÙˆÙ
  const hasNumbers = /[0-9]/.test(password); // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø£Ø±Ù‚Ø§Ù…
  const hasSpecialChars = /[^a-zA-Z0-9]/.test(password); // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø±Ù…ÙˆØ² Ø®Ø§ØµØ©

  return {
      length,
      hasLetters,
      hasNumbers,
      hasSpecialChars,
      isStrong: length >= 8 && hasLetters && hasNumbers // Ø´Ø±Ø· Ù‚ÙˆØ© Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
  };
}



// const globalLimiter = rateLimit({
//   windowMs: 1000 * 60 * 1, // 1 Ø¯Ù‚ÙŠÙ‚Ø©
//   max: 10, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„ÙˆØµÙˆÙ„
//   message: 'Too many requests, please try again after a minute',
//   skipFailedRequests: true, // ØªØ®Ø·ÙŠ Ø§Ù„ÙØ´Ù„ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª
//   handler: (req, res, next) => {
//     res.status(429).json({
//       success: false,
//       message_ar: 'Too many requests, please try again after a minute',
//     });
//   }
// });

// // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø¹Ø¯Ù„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
// app.use(globalLimiter);

//#region Login

// Ø¥Ø¹Ø¯Ø§Ø¯ limiter ÙÙ‚Ø· Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
const loginLimiter = rateLimit({
  windowMs: 1000 * 60 * 1, // Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©
  max: 3, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„
  message: 'Too many login attempts from this IP, please try again after 1 minute',
  skipFailedRequests: true, // Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØªØ®Ø·Ù‰ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
  handler: (req, res, next) => {
    // Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù†Ø§ ÙÙŠ Ø­Ø§Ù„Ø© ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯
    return res.json({
      success: false,
      message_ar: 'Too many login attempts from this IP, please try again after 1 minute',
    });
  },
});

const deleteLimiter = rateLimit({
  windowMs: 1000 * 60 * 1, // Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©
  max: 2, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„
  message: 'Too many login attempts from this IP, please try again after 1 minute',
  skipFailedRequests: true, // Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØªØ®Ø·Ù‰ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
  handler: (req, res, next) => {
    // Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù†Ø§ ÙÙŠ Ø­Ø§Ù„Ø© ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯
   return res.json({
      success: false,
      message_ar: 'Too many delete attempts from this IP, please try again after 1 minute',
    });
  },
});


const registerLimiter = rateLimit({
  windowMs: 1000 * 60 * 60, // Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©
  max: 3, // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„
  message: 'Too many login attempts from this IP, please try again after 60 minute',
  skipFailedRequests: true, // Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØªØ®Ø·Ù‰ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
  handler: (req, res, next) => {
    // Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù†Ø§ ÙÙŠ Ø­Ø§Ù„Ø© ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯
    return res.json({
      success: false,
      message_ar: 'Too many register attempts from this IP, please try again after 60 minute',
    });
  },
});




app.post("/register_request", registerLimiter, async (req, res) => {
  try {
        // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;

    // //! Permission
    // await permissions(req, "customers_permission", "add");
    // if (!permissions) {
    //   return;
    // }



    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);


    if (!posted_elements.account_name_input){
      return res.json({ success: false, message_ar:  'âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ù„Ùƒ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­' });
  }

  if (!posted_elements.phone_input){
      return res.json({ success: false, message_ar:  'âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­' });
  }

  if (!posted_elements.email_input){
      showAlert(`warning`, 'âš ï¸Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø§Ù„ÙƒØªØ±ÙˆÙ†Ù‰ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­')
      return
  }

  if (!posted_elements.massage_input){
      return res.json({ success: false, message_ar:  'âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù†Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­' });
    }
  
  if (!posted_elements.user_name_input){
    return res.json({ success: false, message_ar: 'âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­' });
  }

  if (!posted_elements.user_pass_input1 || !posted_elements.user_pass_input2){
      return res.json({ success: false, message_ar: 'âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­' });
  }

  if (posted_elements.user_pass_input1 !== posted_elements.user_pass_input2){
      return res.json({ success: false, message_ar: 'âš ï¸ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©' });
  }


  const strong_pass = checkPasswordStrength(posted_elements.user_pass_input1);
  
  if (!strong_pass.isStrong){
    return res.json({ success: false, message_ar: 'âš ï¸ Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù‚ÙˆÙŠØ©' });
  }

    //* Start--------------------------------------------------------------

  let query01 = `select count(id) as user_name_count from users where user_name = $1`
  let result01 = await db.oneOrNone(query01, [posted_elements.user_name_input])
  if (result01.user_name_count > 0){
    return res.json({ success: false, message_ar: 'âš ï¸ Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø§Ø®Ø±' });
  }



    //! ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù‚Ø¨Ù„ Ø¥Ø¯Ø®Ø§Ù„Ù‡Ø§ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const pass_input1 = await bcrypt.hash(posted_elements.user_pass_input1, 12);
    let query1 = `
    INSERT INTO registration_requests (datex, owner_name, owner_phone, owner_email, owner_message, owner_use_name, owner_user_pass)
    VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id;
  `;

    await db.tx(async (tx) => {
      const insert = await tx.one(query1, [
        today,
        posted_elements.account_name_input,
        posted_elements.phone_input,
        posted_elements.email_input,
        posted_elements.massage_input,
        posted_elements.user_name_input,
        pass_input1
      ]);

      const newId_header = insert.id;


    })

    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ø­ÙŠÙ† Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø·Ù„Ø¨ ÙˆØ§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª Ù…Ù…ÙƒÙ†.",
    });
  } catch (error) {
    console.error("Error register_request:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


async function accept_request(request_id, companies_limit, users_limit, startr_dat, end_date) {
  try {
    
  
    console.log(`accept_request started`);
    
    let request_data = await db.oneOrNone(`select * from registration_requests where id = $1`, [request_id])
  
    if (!request_data){
      console.log(`request id (${request_id}) is not defined`)
      return
    }

    if (request_data.is_accepted){
      console.log(`this Regetser Request with id (${request_id}) is Already accepted befor`)
      return
    }
  
    //const pass_input1 = await bcrypt.hash(posted_elements.user_pass_input1, 12);
  
    await db.tx(async (tx) => {
  
    
    let query1 = `
    INSERT INTO owners (owner_name, owner_phone, owner_email, owner_started_date, owner_contract_expire_date, owner_number_of_companies_allowed, owner_number_of_users_allowed)
    VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id;
  `;
  
      const insert = await tx.one(query1, [
        request_data.owner_name,
        request_data.owner_phone,
        request_data.owner_email,
        startr_dat,
        end_date,
        companies_limit,
        users_limit
      ]);
  
      const newId_owner = insert.id;
  
      let insert_Query = `INSERT INTO users (user_name, user_password, datex, owner_id, user_full_name, is_owner, is_owner_permission)
        VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id;`
      let params = [request_data.owner_use_name, request_data.owner_user_pass, today, newId_owner, request_data.owner_name, true, true]
      
      const insert2 = await tx.one(insert_Query, params)
      const user_id = insert2.id 
  
      let update_Query = `UPDATE registration_requests set is_accepted = true where id = $1`
      await tx.none(update_Query, [request_id])

      console.log(`request accespted sucssfully , owner_id: ${newId_owner}, user_id: ${user_id} `);
    })
  
   
    
  
  } catch (error) {
    console.error("Error register_request:", error);
  }
  }

  async function change_user_password(user_id, new_pass) {
    try {
      
    
      console.log(`change_user_password started`);
      
    
      const pass = await bcrypt.hash(new_pass, 12);
    
      await db.tx(async (tx) => {
    
      
      let query1 = `
      UPDATE users set user_password = $1 where id = $2 RETURNING id;
    `;
    
        const insert = await tx.one(query1, [
          pass,
          user_id
        ]);
    
        const userId = insert.id;
    
        console.log(`request password changed sucssfully , user_id: ${userId} `);
      })
    
     
      
    
    } catch (error) {
      console.error("Error register_request:", error);
    }
    }
  
  
app.post("/Login", loginLimiter, async (req, res) => {
  try {

   
    //1: receive data from frontend html>body
    const posted_elements = req.body;

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.username_Input,
      posted_elements.password_Input,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* start --------------------------------------------------

    //2: get Today
    

    let query = `SELECT * FROM users WHERE TRIM(user_name) = $1`;
    let rows = await db.any(query, [posted_elements.username_Input]);

    if (rows.length > 0) {
      const password_DB = rows[0].user_password;
      const password_Input = posted_elements.password_Input;
      const isMatch = await bcrypt.compare(password_Input, password_DB);
      const is_active = rows[0].is_active;
      if (is_active) {
        return res.json({
          success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡ ÙØ´Ù„Øª
          message_ar: `âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù†Ø´Ø· Ø¨Ø§Ù„ÙØ¹Ù„ ..Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„ `,
        });
        // let currentId = parseInt(rows[0].id)


        // io.emit('active_user', { username: posted_elements.username_Input });
        // console.log(`thisi is currentId = ${currentId} typeof ${typeof(currentId)}`);
     //   await khorogFawry(req,currentId)
      //  return res.json({
        //  success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡ ÙØ´Ù„Øª
         // type : 'khorogFawary',
         // message_ar: `âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù†Ø´Ø· Ø¨Ø§Ù„ÙØ¹Ù„ ..Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„ `,
         // message_en: "âš ï¸ this user is already active Please try again after minutes",
        //});
      }

      if (isMatch) {
        
        if(rows[0].is_try_hack && rows[0].is_try_hack === true){
          req.session.destroy();
          return res.json({
            success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡ ÙØ´Ù„Øª
            xx: true,
            message_ar: "âŒ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ ØªÙ… ØªØ¬Ù…ÙŠØ¯Ù‡ Ù…Ù† Ù‚Ø¨Ù„ : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø§Ø¯Ø§Ø±Ù‡",
          });
        }

        if(rows[0].is_stop && rows[0].is_stop === true){
          req.session.destroy();
          return res.json({
            success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡ ÙØ´Ù„Øª
            xx: true,
            message_ar: "âŒ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ ØªÙ… Ø§ÙŠÙ‚Ø§ÙÙ‡ Ù…Ù† Ù‚Ø¨Ù„ Ù…Ø¯ÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù… : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø§Ø¯Ø§Ø±Ù‡",
          });
        }
        //!4.1.1: Start new session
        const forwardedIpsStr = req.headers['x-forwarded-for'];
        let ipAddress;
        if (forwardedIpsStr) {
          // Ø§Ù„Ø³Ù„Ø³Ù„Ø© ÙŠÙ…ÙƒÙ† Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¹Ø¯Ø© Ø¹Ù†Ø§ÙˆÙŠÙ† Ù…ÙØµÙˆÙ„Ø© Ø¨ÙØ§ØµÙ„Ø©ØŒ Ø®Ø° Ø£ÙˆÙ„ Ø¹Ù†ÙˆØ§Ù†
          const forwardedIps = forwardedIpsStr.split(',');
          ipAddress = forwardedIps[0].trim();
        } else {
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ø±Ø£Ø³ Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ù…Ù† socket
          ipAddress = req.socket.remoteAddress;
        }
       
        let query2 = `SELECT id, transaction_type_name FROM transaction_type`;
        let rows2 = await db.any(query2);

        req.session.transaction_table = rows2


        req.session.isLoggedIn = true; // active session
        req.session.ipAddress = ipAddress; // get IP 
        req.session.userId = parseInt(rows[0].id);
        req.session.username = rows[0].user_name; // Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ØŒ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ®Ø²ÙŠÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        req.session.userFullName = rows[0].user_full_name; // Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ØŒ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ®Ø²ÙŠÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        req.session.owner_id = rows[0].owner_id;
        req.session.is_owner = rows[0].is_owner;
        req.session.is_owner_permission = rows[0].is_owner_permission;

        let query = `UPDATE users SET is_active = true WHERE id = $1`;
        await db.any(query, [req.session.userId]);


        
        res.json({
          // Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„ ÙØ±ÙˆÙ†Øª Ø§Ù†Øª Ø§Ù†Ø¯
          success: true, // Ù…Ø¹Ù†Ø§Ù‡ Ø§Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡ Ù†Ø¬Ø­Øª Ù„Ùˆ ÙØ´Ù„Øª Ù‡ØªØ¨Ù‚Ø§ ÙØ§Ù„Ø³
          message_ar: `âœ… Welcome back, ${req.session.username}!`, // Ø¯Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø§Ù„Ù‰ Ù‡ØªØ±ÙˆØ­ Ù„Ù„Ø¹Ù…ÙŠÙ„
          user_id: parseInt(rows[0].id),
          username: rows[0].user_name,
          user_full_name: rows[0].user_full_name,
          is_owner: rows[0].is_owner,
          is_owner_permission: rows[0].is_owner_permission,
        });

        last_activity(req);
      } else {
        //4.2.1: send response to front with some data
        res.json({
          success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡ ÙØ´Ù„Øª
          message_ar: error.message || "âŒ Invalid username or password",
        });
      }
    } else {
      res.json({
        success: false,
        message_ar: error.message || "âŒ Invalid username or password",

      });
    }
  } catch (error) {
    console.error("Login Error:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || 'âŒ Login Error',

    });
  }
});

// Endpoint for user logout
app.get("/Logout", async (req, res) => {
  try {
    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      req.session.userId,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* start-----------------------------------
    // // ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ userId ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø©
    // if (!req.session.userId) {
    //   return res.status(400).json({
    //     success: false,
    //     message_ar: "User not logged in"
    //   });
    // }

    let query = `UPDATE users SET is_active = false WHERE id = $1`;
    await db.none(query, [req.session.userId]);
    // ØªØ­Ø¯ÙŠØ« is_active Ø¥Ù„Ù‰ false ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¨Ù„ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©
    // await db.none("UPDATE users SET is_active = false WHERE id = $1", [req.session.userId]);

    // Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©
    req.session.destroy((error) => {
      if (error) {
        console.error("Logout Error:", error);
        res.status(500).json({ success: false, message_ar: "âŒ Logout Error" });
      } else {
        res.json({ success: true, message_ar: "âœ… Logout successful" });
      }
    });
  } catch (error) {
    console.error("Logout Error:", error);
    res.status(500).json({ success: false, message_ar: "âŒ Logout Error" });
  }
});


app.post("/delete_company", deleteLimiter, async (req, res) => {
  try {

   
    //1: receive data from frontend html>body
    const posted_elements = req.body;

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* start --------------------------------------------------

    //!check
    const company_name = posted_elements.x1Val
    const user_pass = posted_elements.x2Val
    const owner_pass = posted_elements.x3Val
    

    if (!company_name || !user_pass || !owner_pass){
      return res.json({
        success: false,
        message_ar: `âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`,
      });
    }




 //! ÙØ­Øµ Ø¨Ø§Ø³ÙˆØ±Ø¯Ø§Øª Ø§Ù„Ù…Ø§Ù„Ùƒ
    let q1 = `
    select
	us.user_password
from
	users us
inner join owners o on o.id = us.owner_id	
inner join companies c on c.owner_id = o.id
where
	c.id = $1
	and us.is_owner_permission is true
	and us.is_stop is null
	and us.is_try_hack is null
    `
    let db_owner_pass_Array = await db.any(q1, [req.session.company_id]) || []

    if (db_owner_pass_Array.length === 0){
      return res.json({
        success: false,
        message_ar: `âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sdc01`,
      });
    }

     
  let is_owner_pass = false
  for (const row of db_owner_pass_Array){    
    const isMatch = await bcrypt.compare(owner_pass, row.user_password);
    if (isMatch){
      is_owner_pass = true
      break;
    }
  }
  
  if (!is_owner_pass) {
    return res.json({
      success: false,
      message_ar: `âŒ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©`,
    });
  }

  
  //! ÙØ­Øµ Ø¨Ø§Ø³ÙˆØ±Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ø³Ù… Ø§Ù„Ø´Ø±ÙƒØ©

    let query0 = `
    SELECT 
      (SELECT c.company_name from companies c WHERE c.id = $1 and c.owner_id = $2) AS company_name,
      (select user_password from users where id = $3 and users.owner_id = $2) AS user_pass
  `;
  


  let result0 = await db.oneOrNone(query0, [req.session.company_id, req.session.owner_id, req.session.userId]);
  
  if (!result0 || !result0.company_name || !result0.user_pass) {
    return res.json({
      success: false,
      message_ar: `âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sdc02`,
    });
  }

  let isMatch2 = await bcrypt.compare(user_pass, result0.user_pass);
  let isMatch3 = result0.company_name === company_name;




  if (!isMatch2 || !isMatch3){
    return res.json({
      success: false,
      message_ar: `âŒ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©`,
    });
  }

  
    //---------------------------

    let query = `DELETE FROM companies where id = $1`;
    let rows = await db.any(query, [req.session.company_id]);

    await khorogFawry(req,req.session.userId)
    // req.session.destroy();
    

    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„ØªØ¬Ø§Ø±Ù‰ Ø¨Ù†Ø¬Ø§Ø­",
    });
   
  
        last_activity(req);
  } catch (error) {
    last_activity(req);
    console.error("delete_company Error:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',

    });
  }
});
//#endregion End-Login

//#region Templets
//! Permission function
async function permissions(req, secendary_permission, perm_type) {
    const owner = req.session.is_owner_permission;
    if (owner) {
      return true;
    } else {
      const permissions = await db.any(
        `select general_permission, ${secendary_permission} from user_company where user_id = $1 AND company_id = $2`,
        [req.session.userId, req.session.company_id]
      );
      const X1 = permissions[0].general_permission;
      const X2 = permissions[0][secendary_permission];
      switch (perm_type) {
        case "view":
          if (X1 > 1 || X2 > 0) {
            return true;
          } else {
            res.json({
              success: false,
              message_ar: "âŒ  Ø¹ÙÙˆÙ‹Ø§ Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¹Ø±Ø¶",
            });
            return false;
          }
        case "add":
          if (X1 > 2 || X2 > 1) {
            return true;
          } else {
            res.json({
              success: false,
              message_ar: "âŒ  Ø¹ÙÙˆÙ‹Ø§ Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø§Ø¶Ø§ÙØ©",
            });
            return false;
          }
        case "update":
          if (X1 > 3 || X2 > 2) {
            return true;
          } else {
            res.json({
              success: false,
              message_ar: "âŒ  Ø¹ÙÙˆÙ‹Ø§ Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„",
            });
            return false;
          }
        case "delete":
          if (X1 > 4 || X2 > 3) {
            return true;
          } else {
            res.json({
              success: false,
              message_ar: "âŒ  Ø¹ÙÙˆÙ‹Ø§ Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø°Ù",
            });
            return false;
          }
      }
    }

}

// get new id ( table foreign Key)
async function newId_fn(tableName_string,columnName_string) {
  // Ù‚Ù… Ø¨ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
  const query = await db.any(`SELECT MAX(${columnName_string}) AS id FROM ${tableName_string}`);

  // Ø§ÙØªØ±Ø§Ø¶ Ø£Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù‡Ùˆ 1 Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø£ÙŠ Ø³Ø¬Ù„Ø§Øª
  let result = 1;

  // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† `query` ÙØ§Ø±ØºÙ‹Ø§ Ø£Ùˆ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù‚ÙŠÙ…Ø© ÙÙŠ `query[0].id`
  if (query && query.length > 0 && query[0].id !== null) {
    result = parseInt(query[0].id) + 1;
  }

  // Ø§Ø±Ø¬Ø¹ `result`
  return result;
}



async function newReference_fn(str_tableName, year, req) {
  try {
    const query1 = `
      SELECT
        MAX(reference) AS max
      FROM
        ${str_tableName} -- ÙƒÙ† Ø­Ø°Ø±Ù‹Ø§ Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
      WHERE
        company_id = $1
         AND datex LIKE '${year}-%'; -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø³Ù†Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ§Ø±ÙŠØ®

    `;

    const Params1 = [req.session.company_id];
    const result = await db.oneOrNone(query1, Params1);

    
    let new_reference = 1;
    if (result && result.max && result.max > 0) {
      
      new_reference = +result.max + 1;
    }

    return new_reference; // ÙŠØ¬Ø¨ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©

    
  

  } catch (error) {
    throw new Error(`Failed to retrieve reference: ${error.message}`);
  }
}


async function newReference_transaction_header_fn(str_tableName, int_transaction_type, year, req) {
  try {
    const query1 = `
      SELECT
        MAX(reference) AS max
      FROM
        ${str_tableName} -- ÙƒÙ† Ø­Ø°Ø±Ù‹Ø§ Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
      WHERE
        company_id = $1
        AND transaction_type = $2
         AND datex LIKE '${year}-%'; -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø³Ù†Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ§Ø±ÙŠØ®

    `;

    const Params1 = [req.session.company_id, int_transaction_type];
    const result = await db.oneOrNone(query1, Params1);

    
    let new_reference = 1;
    if (result && result.max && result.max > 0) {
      
      new_reference = +result.max + 1;
    }

    return new_reference; // ÙŠØ¬Ø¨ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©


  } catch (error) {
    throw new Error(`Failed to retrieve reference: ${error.message}`);
  }
}

// last activity
async function last_activity(req) {

  try {
    await db.none(
      `
      UPDATE users
      SET last_activity = NOW(), last_activity_ip = $1
      WHERE id = $2
  `,[
    req.session.ipAddress,
    req.session.userId]
    );
  } catch (error) {
    console.error("Error last_activity:", error);
  }

}


let closingDate_message_ar = `ØªÙ… Ø§ØºÙ„Ø§Ù‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙÙ‰ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙÙ‰ Ù‡Ø°Ø§ Ø§Ù„ØªØ§Ø±ÙŠØ® `
// async function ClosingDate_is_Allow(transaction_date, req) {
//   try {
//     let query1 = `SELECT datex1 FROM settings WHERE company_id = $1 AND setting_type_id = $2`;
//     let params1 = [req.session.company_id, 1];
//     let result = await db.oneOrNone(query1, params1);

//     if (!result) {
//       return false;
//     }

//     const closingDate = result.datex1;

//     const dateFormatRegex = /^\d{4}-\d{2}-\d{2}$/;

//     // ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ®
//     if (!dateFormatRegex.test(transaction_date) || !dateFormatRegex.test(closingDate)) {
//       return false;
//     }

//     // ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù†Ø§Øª Date Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
//     const transactionDateObj = new Date(transaction_date);
//     const closingDateObj = new Date(closingDate);

//     // Ø¥Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø¨Ù„ Ø£Ùˆ ÙŠØ³Ø§ÙˆÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ØŒ Ø§Ø±Ø¬Ø¹ false
//     if (transactionDateObj <= closingDateObj) {
//       return false;
//     }

//     return true;
//   } catch (error) {
//     throw new Error(`Error while checking closingDate: ${error.message}`);
//   }
// }


// async function check_settings_validation(options = {}, req) {
//   try {

//     if (options.type === 'add' || options.type === 'update' || options.type === 'delete'){
//     // Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø±ÙƒØ©
//     const query1 = `SELECT * FROM settings WHERE company_id = $1`;
//     const params1 = [req.session.company_id];
//     const result = await db.any(query1, params1);

//     if (!result) {
//       return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR500ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ" };
//     }


//     // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ®

//     // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ
//       const isPreventFutureDate = result.find(item => item.setting_type_id === 2)?.boolean1;

//       const closingDate = result.find(item => item.setting_type_id === 1)?.datex1;

  
//       const InValidDateFormat = isInValidDateFormat([closingDate])
//       if (InValidDateFormat){
//         return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR518ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
//       }


//           if (options.type === 'add'){
//             if (options.datex){

//               const datex = options.datex
//               const InValidDateFormat = isInValidDateFormat([datex])
//               if (InValidDateFormat){
//                 return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR519ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
//               }

//               /*
//               //! check if update date out of orignal year 
//               const originalYear = getYear(originalDatex)
//               const datex_year = getYear(datex)
//               if (options.type === 'update' && originalYear !== datex_year){
//                 return { valid: false, message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø®Ø§Ø±Ø¬ Ø§Ù„Ø³Ù†Ù‡ Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ù„Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§ØµÙ„Ù‰" };
//               }
//               */

//               //! check closingDate
//               if (datex <= closingDate) {
//                 return { valid: false, message_ar: "ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©." };
//               }

//               //! check futureDate prevent
//               if (options.check_futureDate && isPreventFutureDate) {
//                 if (datex > today) {
//                   return { valid: false, message_ar: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ø¥Ø¯Ø®Ø§Ù„ ØªØ§Ø±ÙŠØ® ÙŠØªØ¬Ø§ÙˆØ² ØªØ§Ø±ÙŠØ® Ø§Ù„ÙŠÙˆÙ…. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ù…Ø¯ÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù…." };
//                 }
//               }
              
//             }else{
//               return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR525ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
//             }
//           }



//           if (options.type === 'update' || options.type === 'delete'){
//             const query2 = `SELECT datex FROM ${options.tableName} WHERE id = $1 AND company_id = $2`;
//             const params2 = [options.transaction_id, req.session.company_id];
//             let result1 = await db.oneOrNone(query2, params2);
          
//           const originalDatex = result1.datex
          

//           const InValidDateFormat = isInValidDateFormat([originalDatex])
//           if (InValidDateFormat){
//             return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR518ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
//           }

//           if (options.type === 'update'){
//             if (options.tableName && options.transaction_id && options.datex){

//               const datex = options.datex
//               const InValidDateFormat = isInValidDateFormat([datex])
//               if (InValidDateFormat){
//                 return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR519ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
//               }

//               //! check if update date out of orignal year 
//               const originalYear = getYear(originalDatex)
//               const datex_year = getYear(datex)

              
//               if (options.type === 'update' && originalYear !== datex_year){
//                 return { valid: false, message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø®Ø§Ø±Ø¬ Ø§Ù„Ø³Ù†Ù‡ Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ù„Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§ØµÙ„Ù‰" };
//               }

//               //! check closingDate
//               if (originalDatex <= closingDate || datex <= closingDate) {
//                 return { valid: false, message_ar: "ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©." };
//               }

//               //! check futureDate prevent
//               if (options.check_futureDate && isPreventFutureDate) {
//                 if (datex > today) {
//                   return { valid: false, message_ar: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ø¥Ø¯Ø®Ø§Ù„ ØªØ§Ø±ÙŠØ® ÙŠØªØ¬Ø§ÙˆØ² ØªØ§Ø±ÙŠØ® Ø§Ù„ÙŠÙˆÙ…. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ù…Ø¯ÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù…." };
//                 }
//               }
              
//             }else{
//               return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR526ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
//             }
//           }
//           if(options.type === 'delete'){
//             if (originalDatex <= closingDate) {
//               return { valid: false, message_ar: "ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©." };
//             }
//           }
//           }


//     return { valid: true };
//   }else{
//     return { valid: false, message_ar: `An Error Accoured code AR530` };
//   }
//   } catch (error) {
//     throw new Error(`Error while checking settings: ${error.message}`);
//   }
// }



async function check_settings_validation(options = {}, req) {
  try {
    if (options.type === 'add' || options.type === 'update' || options.type === 'delete') {
      // Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø±ÙƒØ©
      const query1 = `SELECT * FROM settings WHERE company_id = $1`;
      const params1 = [req.session.company_id];
      const result = await db.any(query1, params1);

      if (!result) {
        return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR500ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ" };
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
      const isPreventFutureDate = result.find(item => item.setting_type_id === 2)?.boolean1;
      const closingDate = result.find(item => item.setting_type_id === 1)?.datex1 || null; // ØªØ£ÙƒÙŠØ¯ Ø£Ù† `closingDate` Ø¥Ù…Ø§ ØªØ§Ø±ÙŠØ® Ø£Ùˆ `null`

      const InValidDateFormat = isInValidDateFormat([closingDate].filter(Boolean)); // Ø§Ù„ØªØ­Ù‚Ù‚ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† `closingDate` Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
      if (InValidDateFormat) {
        return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR518ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
      }

      if (options.type === 'add') {
        if (options.datex) {
          const datex = options.datex;
          const InValidDateFormat = isInValidDateFormat([datex]);
          if (InValidDateFormat) {
            return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR519ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
          }

          //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ (ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§)
          if (closingDate && datex <= closingDate) {
            return { valid: false, message_ar: "ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©." };
          }

          //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ù†Ø¹ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©
          if (options.check_futureDate && isPreventFutureDate && datex > today) {
            return { valid: false, message_ar: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ø¥Ø¯Ø®Ø§Ù„ ØªØ§Ø±ÙŠØ® ÙŠØªØ¬Ø§ÙˆØ² ØªØ§Ø±ÙŠØ® Ø§Ù„ÙŠÙˆÙ…. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ù…Ø¯ÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù…." };
          }
        } else {
          return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR525ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
        }
      }

      if (options.type === 'update' || options.type === 'delete') {
        const query2 = `SELECT datex FROM ${options.tableName} WHERE id = $1 AND company_id = $2`;
        const params2 = [options.transaction_id, req.session.company_id];
        let result1 = await db.oneOrNone(query2, params2);

        const originalDatex = result1?.datex || null; // ØªØ£ÙƒÙŠØ¯ Ø£Ù† `originalDatex` Ù„ÙŠØ³ `null`

        const InValidDateFormat = isInValidDateFormat([originalDatex].filter(Boolean));
        if (InValidDateFormat) {
          return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR518ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
        }

        if (options.type === 'update') {
          if (options.tableName && options.transaction_id && options.datex) {
            const datex = options.datex;
            const InValidDateFormat = isInValidDateFormat([datex]);
            if (InValidDateFormat) {
              return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR519ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
            }

            //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©
            const originalYear = getYear(originalDatex);
            const datex_year = getYear(datex);
            if (originalDatex && originalYear !== datex_year) {
              return { valid: false, message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø®Ø§Ø±Ø¬ Ø§Ù„Ø³Ù†Ù‡ Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ù„Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§ØµÙ„Ù‰" };
            }

            //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ (ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§)
            if (closingDate && (originalDatex <= closingDate || datex <= closingDate)) {
              return { valid: false, message_ar: "ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©." };
            }

            //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ù†Ø¹ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©
            if (options.check_futureDate && isPreventFutureDate && datex > today) {
              return { valid: false, message_ar: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ø¥Ø¯Ø®Ø§Ù„ ØªØ§Ø±ÙŠØ® ÙŠØªØ¬Ø§ÙˆØ² ØªØ§Ø±ÙŠØ® Ø§Ù„ÙŠÙˆÙ…. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ù…Ø¯ÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù…." };
            }
          } else {
            return { valid: false, message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ AR526ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ." };
          }
        }

        if (options.type === 'delete') {
          if (closingDate && originalDatex <= closingDate) {
            return { valid: false, message_ar: "ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©." };
          }
        }
      }

      return { valid: true };
    } else {
      return { valid: false, message_ar: `An Error Accoured code AR530` };
    }
  } catch (error) {
    throw new Error(`Error while checking settings: ${error.message}`);
  }
}


// function turn_EmptyValues_TO_null(object_Var){
//   for (let key in object_Var) {
//     if (object_Var[key] === "") {
//       object_Var[key] = null;
//     }
//   }
// }

/*
function turn_EmptyValues_TO_null(object_Var) {
  for (let key in object_Var) {
    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© Ø¹Ø¨Ø§Ø±Ø© Ø¹Ù† Ù…ØµÙÙˆÙØ©
    if (Array.isArray(object_Var[key])) {
      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ø¨Ø± Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
      object_Var[key].forEach(item => {
        if (typeof item === 'object' && item !== null) {
          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ù†ØµØ± ÙƒØ§Ø¦Ù†ØŒ Ù†ÙØ­Øµ Ø®ØµØ§Ø¦ØµÙ‡
          turn_EmptyValues_TO_null(item); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù†ÙØ³Ù‡Ø§ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù†
        }
      });
    } else if (typeof object_Var[key] === 'object' && object_Var[key] !== null) {
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© ÙƒØ§Ø¦Ù†ØŒ Ù†ÙØ­Øµ Ø®ØµØ§Ø¦ØµÙ‡
      turn_EmptyValues_TO_null(object_Var[key]);
    } else if (object_Var[key] === "" || object_Var[key] === 0) {
      // Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
      // console.log(`Changing: ${key} = ${object_Var[key]}`);
      object_Var[key] = null; // ØªØºÙŠÙŠØ± Ø§Ù„Ù‚ÙŠÙ…Ø© Ø¥Ù„Ù‰ null
      // Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
      // console.log(`Changed: ${key} = ${object_Var[key]}`);
    }
  }
}
*/
/*
function turn_EmptyValues_TO_null(object_Var) {
  for (let key in object_Var) {
    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© Ø¹Ø¨Ø§Ø±Ø© Ø¹Ù† Ù…ØµÙÙˆÙØ©
    if (Array.isArray(object_Var[key])) {
      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ø¨Ø± Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
      object_Var[key].forEach(item => {
        if (typeof item === 'object' && item !== null) {
          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ù†ØµØ± ÙƒØ§Ø¦Ù†ØŒ Ù†ÙØ­Øµ Ø®ØµØ§Ø¦ØµÙ‡
          turn_EmptyValues_TO_null(item); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù†ÙØ³Ù‡Ø§ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù†
        }
      });
    } else if (typeof object_Var[key] === 'object' && object_Var[key] !== null) {
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© ÙƒØ§Ø¦Ù†ØŒ Ù†ÙØ­Øµ Ø®ØµØ§Ø¦ØµÙ‡
      turn_EmptyValues_TO_null(object_Var[key]);
    } else if (object_Var[key] === "" || object_Var[key] === 0 || parseFloat(object_Var[key]) === 0) {
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© ÙØ§Ø±ØºØ©ØŒ ØªØºÙŠÙŠØ±Ù‡Ø§ Ø¥Ù„Ù‰ null
      object_Var[key] = null;
    } else if (typeof object_Var[key] === "number") {
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© Ø±Ù‚Ù…ÙŠØ©ØŒ Ù†Ù‚ÙˆÙ… Ø¨ØªÙ‚Ø±ÙŠØ¨Ù‡Ø§ Ù„Ø£Ù‚Ø±Ø¨ Ø±Ù‚Ù…ÙŠÙ† Ø¹Ø´Ø±ÙŠÙŠÙ†
      object_Var[key] = parseFloat(object_Var[key].toFixed(2));
    }
  }
}
*/


function turn_EmptyValues_TO_null(object_Var) {
  for (let key in object_Var) {
    if (Array.isArray(object_Var[key])) {
      object_Var[key].forEach(item => {
        if (typeof item === 'object' && item !== null) {
          turn_EmptyValues_TO_null(item);
        }
      });
    } else if (typeof object_Var[key] === 'object' && object_Var[key] !== null) {
      turn_EmptyValues_TO_null(object_Var[key]);
    } else if (typeof object_Var[key] === 'string') {
      object_Var[key] = object_Var[key].trim();
      if (object_Var[key] === "" || object_Var[key] === "0") {
        object_Var[key] = null;
      }
    } else if (object_Var[key] === 0 || parseFloat(object_Var[key]) === 0) {
      object_Var[key] = null;
    } else if (typeof object_Var[key] === 'number') {
      object_Var[key] = parseFloat(object_Var[key].toFixed(2));
      if (object_Var[key] < 0) {
        throw new Error(`Ø§Ù„Ù‚ÙŠÙ…Ø© ${key} ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø³Ø§Ù„Ø¨ (${object_Var[key]})`);
      }
    }
  }
}


// sql injection
let sql_injection_message_ar = "ØªÙ… Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ø¨Ø³Ø¨Ø¨ ÙˆØ¬ÙˆØ¯ Ø±Ù…ÙˆØ² Ù…Ù…Ù†ÙˆØ¹Ø©. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
let sql_injection_message_en =  "Invalid input detected due to prohibited characters. Please review your input and try again."
function sql_anti_injection(values) {
  // ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„ Ù‚ÙŠÙ…Ø© ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
  
  if(!values){
    return;
  }


  for (let value of Object.values(values)) {
    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© null Ø£Ùˆ undefined Ø£Ùˆ Ø¹Ø¯Ø¯ Ø±Ù‚Ù…ÙŠØŒ ØªØ¬Ø§Ù‡Ù„Ù‡Ø§
    if (value === null || value === undefined || typeof value === "number") {      
      continue; // ØªØ¬Ø§Ù‡Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù‚ÙŠÙ…Ø© ÙˆØ§Ù†ØªÙ‚Ù„ Ù„Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
    }
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ©
    if (typeof value === "string") {      
      // Ù‚Ù… Ø¨Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª Ø§Ù„Ø²Ø§Ø¦Ø¯Ø© ÙˆØªØ¹Ù‚ÙŠÙ…Ù‡Ø§
      // ÙˆØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø±Ù…ÙˆØ² Ø¶Ø§Ø±Ø©
      // if (value.trim().match(/['";$%&<>]/)) {
      if (value.trim().match(/['";$&<>]/)) { // ØªÙ… Ø§Ø²Ø§Ù„Ù‰ Ø¹Ù„Ø§Ù…Ù‡ % Ù…Ù† Ø§Ù„ÙƒÙˆØ¯
        return true; // Ø¹Ø«Ø± Ø¹Ù„Ù‰ Ø±Ù…Ø² Ø¶Ø§Ø±
      }
    }
  }
  return false; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ù…ÙˆØ² Ø¶Ø§Ø±Ø©
}


let InValidDateFormat_message_ar = `âŒ ØµÙŠØºØ© Ø§Ù„ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ø­Ø¯ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ†`
function isInValidDateFormat(valuesAsArray) {
  try {
  const dateFormatRegex = /^\d{4}-\d{2}-\d{2}$/;

  for (const value of valuesAsArray) {
    if (!dateFormatRegex.test(value)) {
      return true; // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ØµÙŠØºØ© ØºÙŠØ± Ù…Ø·Ø§Ø¨Ù‚Ø©
    }
  }
  return false; // ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… ØµÙŠØºØªÙ‡Ø§ ØµØ­ÙŠØ­Ø©
} catch (error) {
  catch_error(error)
}
}

/*
const dates = ['2024-08-23', '2024-12-01', '2023-11-31']; // Ù‡Ù†Ø§ ÙƒÙ„ Ø§Ù„ØµÙŠØº ØµØ­ÙŠØ­Ø© Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù†Øª Ø¨Ø¹Ø¶ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® ØºÙŠØ± Ù…Ù†Ø·Ù‚ÙŠØ©

*/
//#region stop_hackers

async function block_user(req, code){
  try {
      //!block user
  let query0 = `update users set is_try_hack = $1 , hack_code_reason = $2, is_active = false WHERE owner_id =$3 AND id = $4`;
  await db.none(query0, [
    true,
    code,
    req.session.owner_id,
    req.session.userId]);

    //! block owner
    let query1 = `update owners set is_try_hack = $1 WHERE id =$2`;
    await db.none(query1, [
      true,
      req.session.owner_id,
      ]);

      await last_activity(req);
      await khorogFawry(req,req.session.userId)
     

      //! destroy session
      if(req.session){
      req.session.destroy()
      }
  } catch (error) {
    console.error("Error block_user:", error);
  }
}

  //#region codes reason
    /*
    
    */
  //#endregion
//#endregion


//#region khorogFawry

async function khorogFawry(req,userId) {
  let query00 = `UPDATE users SET is_active = false WHERE id = $1`;
  await db.none(query00, [userId]);
  io.emit('khorogFawry', { x1: userId});
  if(req.session){
    req.session.destroy()
    }
}


//#endregion
//#endregion End- Templets

//*-- PAGES ---------------------------------------------

//#region owners_and_companies

//#region 1:- companies view
/*
app.post("/get_companies_data", async (req, res) => {
  try {

    //! Permission
    // await permissions(req, 'bread_permission', 'view');
    // if (!permissions) { return; };

    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    const owner = req.session.is_owner;
    let query1;
    let data;

    if (owner) {
      query1 = `select 
      id as company_id,
      company_name as company_name
      from companies uc 
      where owner_id = $1
      order BY company_name asc;
  `;
      data = await db.any(query1, [req.session.owner_id]);
    } else {
      query1 = `select 
      uc.company_id,
      c.company_name
      from user_company uc 
      left join companies c on uc.company_id  = c.id
      where uc.user_id = $1
      order BY c.company_name asc;
  `;
      data = await db.any(query1, [req.session.userId]);
    }



    res.json(data);
  } catch (error) {
    console.error("Error get_All_bread_Data:", error);
    res.status(500).send("Error:");
  }
});
*/


app.post("/get_companies_data", async (req, res) => {
  try {

    //! Permission
    // await permissions(req, 'bread_permission', 'view');
    // if (!permissions) { return; };

    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    const owner = req.session.is_owner_permission;
    let query1;
    let data;

    if (owner) {
      query1 = `select 
      id as company_id,
      company_name as company_name
      from companies uc 
      where owner_id = $1
      order BY company_name asc;
  `;
      data = await db.any(query1, [req.session.owner_id]);
    } else {
      query1 = `select 
      uc.company_id,
      c.company_name
      from user_company uc 
      left join companies c on uc.company_id  = c.id
      where uc.user_id = $1
      order BY c.company_name asc;
  `;
      data = await db.any(query1, [req.session.userId]);
    }



    res.json(data);
  } catch (error) {
    console.error("Error get_All_bread_Data:", error);
    res.status(500).send("Error:");
  }
});

//#endregion End - companies view

//#region 2:- add new company
app.post("/api/add_new_company", async (req, res) => {
  try {

    //! check number of companies allowed
const q1 = `select owner_number_of_companies_allowed 
from owners
where id = $1`
let r1 = await db.oneOrNone(q1,[req.session.owner_id])
r1 = r1.owner_number_of_companies_allowed




const q2 = `select count(id) as id
from companies
where owner_id = $1`

let r2 = await db.oneOrNone(q2,[req.session.owner_id])
r2 = r2.id ? r2.id : 0 


if(!r1 || isNaN(r1) || r1 < 1){
return res.json({
  success: false,
  message_ar: 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ø­Ø¯ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ† Ù„ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ù…Ø§Ù„ Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§',
});
}

if ( r2 >= r1){
return res.json({
  success: false,
  message_ar: 'ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ù‰ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ù…Ø§Ù„ Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§ : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ø­Ø¯ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ† ',
});
}

    const posted_elements = req.body;

        //! owner
        if (req.session.is_owner_permission !== true){
          await block_user(req,'auuwc1')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }


    //! sql injection check
    const hasBadSymbols = sql_anti_injection([posted_elements.company_name_input_value, // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
    //* Start--------------------------------------------------------------


    if (!posted_elements.company_name_input_value || posted_elements.company_name_input_value == ""){
      return res.json({
        success: false,
        message_ar: "Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„ØªØ¬Ø§Ø±Ù‰ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­",
      });
    }

    // check if company name already exist
    let query0 = `
    select company_name from companies c where owner_id =$1 and company_name = $2
  `;
    let rows = await db.any(query0, [
      req.session.owner_id,
      posted_elements.company_name_input_value,
    ]);

    if (rows.length > 0) {
   
      res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ø´Ø±ÙƒÙ‡ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
      });
    }


      

      let query1 = `
      INSERT INTO companies (owner_id, company_name)
      VALUES ($1, $2) RETURNING id;
    `;

      const query1_parameters = [req.session.owner_id,posted_elements.company_name_input_value,]

      
    await db.tx(async (tx) => {
      // 1 : add company
      const insert = await tx.one(query1, query1_parameters);

      const newCompanyId = insert.id;
      // 2 : add global accounts  in accounts_header
    



      const accountEntries = [
        {account_name: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø§Ù„Ù‰", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: 0, account_name_en: null, global_id: 1, main_account_id: 0},
        {account_name: "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„", is_final_account: null, finance_statement: 2, cashflow_statement: null, account_type_id: 0, account_name_en: null, global_id: 2, main_account_id: 0},
        {account_name: "Ø§Ù„Ø§ØµÙˆÙ„", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 3, main_account_id: 1},
        {account_name: "Ø§Ù„Ø§Ù„ØªØ²Ù…Ø§Øª", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 4, main_account_id: 2},
        {account_name: "Ø­Ù‚ÙˆÙ‚ Ø§Ù„Ù…Ù„ÙƒÙŠÙ‡", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 5, main_account_id: 3},
        {account_name: "Ø§Ù„Ø§ÙŠØ±Ø§Ø¯Ø§Øª", is_final_account: null, finance_statement: 2, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 6, main_account_id: 4},
        {account_name: "Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª", is_final_account: null, finance_statement: 2, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 7, main_account_id: 5},
        {account_name: "Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§ÙŠØªØ©", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 9, main_account_id: 1},
        {account_name: "Ù…Ø¬Ù…Ø¹ Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ©", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 10, main_account_id: 1},
        {account_name: "Ø§Ù„Ù†Ù‚Ø¯ ÙˆÙ…Ø§ ÙÙ‰ Ø­ÙƒÙ…Ù‡", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 11, main_account_id: 1},
        {account_name: "Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø§Ù„Ø­Ø§Ù„Ù‰", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: 5, account_name_en: null, global_id: 12, main_account_id: 1},
        {account_name: "Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 13, main_account_id: 1},
        {account_name: "Ø§Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 14, main_account_id: 2},
        {account_name: "Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ†", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: 4, account_name_en: null, global_id: 20, main_account_id: 2},
        {account_name: "Ø­Ø³Ø§Ø¨Ø§Øª Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: null, account_name_en: null, global_id: 15, main_account_id: 3},
        {account_name: "Ø§Ø±Ø¨Ø§Ø­ ÙˆØ®Ø³Ø§Ø¦Ø± Ø§Ù„ÙØªØ±Ø©", is_final_account: true, finance_statement: 1, cashflow_statement: null, account_type_id: 1, account_name_en: null, global_id: 16, main_account_id: 3},
        {account_name: "Ø§Ø±Ø¨Ø§Ø­ ÙˆØ®Ø³Ø§Ø¦Ø± ÙØªØ±Ø§Øª Ø³Ø§Ø¨Ù‚Ø©", is_final_account: true, finance_statement: 1, cashflow_statement: null, account_type_id: 1, account_name_en: null, global_id: 23, main_account_id: 3},
        {account_name: "Ø§ÙŠØ±Ø§Ø¯Ø§Øª Ù…Ø¨ÙŠØ¹Ø§Øª - Ø§Ù„Ù…Ø®Ø²ÙˆÙ†", is_final_account: true, finance_statement: 2, cashflow_statement: null, account_type_id: 1, account_name_en: null, global_id: 19, main_account_id: 4},
        {account_name: "Ø§ÙŠØ±Ø§Ø¯Ø§Øª Ù…Ø¨ÙŠØ¹Ø§Øª - Ø®Ø¯Ù…Ø§Øª", is_final_account: true, finance_statement: 2, cashflow_statement: null, account_type_id: 1, account_name_en: null, global_id: 24, main_account_id: 4},
        {account_name: "ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø®Ø²ÙˆÙ† - Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª", is_final_account: true, finance_statement: 2, cashflow_statement: null, account_type_id: 1, account_name_en: null, global_id: 17, main_account_id: 5},
        {account_name: "Ù…ØµØ§Ø±ÙŠÙ Ø§Ù‡Ù„Ø§Ùƒ Ø§ØµÙˆÙ„ Ø«Ø§Ø¨ØªÙ‡", is_final_account: true, finance_statement: 2, cashflow_statement: null, account_type_id: 1, account_name_en: null, global_id: 18, main_account_id: 5},
        {account_name: "Ù…Ø±Ø§ÙƒØ² Ø§Ù„ØªÙƒÙ„ÙØ©", is_final_account: null, finance_statement: 4, cashflow_statement: null, account_type_id: 11, account_name_en: null, global_id: 21, main_account_id: null},
        {account_name: "Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ø±Ø§ÙƒØ² Ø§Ù„ØªÙƒÙ„ÙØ© 1", is_final_account: null, finance_statement: 4, cashflow_statement: null, account_type_id: 11, account_name_en: null, global_id: 22, main_account_id: null},
        {account_name: "Ø§Ù„Ù…Ø®Ø²Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ", is_final_account: true, finance_statement: null, cashflow_statement: null, account_type_id: 7, account_name_en: null, global_id: 25, main_account_id: null},
        {account_name: "Ù‚Ø³Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", is_final_account: null, finance_statement: 1, cashflow_statement: null, account_type_id: 4, account_name_en: null, global_id: 26, main_account_id: 2},
        {account_name: "Ù…ÙˆØ¸Ù - Ø¨Ø§Ø¦Ø¹", is_final_account: true, finance_statement: 1, cashflow_statement: null, account_type_id: 4, account_name_en: null, global_id: 27, main_account_id: 2},
        
        // Ø£Ø¶Ù Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª
      ];




      let insertHeaderQuery = `
      INSERT INTO accounts_header (company_id, account_name, is_final_account, finance_statement, cashflow_statement, account_type_id, account_name_en, global_id, main_account_id) 
        VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING id`;
    
        let header_id_Array = []; // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø±Ø¬Ø¹Ø© Ù„ÙƒÙ„ Ø­Ø³Ø§Ø¨

        for (const row of accountEntries) {
          let insertedId = await tx.one(insertHeaderQuery, [
              newCompanyId,
              row.account_name,
              row.is_final_account,
              row.finance_statement,
              row.cashflow_statement,
              row.account_type_id,
              row.account_name_en,
              row.global_id,
              row.main_account_id
          ]);
      
          header_id_Array.push(insertedId.id); // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø±ØªØ¬Ø¹ Ø¯Ø§Ø®Ù„ ÙƒØ§Ø¦Ù† idMap
      }

      let x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, 
      x11, x12, x13, x14, x15, x16, x17, x18, x19, 
      x20, x21, x22, x23 , x24, x25, x26;
      // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø·ÙˆÙ„ Ø§Ù„Ù…ØµÙÙˆÙØ© ÙŠØªØ·Ø§Ø¨Ù‚ Ù…Ø¹ Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª
      //! ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙŠÙ… Ù…Ù† Ø§Ù„Ù…ØµÙÙˆÙÙ‡  Ø§Ù„Ù‰ Ø§Ù„Ø§ÙƒØ³Ø§Øª ÙÙˆÙ‚ Ù…Ø¨Ø§Ø´Ø±Ø©
      if (header_id_Array.length === 26 && header_id_Array.every(id => id != null)) {
        // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙŠÙ… Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª x1, x2, ... x23
        [x1, x2, x3, x4, x5, x6, x7, x8, x9, x10,
         x11, x12, x13, x14, x15, x16, x17, x18, x19,
         x20, x21, x22, x23, x24, x25, x26] = header_id_Array;
      } else {
        throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: Sadnc001');
      }
      

      const accountbodies = [
        {id: x1, parent_id: false}, //  "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø§Ù„Ù‰"
        {id: x2, parent_id: false}, // "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„"
        {id: x3, parent_id: x1}, // "Ø§Ù„Ø§ØµÙˆÙ„"
        {id: x4, parent_id: x1}, //  "Ø§Ù„Ø§Ù„ØªØ²Ù…Ø§Øª"
        {id: x5, parent_id: x1}, // "Ø­Ù‚ÙˆÙ‚ Ø§Ù„Ù…Ù„ÙƒÙŠÙ‡"
        {id: x6, parent_id: x2}, // "Ø§Ù„Ø§ÙŠØ±Ø§Ø¯Ø§Øª"
        {id: x7, parent_id: x2}, //  "Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª"
        {id: x8, parent_id: x3}, // "Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§ÙŠØªØ©"
        {id: x9, parent_id: x3}, // "Ù…Ø¬Ù…Ø¹ Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ©"
        {id: x10, parent_id: x3}, // "Ø§Ù„Ù†Ù‚Ø¯ ÙˆÙ…Ø§ ÙÙ‰ Ø­ÙƒÙ…Ù‡"
        {id: x11, parent_id: x3}, //  "Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø§Ù„Ø­Ø§Ù„Ù‰"
        {id: x12, parent_id: x3}, // "Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡"
        {id: x13, parent_id: x4}, // "Ø§Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†"
        {id: x14, parent_id: x4}, // "Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ†"
        {id: x15, parent_id: x5}, // "Ø­Ø³Ø§Ø¨Ø§Øª Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„"
        {id: x16, parent_id: x5}, // "Ø§Ø±Ø¨Ø§Ø­ ÙˆØ®Ø³Ø§Ø¦Ø± Ø§Ù„ÙØªØ±Ø©"
        {id: x17, parent_id: x5}, // "Ø§Ø±Ø¨Ø§Ø­ ÙˆØ®Ø³Ø§Ø¦Ø± ÙØªØ±Ø§Øª Ø³Ø§Ø¨Ù‚Ø©"
        {id: x18, parent_id: x6}, // "Ø§ÙŠØ±Ø§Ø¯Ø§Øª Ù…Ø¨ÙŠØ¹Ø§Øª - Ø§Ù„Ù…Ø®Ø²ÙˆÙ†"
        {id: x19, parent_id: x6}, // "Ø§ÙŠØ±Ø§Ø¯Ø§Øª Ù…Ø¨ÙŠØ¹Ø§Øª - Ø®Ø¯Ù…Ø§Øª"
        {id: x20, parent_id: x7}, //  "ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø®Ø²ÙˆÙ† - Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª"
        {id: x21, parent_id: x7}, // "Ù…ØµØ§Ø±ÙŠÙ Ø§Ù‡Ù„Ø§Ùƒ Ø§ØµÙˆÙ„ Ø«Ø§Ø¨ØªÙ‡"
        {id: x22, parent_id: false}, // "Ù…Ø±Ø§ÙƒØ² Ø§Ù„ØªÙƒÙ„ÙØ©"
        {id: x23, parent_id: x22}, // "Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ø±Ø§ÙƒØ² Ø§Ù„ØªÙƒÙ„ÙØ© 1"
        {id: x24, parent_id: false}, // "Ø§Ù„Ù…Ø®Ø²Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ"
        {id: x25, parent_id: x14}, //"Ù‚Ø³Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©"
        {id: x26, parent_id: x25}, //"Ù…ÙˆØ¸Ù-Ø¨Ø§Ø¦Ø¹"
        // Ø£Ø¶Ù Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª
      ];

        let insertBodyQuery = `
          INSERT INTO accounts_body (parent_id, account_id) 
          VALUES ($1,$2)
        `;
        
        const insert_array_accounts_body = [];
                
        for (const row of accountbodies) {
          if (row.parent_id) {  // Ø¥Ø°Ø§ ÙƒØ§Ù† parent_id Ù„ÙŠØ³ false            
            const processedRow = [
              row.parent_id,
              row.id,
            ];
        
            insert_array_accounts_body.push(processedRow);  // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙ Ø¥Ù„Ù‰ Ø§Ù„Ù…ØµÙÙˆÙØ©
          }
        }
        
        // ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… batch
        await tx.batch(insert_array_accounts_body.map(data => tx.none(insertBodyQuery, data)));
        
  

      //4 : add settings
      await tx.none( //! closingDate = null
        `INSERT INTO settings (company_id,setting_type_id) values(${newCompanyId},1)`
      ); 
      await tx.none( //! prevent_futureDate = null
        `INSERT INTO settings (company_id,setting_type_id) 
        values(${newCompanyId},2)`
      ); 
    })
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    });

  

  } catch (error) {
    console.error("Error adding production:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region 2:- company Login
app.post("/company_login", async (req, res) => {
  try {
    
    
    const posted_elements = req.body;
    //! Permission
    // await permissions(req, 'bread_permission', 'view');
    // if (!permissions) { return; };

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.c_id,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    let query1;
    let data;
    const is_owner = req.session.is_owner_permission;
    
    if (is_owner && is_owner === true) {
      query1 = `select company_name from companies c
      where id = $1 AND owner_id = $2`;
      data = await db.oneOrNone(query1, [posted_elements.c_id, req.session.owner_id]);

      if (data) {
        req.session.company_id = parseInt(posted_elements.c_id);
        req.session.company_name = data.company_name;
        
        data = {company_id: parseInt(posted_elements.c_id), company_name: data.company_name}
        
        res.json(data);
      } else {
        res.json({
          success: false,
          message_ar: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ",
        });
      }
    } else {




//! Global Code permissions500 S-1
// The SQL query remains the same
const query_permissions = 
`select
    c.company_name,
    uc.user_id,
    uc.company_id,
    uc.general_permission,
    uc.employees_permission,
    uc.effects_permission,
    uc.users_permission,
    uc.production_permission,
    uc.bread_permission,
    uc.acounts_permission,
    uc.transaction_permission,
    uc.customers_permission,
    uc.vendors_permission,
    uc.departments_permission,
    uc.items_permission,
    uc.itemsLocations_permission,
    uc.salesman_permission,
    uc.sales_qutation_permission,
    uc.sales_order_permission,
    uc.sales_invoice_permission,
    uc.purshases_qutation_permission,
    uc.purshases_order_permission,
    uc.purshases_invoice_permission,
    uc.services_permission,
    uc.sales_returns_permission,
    uc.purshases_returns_permission,
    uc.fixed_assests_permission,
    uc.accumulated_depreciation_permission,
    uc.disposed_fixed_asset_permission,
    uc.items_transfer_permission,
    uc.cash_accounts_permission,
    uc.cash_transaction_permission
FROM user_company uc 
    left join companies c on uc.company_id = c.id
WHERE
    uc.user_id = $1
    AND uc.company_id = $2
order BY c.company_name asc;
  `;

const data = await db.oneOrNone(query_permissions, [req.session.userId, posted_elements.c_id]);

if (data) {
  // Save user & company Permissions in session
  req.session.company_id = data.company_id;
  req.session.company_name = data.company_name;
  // Save all permissions dynamically

  //! Global Code permissions500 S-2

  req.session.general_permission = data.general_permission
  req.session.employees_permission = data.employees_permission
  req.session.effects_permission = data.effects_permission
  req.session.users_permission = data.users_permission
  req.session.production_permission = data.production_permission
  req.session.bread_permission = data.bread_permission
  req.session.acounts_permission = data.acounts_permission
  req.session.transaction_permission = data.transaction_permission
  req.session.customers_permission = data.customers_permission
  req.session.vendors_permission = data.vendors_permission
  req.session.departments_permission = data.departments_permission
  req.session.items_permission = data.items_permission
  req.session.itemsLocations_permission = data.itemsLocations_permission
  req.session.salesman_permission = data.salesman_permission
  req.session.sales_qutation_permission = data.sales_qutation_permission
  req.session.sales_order_permission = data.sales_order_permission
  req.session.sales_invoice_permission = data.sales_invoice_permission
  req.session.purshases_qutation_permission = data.purshases_qutation_permission
  req.session.purshases_order_permission = data.purshases_order_permission
  req.session.purshases_invoice_permission = data.purshases_invoice_permission
  req.session.services_permission = data.services_permission
  req.session.sales_returns_permission = data.sales_returns_permission
  req.session.purshases_returns_permission = data.purshases_returns_permission
  req.session.fixed_assests_permission = data.fixed_assests_permission
  req.session.accumulated_depreciation_permission = data.accumulated_depreciation_permission
  req.session.disposed_fixed_asset_permission = data.disposed_fixed_asset_permission
  req.session.items_transfer_permission = data.items_transfer_permission
  req.session.cash_accounts_permission = data.cash_accounts_permission
  req.session.cash_transaction_permission = data.cash_transaction_permission


  res.json(data);

      } else {
        res.json({
          success: false,
          message_ar: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ",
        });
      }
    }
  } catch (error) {
    console.error("Error company_login:", error);
    res.status(500).send("Error:");
  }
});
//#endregion

//#region 4:- get companies_data
app.post("/api/get_companies_users", async (req, res) => {
  try {
    const posted_elements = req.body;
    //! Permission
    // await permissions(req, 'bread_permission', 'view');
    // if (!permissions) { return; };

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.new_user,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
                message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }
    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    let query1;
    let rows;
    const is_owner = req.session.is_owner_permission;
    if (is_owner && is_owner === true) {
      query1 = `select id, company_name from companies c
      where owner_id = $1`;
      rows = await db.any(query1, [req.session.owner_id]);

      const data = rows.map((row) => ({
        wazn: row.wazn,
        amount: row.amount,
      }));

      if (rows.length > 0) {
        const data = rows.map((row) => ({
          company_id: row.id,
          company_name: row.company_name,
        }));
        res.json(data);
      } else {
        res.json({
          success_ar: false,
          message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ",
        });
      }
    }
  } catch (error) {
    console.error("Error get_All_bread_Data:", error);
    res.status(500).send("Error:");
  }
});
//#endregion

//#region 5:- get users
app.post("/get_main_users_Data", async (req, res) => {
  try {
    //! check Permission
    permissions(req, "users_permission", "view");
    if (!permissions) {
      return;
    }


    //*----------------------------------------------------------------

    let query = `select id,
      user_full_name,
              CASE
              WHEN is_stop = true THEN 'Ø§ÙŠÙ‚Ø§Ù'
              ELSE ''
          END AS is_stop
    from users
    where
      owner_id = $1
      AND is_owner is NULL
    ;`
    ;
    let data = await db.any(query, [req.session.owner_id]);

    // const rows = await db.any("SELECT id, user_name  FROM users");
    

    res.json(data);
    last_activity(req);
  } catch (error) {
    console.error("Error get_All_users_Data ", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region 5:- save new user
app.post("/api/save_new_user", async (req, res) => {
  try {
    
//! check users_numbers_allowed

const q1 = `select owner_number_of_users_allowed 
    	from owners
    where id = $1`
 let r1 = await db.oneOrNone(q1,[req.session.owner_id])
    r1 = r1.owner_number_of_users_allowed

const q2 = `select count(id) as id
    from users
    where owner_id = $1`

let r2 = await db.oneOrNone(q2,[req.session.owner_id])
    r2 = r2.id ? r2.id : 0 
 
    if(!r1 || isNaN(r1) || r1 < 1){
      return res.json({
        success: false,
        message_ar: 'âŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ø­Ø¯ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ† Ù„ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ù…',
      });
    }

    if ( r2 >= r1){
      return res.json({
        success: false,
        message_ar: 'âŒ ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ù‰ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ù‚ØµÙ‰ Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ù… : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ø­Ø¯ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ†',
      });
    }
    

 //-------------------------------------------------------------------
    const posted_elements = req.body;

        //! owner
        if (req.session.is_owner_permission !== true){
          await block_user(req,'auuwc1')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }


    //! Permission
    // await permissions(req, 'bread_permission', 'view');
    // if (!permissions) { return; };
    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.selectedCompanies.map((obj) => obj.company_id + obj.checked), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.permission_type,
      posted_elements.user_name_value,
      posted_elements.pass_value,
      posted_elements.user_fullName_value,
      posted_elements.inactive_select_value,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    //* if no company selected
    if (posted_elements.permission_type == "1" && parseInt(posted_elements.selectedCompanies.length) < 1 ) {
      return res.json({
        success: false,
        message_ar: "Ù…Ù† ÙØ¶Ù„Ùƒ Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø¹Ù…Ø§Ù„ Ø§Ù„ØªØ¬Ø§Ø±Ù‡ Ø§Ù„Ù…Ø®ØµØµÙ‡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…",
      });
    }

    if (posted_elements.permission_type == "1"){
        //! Security hacking 
        let query01 = `SELECT id from companies where owner_id = $1`;
        let rows01 = await db.any(query01, [
          req.session.owner_id
        ]);
    
        const deafult_companies_array = rows01.map((row) => parseInt(row.id));
        const selectedCompanies = posted_elements.selectedCompanies.map((item) => parseInt(item.company_id));
        const defrenceArray = selectedCompanies.filter((company_id) => !deafult_companies_array.includes(company_id));

        


        if (defrenceArray.length > 0){
          await block_user(req,'auuwc')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
    }


    //* Start--------------------------------------------------------------

    const permission_type = posted_elements.permission_type == "0" ? true : null

    

    let query = `SELECT TRIM(user_name) FROM users WHERE owner_id =$1 AND TRIM(user_name) = $2`;
    let rows = await db.any(query, [
      req.session.owner_id,
      posted_elements.user_name_value
    ]);

    if (rows.length > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
      });
    } else {
      await db.tx(async (tx) => {
        //! ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù‚Ø¨Ù„ Ø¥Ø¯Ø®Ø§Ù„Ù‡Ø§ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        const pass_input1 = await bcrypt.hash(posted_elements.pass_value, 12);
        //3: insert data into db
        
        const inactive_select_value = posted_elements.inactive_select_value == '0'? null : true 
        
        
        let query = `INSERT into users (user_name, user_password, user_full_name, is_active, owner_id, is_owner_permission, datex, is_stop) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id`;
        const insert = await tx.one(query, [
          posted_elements.user_name_value,
          pass_input1,
          posted_elements.user_fullName_value,
          null,
          req.session.owner_id,
          permission_type,
          posted_elements.today,
          inactive_select_value
        ]);

        const newUserId = insert.id;
        if (posted_elements.permission_type == "1" && parseInt(posted_elements.selectedCompanies.length) > 0 ) {
          for (const element of posted_elements.selectedCompanies) {
            let query2 = `INSERT INTO user_company
                                (user_id, company_id)
                                VALUES($1, $2);`;

            await tx.none(query2, [newUserId, element.company_id]);
          }
        }
      });
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ…  ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­",
      });
      last_activity(req);
    }
    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  } catch (error) {
    console.error("Error adding user:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//#endregion

//#region 6:- update user
app.post("/api/update_user", async (req, res) => {
  try {
    

     //-------------------------------------------------------------------
        const posted_elements = req.body;
    
            //! owner
            if (req.session.is_owner_permission !== true){
              await block_user(req,'uus1')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }
    
    
        //! Permission

        //! sql injection check
        let hasBadSymbols = sql_anti_injection([
          ...posted_elements.selectedCompanies.map((obj) => obj.company_id + obj.checked), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
          posted_elements.id,
          posted_elements.is_changePass,
          posted_elements.permission_type,
          posted_elements.user_name_value,
          posted_elements.pass_value,
          posted_elements.user_fullName_value,
          posted_elements.inactive_select_value,
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        ]);
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar: sql_injection_message_ar,
            message_en: sql_injection_message_en,
          });
        }
    
        //* if no company selected
        if (posted_elements.permission_type == "1" && parseInt(posted_elements.selectedCompanies.length) < 1 ) {
          return res.json({
            success: false,
            message_ar: "âŒ Ù…Ù† ÙØ¶Ù„Ùƒ Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø¹Ù…Ø§Ù„ Ø§Ù„ØªØ¬Ø§Ø±Ù‡ Ø§Ù„Ù…Ø®ØµØµÙ‡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…",
          });
        }
    


        if (posted_elements.permission_type == "1"){
            //! Security hacking 
            let query01 = `SELECT id from companies where owner_id = $1`;
            let rows01 = await db.any(query01, [
              req.session.owner_id
            ]);
        
            const deafult_companies_array = rows01.map((row) => parseInt(row.id));
            const selectedCompanies = posted_elements.selectedCompanies.map((item) => parseInt(item.company_id));
            const defrenceArray = selectedCompanies.filter((company_id) => !deafult_companies_array.includes(company_id));
    
            
    
    
            if (defrenceArray.length > 0){
              await block_user(req,'auuwc')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }
        }
    


        //* Start--------------------------------------------------------------
    
        const permission_type = posted_elements.permission_type == "0" ? true : null
    
        

          await db.tx(async (tx) => {

            //#region : ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙ‰ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ù…ÙŠÙ† 
            const inactive_select_value = posted_elements.inactive_select_value == '0'? null : true
            let q1
            let p1
            if (posted_elements.is_changePass){
                //? check pass
                if (!posted_elements.pass_value || posted_elements.pass_value == ""){
                  return res.json({
                    success: false,
                    message_ar: "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ù‡",
                  });
                }

                //? ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
                const pass_value = await bcrypt.hash(posted_elements.pass_value, 12);

                q1 = `update users set user_name = $1, user_password = $2, user_full_name = $3, is_owner_permission = $4, is_stop = $5 Where id = $6 AND owner_id = $7 `;
                p1 = [posted_elements.user_name_value,pass_value,posted_elements.user_fullName_value,permission_type,inactive_select_value, posted_elements.id, req.session.owner_id]
            }else {

              q1 = `update users set user_name = $1, user_full_name = $2, is_owner_permission = $3, is_stop = $4 Where id = $5 AND owner_id = $6 `;
              p1 = [posted_elements.user_name_value,posted_elements.user_fullName_value,permission_type,inactive_select_value, posted_elements.id, req.session.owner_id]
                      
            }
      
            await tx.none(q1,p1);

            //#endregion 

            //#region : ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙ‰ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†-Ø§Ù„Ø´Ø±ÙƒØ§Øª
              if (permission_type || !posted_elements.selectedCompanies || posted_elements.selectedCompanies.length < 1){
                const q2 = `delete from user_company where user_id = $1`
                const p2 = [posted_elements.id]
                await tx.none(q2,p2);
              }else{
                //#region Ø¹Ù…Ù„ Ù…ØµÙÙˆÙØªÙŠÙ† ÙˆØ§Ø­Ø¯Ù‡ Ù„Ù„Ø´Ø±ÙƒØ§Øª Ø§Ù„Ù…Ø¶Ø§ÙÙ‡ ÙˆÙˆØ§Ø­Ø¯Ù‡ Ù„Ù„Ø´Ø±ÙƒØ§Øª Ø§Ù„Ù…Ø­Ø°ÙˆÙÙ‡
                const q01 = `select
                company_id
              from
                user_company
              where
                user_id = $1
              `
            const user_companies_in_db = await db.any(q01,[posted_elements.id])
  
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…ØµÙÙˆÙØ§Øª Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø£ÙØ¶Ù„ ÙÙŠ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
            const userCompaniesSet = new Set(user_companies_in_db.map(item => item.company_id));
            const selectedCompaniesSet = new Set(posted_elements.selectedCompanies.map(item => item.company_id));
  
            // Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„ÙØ±ÙŠØ¯Ø© ÙÙŠ ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø©
            const deletedArray = [...userCompaniesSet].filter(id => !selectedCompaniesSet.has(id));
            const newArray = [...selectedCompaniesSet].filter(id => !userCompaniesSet.has(id));
          
                //#endregion

                //#region Ø­Ø°Ù Ø§Ù„Ø´Ø±ÙƒØ§Øª ÙÙ‰ Ù…ØµÙÙˆÙÙ‡ Ø§Ù„Ø­Ø°Ù
              if (deletedArray.length > 0) {
                  const query2 = `DELETE FROM user_company WHERE user_id = $1 AND company_id = ANY($2::int[])`;
                  await tx.none(query2, [posted_elements.id, deletedArray]);
              }
                //#endregion

                //#region Ø§Ø¶Ø§ÙØ© Ø§Ù„Ø´Ø±ÙƒØ§Øª 
                if (newArray.length > 0) {
                  const values = newArray.map(element => `(${posted_elements.id}, ${element})`).join(', ');
              
                  const query3 = `INSERT INTO user_company (user_id, company_id) VALUES ${values}`;
                  await tx.none(query3);
              }
              
            //#endregion

              }

            //#endregion
            //!-----------------------------------------------------------

          });
          //4: send a response to frontend about success transaction
          res.json({
            success: true,
            message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­",
          });
          last_activity(req);
        
        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      } catch (error) {
        console.error("Error adding user:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
});

//#endregion

//#region 7:- get users for update
app.get("/get_All_users_Data_companies", async (req, res) => {
  try {
    //! check Permission
    // permissions(req, 'users_permission', 'view');
    // if (!permissions) {
    //   return;
    // };

    //*----------------------------------------------------------------

    let query = `select
    uc.user_id as id,
    u.user_name as user_name
    
    from user_company uc
    left join users u on uc.user_id = u.id
    where u.owner_id = $1
    order by user_name ASC`;
    let data = await db.any(query, [req.session.owner_id]);

    


    res.json(data);
    last_activity(req);
  } catch (error) {
    console.error("Error get_All_users_Data ", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region 8:- get users info for update
app.post("/get_user_data_for_update", async (req, res) => {
  try {

    //! Permission

    
        //! owner
        if (req.session.is_owner_permission !== true){
          await block_user(req,'gudfu1')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
        const posted_elements = req.body;

    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    

       //!validation
       const q1 = `SELECT COUNT(id) AS count FROM users WHERE id = $1 AND owner_id = $2`;
       const l1 = await db.oneOrNone(q1,[posted_elements.id, req.session.owner_id]);
       
       if (!l1 || l1.count !== '1') {
           await block_user(req, 'gudfu2');
           return res.json({
               success: false,
               xx: true,
               message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
           });
       }
       
    
    let data = {};


    // 1 : get all companies


     const query1 = `select 
      id as company_id,
      company_name as company_name
      from companies uc 
      where owner_id = $1
      order BY company_name asc;
  `;

  const query2 = `
    select
      id ,user_name ,user_password ,user_full_name ,is_stop, is_owner_permission
    from
      users
    where
      id = $1
  `

const query3 = `
    select
    	company_id
    from
    	user_company
    where
    	user_id = $1 
`
      
      

await db.tx(async (tx) => {
  const allCompanies = await tx.any(query1, [req.session.owner_id]);
  const userinfo = await tx.oneOrNone(query2, [posted_elements.id]);
  const currentCompanies = await tx.any(query3, [posted_elements.id]);

  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø´Ø±ÙƒØ§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙÙŠ Ù…ØµÙÙˆÙØ©
  const currentCompanyIds = new Set(currentCompanies.map(company => company.company_id));

  // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¹ Ø¥Ø¶Ø§ÙØ© is_select
  const companiesWithSelection = allCompanies.map(company => ({
      ...company,
      is_select: currentCompanyIds.has(company.company_id) // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø¹Ø±Ù Ù…ÙˆØ¬ÙˆØ¯
  }));

  // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…ØµÙÙˆÙØ© Ø¨Ø­ÙŠØ« ØªÙƒÙˆÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªÙŠ is_select = true ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
  companiesWithSelection.sort((a, b) => {
      return (b.is_select === true) - (a.is_select === true);
  });


  data = { companiesWithSelection, userinfo };
});


    

    res.json(data);
  } catch (error) {
    console.error("Error get_user_data_for_update:", error);
    res.status(500).send("Error:");
  }
});
//#endregion

//#region 9:- delete user 
app.post("/delete_user", async (req, res) => {
  try {
        // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
            //! owner
            if (req.session.is_owner_permission !== true){
              await block_user(req,'dus1')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }
    
    //! sql injection check

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );
    let query0 = ` 
                select count(id) as id_count from users where id = $1 AND owner_id = $2
              `;
    let result = await db.oneOrNone(query0, [
      posted_elements.id,
      req.session.owner_id
    ]);
    

    if (result.id_count === 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      await block_user(req,'delue2')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


    
    //3: delete data into db


    let query1 = `DELETE FROM users WHERE id = $1`;
    let params1 = [posted_elements.id];


    await db.tx(async (tx) => {
      await tx.none(query1, params1);
    })


    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error delete_user:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//#endregion

//#region 9:- get users permissions view data
app.post("/get_users_permissions_Data", async (req, res) => {
  try {
    //! check Permission
    permissions(req, "users_permission", "view");
    if (!permissions) {
      return;
    }


    //*----------------------------------------------------------------

    let query = `    SELECT uc.user_id ,
    u.user_full_name
    from user_company uc 
    left join users u on uc.user_id = u.id  
    WHERE uc.company_id = $1
    `;
    let data = await db.any(query, [req.session.company_id]);

    // const rows = await db.any("SELECT id, user_name  FROM users");
    

    res.json(data);
    last_activity(req);
  } catch (error) {
    console.error("Error get_All_users_Data ", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion 

//#endregion  END - owners_and_companies



//#region settings
  //#region get settings data
  app.post("/general_settings_view", async (req, res) => {
    try {
      
      const posted_elements = req.body;
  
      // //! Permission
      // await permissions(req, "effects_permission", "view");
      // if (!permissions) {
      //   return;
      // }
  
        //   // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        //   const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        //   if (hasBadSymbols) {
        //     return res.json({
        //       success: false,
        //       message_ar:
        //         "Invalid input detected due to prohibited characters. Please review your input and try again.",
        //     });
        //   }
        
        //   if (posted_elements.checkbox_aggregation_val && posted_elements.select_aggregation_val == '1') {
        //     const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
        //     if (InValidDateFormat){
        //       return res.json({
        //         success: false,
        //         message_ar: InValidDateFormat_message_ar,
        //       });
        //     }
        //   }
  
  
        // turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
  
          
          

            query = `SELECT * from settings where company_id = $1;`
            params = [req.session.company_id] 
      let data = await db.any(query, params);
      res.json(data);
    } catch (error) {
      console.error("Error getEffectsData1:", error);
      res
        .status(500)
        .json({
           success: false,
           message_ar: error.message || deafultErrorMessage,
          });
    }
  });

  app.post("/general_settings_update", async (req, res) => {
    try {
      const posted_elements = req.body;
      // //! Permission
      // await permissions(req, "effects_permission", "update");
      // if (!permissions) {
      //   return;
      // }


      
       // Ø§ÙØ¶Ù„ ØµÙˆØ±Ù‰  Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø§Ù„Ùƒ Ø§Ùˆ Ù…Ø¯ÙŠØ± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ø­Ø¯Ø§Ù‡Ù…Ø§ Ù…ÙˆØ¬ÙˆØ¯ Ø³ÙŠØªÙ… ØªØ­Ù‚Ù‚ Ø§Ù„Ø´Ø±Ø· ÙˆØ§Ù†Ù‡Ø§Ø¡ Ø§Ù„ÙƒÙˆØ¯
      if (req.session.is_owner_permission !== true && +req.session.general_permission !== 6) {
        return res.json({
          success: false,
          message_ar: "âŒ Ø¹Ø°Ø±Ù‹Ø§ØŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠÙƒ Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø£Ùˆ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¥Ø¶Ø§ÙÙŠØ©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.",
          message_end: "Sorry, you do not have the necessary permissions to perform this action. If you have any questions or require further assistance, please contact the administration.",
        });
    }



      //! sql injection check
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.closingDate])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  

      turn_EmptyValues_TO_null(posted_elements);
  
      
  
      // const settings = await check_settings_validation({
      //   check_futureDate: true,
      //   check_closingDate: true,
      //   type: 'update',
      //   tableName: 'effects',
      //   transaction_id: posted_elements.id,
      //   datex: posted_elements.date_val,
      // }, req);
  
      // if (!settings.valid) {
      //   return res.json({
      //     success: false,
      //     message_ar: settings.message_ar,
      //   });
      // }
  
 
      //* Start--------------------------------------------------------------
  
  
  
      let query1 = `
UPDATE settings
SET 
    datex1 = CASE 
        WHEN setting_type_id = 1 THEN $2  -- Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù€ datex1 Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† setting_type_id ÙŠØ³Ø§ÙˆÙŠ $1
        ELSE datex1  -- Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªÙŠÙØ§Ø¡ Ø§Ù„Ø´Ø±ÙˆØ·
    END,
    boolean1 = CASE 
        WHEN setting_type_id = 2 THEN $3  -- Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù€ boolean1 Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† setting_type_id ÙŠØ³Ø§ÙˆÙŠ $1
        ELSE boolean1  -- Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªÙŠÙØ§Ø¡ Ø§Ù„Ø´Ø±ÙˆØ·
    END
WHERE company_id = $1 AND setting_type_id IN (1, 2);

      `;
      let params1 = [
        req.session.company_id,
        posted_elements.closingDate,
        posted_elements.is_prevent_futureDate
      ]
  
  
      // const year = getYear(posted_elements.date_val)
      // const reference = formatFromFiveDigits(posted_elements.reference);
  
      await db.tx(async (tx) => {
          await tx.none(query1, params1);
          // await history(16, 2, posted_elements.id, posted_elements.reference, req, tx)
      });
  
      
      return res.json({
        success: true,
        message_ar: "âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ù†Ø¬Ø§Ø­. Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª.",
        message_en: "The application settings have been successfully updated. The page will refresh automatically to apply the changes.",
      });
      
    } catch (error) {
      console.error("Error Update general settings:", error);
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });

  //#endregion end get settings data

//#endregion settings



//#region todo

  //#region get todo data
  app.post("/get_All_todo_Data", async (req, res) => {
    try {
      const posted_elements = req.body;
      //! No permissions


      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //* Start--------------------------------------------------------------
  
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `
      select
        t.id,
        COALESCE(t.datex, '') as datex,
        t.is_done,
        COALESCE(t.text, '') as note
      from todo t
      where t.user_id = $1
       And company_id = $2
       AND (t.datex BETWEEN $3 AND $4 )
      ORDER BY
        t.is_done ASC, t.datex DESC, t.id DESC;
  ;`;
      let data = await db.any(query1, [
        req.session.userId,
        req.session.company_id,
        posted_elements.start_date,
        posted_elements.end_date,
      ]);
  

    
      
      res.json(data);
    } catch (error) {
      console.error("Error notes data:", error);
      res.status(500).send("Error: getting todo list");
    }
  });


  app.post("/api/todo_add", async (req, res) => {
    try {

      const posted_elements = req.body;
  
      // //! Permission
      // await permissions(req, "employees_permission", "add");
      // if (!permissions) {
      //   return;
      // }
  
      //! sql injection check
      const hasBadSymbols = sql_anti_injection([
        posted_elements.datex,
        posted_elements.note,
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
      //* Start--------------------------------------------------------------
  
  
      //3: insert data into db
    
  
      let query = `
    INSERT INTO todo (user_id, datex, is_done, text, company_id)
    VALUES ($1, $2, $3, $4, $5) RETURNING id;
  `;
  const insert = await db.one(query, [
        req.session.userId,
        posted_elements.datex,
        false,
        posted_elements.note,
        req.session.company_id,
      ]);
      const newId = insert.id;

      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      console.error("Error adding employee:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });


  app.post("/api/todo_update", async (req, res) => {
    try {

      const posted_elements = req.body;
  
      // //! Permission
      // await permissions(req, "employees_permission", "add");
      // if (!permissions) {
      //   return;
      // }
  
      //! sql injection check
      const hasBadSymbols = sql_anti_injection([
        posted_elements.id_value,
        posted_elements.datex,
        posted_elements.note,
        posted_elements.is_checked,
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
      //* Start--------------------------------------------------------------
  
      //! check if hack
      let query0 = `SELECT id FROM todo WHERE id = $1 AND user_id =$2 AND company_id = $3`;
      let rows0 = await db.any(query0, [
        posted_elements.id_value,
        req.session.userId,
        req.session.company_id,
      ]);
      if (rows0.length === 0) {
        await block_user(req,'todoBlock1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

  
      //3: insert data into db
    
  
      let query = `
    update todo set datex = $1, is_done = $2, text = $3
    WHERE id = $4
  `;
      await db.none(query, [
        posted_elements.datex,
        posted_elements.is_checked,
        posted_elements.note,
        posted_elements.id_value,
      ]);
  
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      console.error("Error adding employee:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });


  app.post("/api/todo_update_is_checked", async (req, res) => {
    try {

      const posted_elements = req.body;
  
      // //! Permission
      // await permissions(req, "employees_permission", "add");
      // if (!permissions) {
      //   return;
      // }
  
      //! sql injection check
      const hasBadSymbols = sql_anti_injection([
        posted_elements.id_value,
        posted_elements.isChecked,
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
      //* Start--------------------------------------------------------------
  
      //! check if hack
      let query0 = `SELECT id FROM todo WHERE id = $1 AND user_id =$2 AND company_id = $3`;
      let rows0 = await db.any(query0, [
        posted_elements.id_value,
        req.session.userId,
        req.session.company_id,
      ]);
      if (rows0.length === 0) {
        await block_user(req,'todoBlock2')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

  
      //3: insert data into db
    
  
      let query = `
    update todo set is_done = $1
    WHERE id = $2
  `;
      await db.none(query, [
        posted_elements.isChecked,
        posted_elements.id_value
      ]);
  
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      console.error("Error update todo2:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });


  app.post("/api/todo_delete", async (req, res) => {
    try {

      const posted_elements = req.body;
  
      // //! Permission
      // await permissions(req, "employees_permission", "add");
      // if (!permissions) {
      //   return;
      // }
  
      //! sql injection check
      const hasBadSymbols = sql_anti_injection([
        posted_elements.id_value,
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
      //* Start--------------------------------------------------------------
  
      //! check if hack
      let query0 = `SELECT id FROM todo WHERE id = $1 AND user_id =$2 AND company_id = $3`;
      let rows0 = await db.any(query0, [
        posted_elements.id_value,
        req.session.userId,
        req.session.company_id,
      ]);
      if (rows0.length === 0) {
        await block_user(req,'todoBlock2')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

  
      //3: insert data into db
    
  
      let query = `
    DELETE FROM todo WHERE id = $1
  `;
      await db.none(query, [
        posted_elements.id_value
      ]);
  
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      console.error("Error update todo2:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#endregion

//#endregion



//#region history
  //#region history_view
  app.post("/get_All_history_Data", async (req, res) => {
    try {
      const posted_elements = req.body;
      //! No permissions


      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //* Start--------------------------------------------------------------
  
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `
 select
	H.id,
  H.datex,
  H.timex,
  H.user_id,
  COALESCE(u.user_full_name, '') as user_full_name,
  H.transactiontype_id,
	tt.transaction_type_name,
	H.transaction_id,
  H.reference,
            CASE
              WHEN H.history_type = 1 THEN 'Ø¥Ù†Ø´Ø§Ø¡'
              WHEN H.history_type = 2 THEN 'ØªØ­Ø¯ÙŠØ«'
              WHEN H.history_type = 3 THEN 'Ø­Ø°Ù'
              ELSE 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯' -- Ø®ÙŠØ§Ø± Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ù‚ÙŠÙ…Ø© 1 Ø£Ùˆ 2 Ø£Ùˆ 3
          END AS history_type
from
	history H
left join
	transaction_type tt on tt.id = H.transactiontype_id
left join
	users u on u.id  = H.user_id
where 
	H.company_id = $1
	AND (H.datex BETWEEN $2 AND $3 )
order by
	H.datex desc,
	H.id desc
  ;`;
      let data = await db.any(query1, [
        req.session.company_id,
        posted_elements.start_date,
        posted_elements.end_date,
      ]);
  

    
      
      res.json(data);
    } catch (error) {
      console.error("Error notes data:", error);
      res.status(500).send("Error: getting todo list");
    }
  });

  //#endregion

//#endregion




//#region users


// update user
app.post("/updateUser", async (req, res) => {
  try {
    const posted_elements = req.body;
    //! Permission
    await permissions(req, "Users_permission", "view");
    if (!permissions) {
      return;
    }


    if(req.session.is_owner_permission && req.session.is_owner_permission !== true){
      let general_permission = parseInt(req.session.general_permission);
      if (!general_permission || general_permission !== 6) {
       
        return res.json({
          success: false,
          message_ar: "âŒ Sorry,you  can't use this featue",
        });
      }
  
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.user_id,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:"Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //! check id
    let query0 = `SELECT id FROM users WHERE owner_id = $1 AND id = $2`;
    let rows0 = await db.any(query0, [
      req.session.owner_id,
      posted_elements.user_id
    ]);
    if (rows0.length === 0) {
      await block_user(req,'uu1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    //* Start--------------------------------------------------------------
    //1: receive data from frontend new_employee_ar.

    //2: validation data befor inserting to db
    // const rows = await db.any("SELECT * FROM users WHERE id = $1", [
    //   posted_elements.user_id,
    // ]);

    let query = `SELECT uc.*,
    u.user_full_name,
    u.is_stop
    from user_company uc 
    left join users u on uc.user_id = u.id  
    WHERE uc.company_id = $1 AND uc.user_id = $2`;
    let data = await db.any(query, [
      req.session.company_id,
      posted_elements.user_id,
    ]);

    
    res.json(data);
    
  } catch (error) {
    console.error("Error get employee data:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/update_User_from_user_update_ar", async (req, res) => {
  try {

 
    
    const posted_elements = await req.body;

    //! Permission

  
    await permissions(req, "Users_permission", "update");
    if (!permissions) {
      return;
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);


   
    //* Start--------------------------------------------------------------

    if (parseInt(posted_elements.user_id) === 1) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…",
      });
    }

    //! check hacking 
    let query0 = `SELECT id FROM users WHERE owner_id =$1`;
    let rows0 = await db.any(query0, [req.session.owner_id]);
    if (rows0.length === 0) {
      await block_user(req,'auuwc')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

       //! Global Code permissions500 S-3
        let query1 = `Update user_company set
                        general_permission = $3,
                        users_permission = $4,
                        departments_permission = $5,
                        employees_permission = $6,
                        effects_permission = $7,
                        production_permission = $8,
                        bread_permission = $9,
                        transaction_permission = $10,
                        items_permission = $11,
                        customers_permission = $12,
                        vendors_permission = $13,
                        itemsLocations_permission = $14,
                        salesman_permission = $15,
                        sales_qutation_permission = $16,
                        sales_order_permission = $17,
                        sales_invoice_permission = $18,
                        purshases_qutation_permission = $19,
                        purshases_order_permission = $20,
                        purshases_invoice_permission = $21,
                        services_permission = $22,
                        sales_returns_permission = $23,
                        purshases_returns_permission = $24,
                        fixed_assests_permission = $25,
                        accumulated_depreciation_permission = $26,
                        disposed_fixed_asset_permission = $27,
                        items_transfer_permission = $28,
                        cash_accounts_permission = $29,
                        cash_transaction_permission = $30
                      WHERE user_id = $1
                        AND company_id = $2`;

         //! Global Code permissions500 S-4               
        await db.any(query1, [
          posted_elements.user_id,
          req.session.company_id,
          posted_elements.general_permission_select,
          posted_elements.table_permission_users,
          posted_elements.table_permission_departments,
          posted_elements.table_permission_employees,
          posted_elements.table_permission_effects,
          posted_elements.table_permission_production,
          posted_elements.table_permission_bread,
          posted_elements.table_permission_transaction,
          posted_elements.table_permission_items,
          posted_elements.table_permission_customers,
          posted_elements.table_permission_vendors,
          posted_elements.table_permission_itemsLocations,
          posted_elements.table_permission_salesman,
          posted_elements.table_permission_sales_qutation,
          posted_elements.table_permission_sales_order,
          posted_elements.table_permission_sales_invoice,
          posted_elements.table_permission_purshases_qutation,
          posted_elements.table_permission_purshases_order,
          posted_elements.table_permission_purshases_invoice,
          posted_elements.table_permission_services,
          posted_elements.table_permission_sales_returns,
          posted_elements.table_permission_purshases_returns,
          posted_elements.table_permission_fixed_assests,
          posted_elements.table_permission_accumulated_depreciation,
          posted_elements.table_permission_disposed_fixed_asset,
          posted_elements.table_permission_items_transfer,
          posted_elements.table_permission_cash_accounts,
          posted_elements.table_permission_cash_transaction
        ]);

        return res.json({
          success: true,
          message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­",
        });
      
    
  } catch (error) {
    console.error("Error updating user data:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

// Delete_user
app.post("/delete_User_from_user_update_ar", async (req, res) => {
  try {
    const posted_elements = req.body;

    //! Permission
    await permissions(req, "Users_permission", "delete");
    if (!permissions) {
      return;
    }

    let general_permission = parseInt(req.session.general_permission);
    if (!general_permission || general_permission !== 6) {
      return res.json({
        success: false,
        message_ar: "Sorry,you  can't use this featue",
      });
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.user_id,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* Start--------------------------------------------------------------

    //3: insert data into db
    // const rows = await db.none("DELETE FROM users WHERE id = $1", [
    //   posted_elements.user_id,
    // ]);

    let query = `DELETE FROM users WHERE id = $1`;
    await db.none(query, [posted_elements.user_id]);

    return res.json({
      success: true,
      message_ar:
        "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­ : Ø³ÙŠØªÙ… ØªÙˆØ¬ÙŠÙ‡Ùƒ Ø§Ù„Ù‰ ØµÙØ­Ù‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
    });
  } catch (error) {
    console.error("Error Deleting user data:", error);
    res.status(500).json({
      success: false,
      message_ar: "ØªÙˆØ¬Ø¯ Ø¹Ù…Ù„ÙŠØ§Øª ÙÙ‰ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±ØªØ¨Ø·Ù‡ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°ÙÙ‡",
    });
  }
});
//#endregion users


//#region customers

//#region get customers data
app.post("/get_All_customers_Data", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "customers_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.end_date])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


  turn_EmptyValues_TO_null(posted_elements);
//* Start--------------------------------------------------------------



    let query1 = `
WITH 
balance_query AS (
    SELECT 
        ah.id,
        COALESCE(
            SUM(
			 	COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
            ), 0
        ) AS balance
    FROM 
        accounts_header ah
    LEFT JOIN transaction_body tb ON ah.id = tb.account_id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        AND ah.account_type_id = 2
        AND ah.is_final_account = true
        AND th.is_deleted IS NULL
        AND th.datex <= $2
    GROUP BY
        ah.id
),
main_query as (
    SELECT 
        A.id, 
        A.account_name,  
        COALESCE(A.account_no, '') as account_no,  
        COALESCE(A.numeric_column1, 0) as credit_limit,  
        COALESCE(A.str_textarea_column5, '') as email,
        COALESCE(A.str20_column1, '') as tasgel_darepy,
        COALESCE(A.str_textarea_column1, '') as legal_info,   
        COALESCE(A.str_textarea_column2, '') as contact_info,  
        COALESCE(A.str_textarea_column3, '') as delivery_adress,  
        COALESCE(A.str_textarea_column4, '') as banking_info,
        COALESCE(bq.balance, 0) AS balance,
        A.is_allow_to_buy_and_sell
    FROM
        accounts_header A
   	LEFT JOIN balance_query bq ON A.id = bq.id   
    WHERE
        A.company_id = $1
        AND A.account_type_id = 2
        AND A.is_final_account = true
)
SELECT *
FROM 
    main_query mq
ORDER BY 
    CASE 
        WHEN mq.balance = 0 THEN 1  -- Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© ØªØ°Ù‡Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
        ELSE 0                      -- Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£Ø¹Ù„Ù‰
    END, 
    mq.balance DESC  -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
    ;  
`;
    let data = await db.any(query1, [req.session.company_id, posted_elements.end_date]);
    last_activity(req)
    res.json(data);
  } catch (error) {
    console.error("Error fetching data:", error);
    res.status(500).send("Error: getEmployeesData");
  }
});

//#endregion


//#region import customers data
app.post("/api/add_imported_customers", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "customers_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
 
    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }

    if (posted_elements.posted_array.length > 301) {
      throw new Error(`âš ï¸ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‡Ùˆ 300 ØµÙ. ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù„Ù‰ Ø¯ÙØ¹Ø§Øª Ø£ØµØºØ±.`);
    }

    //! sql injection check - ÙØ­Øµ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ posted_array
    let hasBadSymbols = posted_elements.posted_array.some(row =>
      row.some(cell => sql_anti_injection([cell]))
    );
    
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }
    
    turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }
    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit
    
    const customersParent = await db.oneOrNone(`select id from accounts_header where company_id = $1 AND global_id = 13`, [req.session.company_id])

    if (!customersParent || !customersParent.id){
      throw new Error(`âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Saaici01 `);
    }

    const parent_id = customersParent.id

    const db_AllAccounts = await db.any(
      `select id, account_name, is_final_account, account_type_id, main_account_id from accounts_header where company_id = $1`,
      [req.session.company_id]
    );

    
    const company_id = req.session.company_id;
    const account_type_id = 2;
    


    // Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªØ®Ø²ÙŠÙ† Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£ØµÙ†Ø§Ù Ø§Ù„Ù„ÙŠ Ø¨ØªØªØ­Ù‚Ù‚ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù„ÙˆØ¨
    const customerNamesSet = new Set();
    
    let array1 = [];
    let validRows = []; // Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù„ÙŠ Ø¯Ø®Ù„Øª ÙØ¹Ù„ÙŠÙ‹Ø§
    let index = 1;
    
    for (const row of posted_elements.posted_array) {
      let account_no = row[0] || null;
      let account_name = row[1] || null;
      let credit_limit = row[2] || null;
      let email = row[3] || null;
      let tasgel_darepy = row[4] || null;
      let kanonya = row[5] || null;
      let tawasol_info = row[6] || null;
      let bank_info = row[7] || null;
      let taslem_address = row[8] || null;
      let is_allow_purshase = row[9] || null;
    
      if (!account_name) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
      if (account_no === 'Ù…Ø¹Ø±Ù Ø§Ù„Ø¹Ù…ÙŠÙ„ ( Ø§Ø®ØªÙŠØ§Ø±Ù‰ )' || account_name === 'Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ ( Ù…Ø·Ù„ÙˆØ¨ )' || credit_limit === 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ø¦ØªÙ…Ø§Ù†Ù‰ ( Ø§Ø®ØªÙŠØ§Ø±ÙŠ )') {
        console.log(`skip header row`);
        //index++;
        continue;
      }

      if (is_allow_purshase && is_allow_purshase === 'Ù†Ø¹Ù…'){
        is_allow_purshase = true
      }else{
        is_allow_purshase = null
      }
    
    
      const isNameExists = db_AllAccounts.some((account) => account.account_name.trim() === account_name);
      if (isNameExists) {
        throw new Error(`âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ '${account_name}' Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
    
      if (customerNamesSet.has(account_name)) {
        throw new Error(`âŒ Ø§Ù„Ø¹Ù…ÙŠÙ„ '${account_name}' Ù…ÙƒØ±Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
      customerNamesSet.add(account_name);
    

      if (credit_limit !== null && (credit_limit === "" || isNaN(+credit_limit))) {
        throw new Error(`âŒ Ø­Ø¯ Ø§Ù„Ø¥Ø¦ØªÙ…Ø§Ù† ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ù„Ø¹Ù…ÙŠÙ„  ${account_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
    
      array1.push([
        account_name,
        true,
        account_no,
        1,
        company_id,
        account_type_id,
        1,
        credit_limit,
        email,
        tasgel_darepy,
        kanonya,
        tawasol_info,
        taslem_address,
        bank_info,
        is_allow_purshase
      ]);
    
      validRows.push(row); // ØªØ®Ø²ÙŠÙ† Ø§Ù„ØµÙ Ø§Ù„ØµØ§Ù„Ø­ ÙÙ‚Ø·
    
      index++;
    }
    
// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {

// Ø¥Ø¯Ø®Ø§Ù„ accounts_header
if (array1.length > 0){


let columnsCount = array1[0].length;
let query1 = `INSERT INTO accounts_header (account_name, is_final_account, account_no, finance_statement, company_id, account_type_id, main_account_id, numeric_column1, str_textarea_column5, str20_column1, str_textarea_column1, str_textarea_column2, str_textarea_column3, str_textarea_column4, is_allow_to_buy_and_sell)
      VALUES ${array1.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}
  RETURNING id;`;

const insertedIds = await tx.many(query1, array1.flat());

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª accounts_body
let array2 = insertedIds.map((inserted) => [
  parent_id, // Ø«Ø§Ø¨Øª Ù„ÙƒÙ„ Ø§Ù„ØµÙÙˆÙ
  inserted.id
]);


let columnsCount2 = array2[0].length;
let query2 = `INSERT INTO accounts_body (parent_id, account_id)
              VALUES ${array2.map((_, i) => 
                `(${Array.from({ length: columnsCount2 }, (_, j) => `$${i * columnsCount2 + j + 1}`).join(', ')})`
              ).join(', ')}`


await tx.none(query2, array2.flat());

}

 // await history(transaction_type, 1, newId_transaction_header, newReference_transaction_header, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
   // const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ù‰ Ø¨Ù†Ø¬Ø§Ø­ `,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error add_imported_customers:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

  //#region add customers
  app.post("/addNewCustomer", async (req, res) => {
    try {
          // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
          // io.emit('blockUser', { userId: req.session.userId });
          
      const posted_elements = req.body;
  
      //! Permission
      await permissions(req, "customers_permission", "add");
      if (!permissions) {
        return;
      }
  
      //! sql injection check
      // const hasBadSymbols = sql_anti_injection([
      //   posted_elements.employee_name_input,
      //   posted_elements.today,
      //   posted_elements.employee_job_input,
      //   posted_elements.employee_beta2a_input,
      //   posted_elements.employee_adress_input,
      //   posted_elements.employee_phone_input,
      //   posted_elements.employee_emergency_phone_input,
      //   posted_elements.employee_start_date_input,
      //   posted_elements.employee_leave_date_input,
      //   // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      // ]);

      // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      if (!posted_elements.account_name_input_value || posted_elements.account_name_input_value === '') {
        return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„" });
      }
      //* Start--------------------------------------------------------------
  
      //2: validation data befor inserting to db
      // const rows = await db.any(
      //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
      //   [posted_elements.employee_name_input]
      // );
  
      let query0 = ` select
      (SELECT count(account_name) FROM accounts_header WHERE company_id = $1 AND TRIM(account_name) = $2) as account_name_count,
      (select id from accounts_header where company_id = $1 AND global_id = 13) as parent_id
                `;
      let result = await db.oneOrNone(query0, [
        req.session.company_id,
        posted_elements.account_name_input_value,
      ]);
  
      if (result.account_name_count > 0) {
        // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
        return res.json({ success: false, message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
      }
  
      //3: insert data into db
  
      let query1 = `
      INSERT INTO accounts_header (account_name, is_final_account, account_no, finance_statement, company_id, account_type_id, main_account_id, numeric_column1, str_textarea_column5, str20_column1, str_textarea_column1, str_textarea_column2, str_textarea_column3, str_textarea_column4, is_allow_to_buy_and_sell)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING id;
    `;

    let query2 = `
    INSERT INTO accounts_body (parent_id, account_id)
    values ($1, $2)
    `


      await db.tx(async (tx) => {
        const insert = await tx.one(query1, [
          posted_elements.account_name_input_value,
          true,
          posted_elements.acc_no_div_value,
          1,
          req.session.company_id,
          2,
          1,
          posted_elements.credit_limit_value,
          posted_elements.email_input_value,
          posted_elements.tasgel_darepy_input_value,
          posted_elements.legal_info_input_value,
          posted_elements.contact_info_input_value,
          posted_elements.delivery_adress_input_value,
          posted_elements.banking_info_input_value,
          posted_elements.is_allow_to_buy_and_sell ? true : null,
        ]);

        const newId_header = insert.id;

        await tx.none(query2,[result.parent_id,newId_header])

        await history(18,1,newId_header,0,req,tx)
      })


      last_activity(req)
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      console.error("Error adding customers:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#endregion

  //#region update cutomer
  app.post("/updateCustomer", async (req, res) => {
    try {
          // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
          // io.emit('blockUser', { userId: req.session.userId });
          
      const posted_elements = req.body;
  
      //! Permission
      await permissions(req, "customers_permission", "update");
      if (!permissions) {
        return;
      }
  
      //! sql injection check
      
      // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      if (!posted_elements.account_name_input_value || posted_elements.account_name_input_value === '' || !posted_elements.account_id_hidden_value || isNaN(posted_elements.account_id_hidden_value) ) {
        return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„" });
      }
      //* Start--------------------------------------------------------------
  

      let query0 = ` select
                      (SELECT count(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3 AND id != $2) as count_account_name_exist,
                      (select count(id) FROM accounts_header WHERE company_id = $1 AND account_type_id = 2) as count_id
      `
      let result = await db.oneOrNone(query0, [
        req.session.company_id,
        posted_elements.account_id_hidden_value,
        posted_elements.account_name_input_value,
      ]);
  
      if (result.count_id === 0) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      if (result.count_account_name_exist > 0) {
        return res.json({
          success: false,
          message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
        });
      }
  
      let query1 = `
    UPDATE accounts_header set account_name = $1, account_no = $2, numeric_column1 = $3, str_textarea_column5 = $4, str20_column1 = $5, str_textarea_column1 = $6, str_textarea_column2 = $7, str_textarea_column3 = $8, str_textarea_column4 = $9, is_allow_to_buy_and_sell = $10
    WHERE company_id = $11 AND account_type_id = 2 AND id = $12
  `;

  
      const params1 =  [
        posted_elements.account_name_input_value,
        posted_elements.acc_no_div_value,
        posted_elements.credit_limit_value,
        posted_elements.email_input_value,
        posted_elements.tasgel_darepy_input_value,
        posted_elements.legal_info_input_value,
        posted_elements.contact_info_input_value,
        posted_elements.delivery_adress_input_value,
        posted_elements.banking_info_input_value,
        posted_elements.is_allow_to_buy_and_sell ? true : null,
        req.session.company_id,
        posted_elements.account_id_hidden_value
      ];
  

      await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(18,2,posted_elements.account_id_hidden_value,0,req,tx);
      })
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      console.error("Error adding customers:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#endregion

  //#region delete customers
  app.post("/delete_customer", async (req, res) => {
    try {
      //! Permission
      await permissions(req, "customers_permission", "delete");
      if (!permissions) {
        return;
      }
  
      const posted_elements = req.body;
      //! sql injection check
      const hasBadSymbols = sql_anti_injection([
        posted_elements.account_id_hidden_value,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      //* Start--------------------------------------------------------------
  
      if (!posted_elements.account_id_hidden_value || isNaN(posted_elements.account_id_hidden_value)) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
  
      let query0 = `
      select
      (select count(account_id) from transaction_body where account_id = $1) as count_account_id,
      (select count(id) from accounts_header where company_id = $2 AND account_type_id = 2) as count_id
  `;
  

      let result = await db.oneOrNone(query0,[
        posted_elements.account_id_hidden_value,
        req.session.company_id
      ])


      if (result.count_id === 0) {
        await block_user(req,'dc1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      if (result.count_account_id > 0) {
        return res.json({
          success: false,
          message_ar: 'ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ : ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø°Ù',
        });
      }

      let query1 = `DELETE FROM accounts_header WHERE company_id = $1 AND id = $2 AND account_type_id = 2`;
      let params1 =  [
        req.session.company_id,
        posted_elements.account_id_hidden_value,
      ];
  

      await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(18,3,posted_elements.account_id_hidden_value,0,req,tx);
      })

      await last_activity(req)
      return res.json({
        success: true,
        message_ar:
          "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¸Ù : Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ùƒ Ø§Ù„Ø§Ù† Ø§Ù„Ù‰ ØµÙØ­Ù‡ Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙ‡",
      });
    } catch (error) {
      last_activity(req)
      console.error("Error get customer data:", error);
      res.status(500).json({
        success: false,
        message_ar:
          "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø¹Ù…ÙŠÙ„ : Ù‚Ø¯ ØªÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ø±ØªØ¨Ø·Ù‡ Ø¨Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ¬Ø¨ Ø­Ø°ÙÙ‡Ø§ Ø§ÙˆÙ„Ø§",
      });
    }
  });
  //#endregion

//#endregion

//#region human_resources

  //#region human_resources_department

    //#region 1: get departments data
    app.post("/get_All_human_resources_department_Data", async (req, res) => {
      try {
        //! Permission
        await permissions(req, "employees_permission", "view");
        if (!permissions) {
          return;
        }
    
        //* Start--------------------------------------------------------------
        

        let query0 = `
        SELECT id FROM accounts_header Where company_id = $1 AND global_id = 20
        `
        let result = await db.oneOrNone(query0,[req.session.company_id])
        
        if (!result) {
          return res.json({
            success: false,
            message_ar: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ",
            message_en: "You do not have the necessary permissions to delete this account",
          })
        }


        let query1 = `

        -- hena ba3mel ensha2 mo2kt le table gept feh el parent_id, employees_count fe table lew7dhom
        -- we ba3den ha3tbro gdwal 3ady we ha3melo join 3ashan a5od el count beta3 el employees da5el kol ksm 3asla tol mnho

    -- 1 : get depratmentId and employeesCont in it    
   WITH department_employees AS (
    SELECT
        ab_inner.parent_id,
        COUNT(ab_inner.id) AS employees_count
    FROM 
        accounts_body ab_inner
    LEFT JOIN 
        accounts_header ah_inner 
        ON ab_inner.account_id = ah_inner.id
    WHERE 
        ah_inner.is_inactive IS NULL
    GROUP BY
        ab_inner.parent_id
)

-- 2 : Main query
SELECT 
    ah.id,
    COALESCE(ah.account_no , '') AS acc_no,
    COALESCE(ah.account_name, '') AS department_name,
    COALESCE(ah.str_textarea_column1, '') AS legal_info,
    COALESCE(de.employees_count, 0) AS employees_count
FROM 
    accounts_body ab_outer
LEFT JOIN 
    accounts_header ah 
    ON ab_outer.account_id = ah.id
LEFT JOIN
    department_employees de 
    ON de.parent_id = ab_outer.account_id
WHERE 
    ah.company_id = $1
    AND ab_outer.parent_id = $2
    AND (ah.is_final_account IS NULL OR ah.is_final_account = false)
ORDER BY
    employees_count DESC,
    ah.account_name ASC;
    `;
        let data = await db.any(query1, [
          req.session.company_id,
          result.id
        ]);
    
        res.json(data);
      } catch (error) {
        console.error("Error fetching data:", error);
        res.status(500).send("Error: human_resources_department");
      }
    });
    //#endregion  end get department data


    //#region departments_add
    app.post("/addNewDepartment", async (req, res) => {
      try {
            // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
            // io.emit('blockUser', { userId: req.session.userId });
            
        const posted_elements = req.body;
    
        //! Permission
        await permissions(req, "departments_permission", "add");
        if (!permissions) {
          return;
        }
    
        //! sql injection check

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
  
        
        turn_EmptyValues_TO_null(posted_elements);



  
        if (!posted_elements.name || posted_elements.name === '') {
          return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù‚Ø³Ù…" });
        }


        if (posted_elements.activeValue && posted_elements.activeValue !== 1) {
          await block_user(req,'andep1')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }

        //* Start--------------------------------------------------------------
    
        //2: validation data befor inserting to db
        // const rows = await db.any(
        //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
        //   [posted_elements.employee_name_input]
        // );
        let query0 = ` select
                    (SELECT count(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $2) as account_name_count,
                    (select id from accounts_header where company_id = $1 AND global_id = 20) as parent_id
                  `;
        let result = await db.oneOrNone(query0, [
          req.session.company_id,
          posted_elements.name,
        ]);
        


        if (result.account_name_count > 0) {
          // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
          return res.json({ success: false, message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ù‚Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
        }
        
        
        if (!result.parent_id) {
          // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
          return res.json({ success: false, message_ar: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡" });
        }
        //3: insert data into db

        let active_value;
        if(posted_elements.activeValue == 0){
          active_value = null
        }else if (posted_elements.activeValue == 1) {
          active_value = 1
        }

        await db.tx(async (tx) => {

        let query1 = `INSERT INTO accounts_header (account_name, finance_statement, company_id, account_type_id, main_account_id, str_textarea_column1) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id;`;
        let params1 = [posted_elements.name, 1, req.session.company_id, 4, 2, posted_elements.info];
       
        const insert = await tx.one(query1, params1);
        const newId_header = insert.id

        let query2 = `INSERT INTO accounts_body (parent_id, account_id) values ($1, $2)`
        let params2 = [result.parent_id, newId_header]
    
       
          
          await tx.none(query2,params2);
        })
  
    
        //4: send a response to frontend about success transaction
        res.json({
          success: true,
          message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø³Ù… Ø¨Ù†Ø¬Ø§Ø­",
        });
      } catch (error) {
        console.error("Error adding department:", error);
        // send a response to frontend about fail transaction
        res.status(500).json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });

    //#endregion

    //#region departments Update
    app.post("/deleteDepartment", async (req, res) => {
      try {
            // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
            // io.emit('blockUser', { userId: req.session.userId });
            
        const posted_elements = req.body;
    
        //! Permission
        await permissions(req, "departments_permission", "delete");
        if (!permissions) {
          return;
        }
    
        //! sql injection check

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }

        turn_EmptyValues_TO_null(posted_elements);
  
        //* Start--------------------------------------------------------------
    
        //2: validation data befor inserting to db
        // const rows = await db.any(
        //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
        //   [posted_elements.employee_name_input]
        // );
        let query0 = ` 
                    select count(id) as id_count from accounts_header where company_id = $1 AND id = $2 AND account_type_id = 4 AND (is_final_account IS NULL OR is_final_account = FALSE);
                  `;
        let result = await db.oneOrNone(query0, [
          req.session.company_id,
          posted_elements.id,
        ]);
        

        if (result.id_count === 0) {
          // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
          await block_user(req,'udep1')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }


        
        //3: delete data into db


        let query1 = `DELETE FROM accounts_header WHERE company_id = $1 AND id = $2`;
        let params1 = [req.session.company_id, posted_elements.id];
    
    
        await db.tx(async (tx) => {
          await tx.none(query1, params1);
        })
  
    
        //4: send a response to frontend about success transaction
        res.json({
          success: true,
          message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø³Ù… Ø¨Ù†Ø¬Ø§Ø­",
        });
      } catch (error) {
        console.error("Error adding department:", error);
        // send a response to frontend about fail transaction
        res.status(500).json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion


    //#region department delete
    app.post("/updateDepartment", async (req, res) => {
      try {
            // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
            // io.emit('blockUser', { userId: req.session.userId });
            
        const posted_elements = req.body;
    
        
        //! Permission
        await permissions(req, "departments_permission", "update");
        if (!permissions) {
          return;
        }
    
        //! sql injection check

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
  
  
        if (!posted_elements.name || posted_elements.name === '') {
          return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù‚Ø³Ù…" });
        }

        // if (posted_elements.activeValue && posted_elements.activeValue !== 1) {
        //   await block_user(req,'andep1')
        //   return res.json({
        //     success: false,
        //     xx: true,
        //     message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        //   });
        // }
        //* Start--------------------------------------------------------------
    
        //2: validation data befor inserting to db
        // const rows = await db.any(
        //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
        //   [posted_elements.employee_name_input]
        // );
        let query0 = ` select
                    (select count(id) from accounts_header where company_id = $1 AND id = $3 AND account_type_id = 4 AND (is_final_account IS NULL OR is_final_account = FALSE)) as id_count,
                    (SELECT count(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $2 AND id != $3) as account_name_count
                  `;
        let result = await db.oneOrNone(query0, [
          req.session.company_id,
          posted_elements.name,
          posted_elements.id,
        ]);
        

        if (result.id_count === 0) {
          // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
          await block_user(req,'udep1')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });        }

        if (result.account_name_count > 0) {
          // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
          return res.json({ success: false, message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ù‚Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
        }
        
        
        //3: insert data into db


        let query1 = `UPDATE accounts_header set account_name = $1, str_textarea_column1 = $2 WHERE company_id = $3 AND id = $4`;
        let params1 = [posted_elements.name, posted_elements.info, req.session.company_id, posted_elements.id];
    
    
        await db.tx(async (tx) => {
          await tx.none(query1, params1);
        })
  
    
        //4: send a response to frontend about success transaction
        res.json({
          success: true,
          message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø³Ù… Ø¨Ù†Ø¬Ø§Ø­",
        });
      } catch (error) {
        console.error("Error adding department:", error);
        // send a response to frontend about fail transaction
        res.status(500).json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion

  //#endregion

  //#region human_resources_employees
// Add new employee
app.post("/employee_add", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
    if (posted_elements.isUrlParams_salesman){
      await permissions(req, "salesman_permission", "add");
      if (!permissions) {
        return;
      }  
    }else{
      await permissions(req, "employees_permission", "add");
      if (!permissions) {
        return;
      }  
    }


    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          const InValidDateFormat = isInValidDateFormat([posted_elements.employee_start_date_value, posted_elements.employee_leave_date_value])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.employee_name_value || posted_elements.employee_name_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù Ø§ÙˆÙ„Ø§",
      });
    }          
  
    if (!posted_elements.select_department_value){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚Ø³Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­",
      });
    }    

    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );

    let query0 = `SELECT

               (select count(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $2) as count_account_name,
               (select count(account_name) FROM accounts_header WHERE company_id = $1 AND id = $3 AND (is_final_account = false or is_final_account IS NULL) AND account_type_id = 4) as count_department_name
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.employee_name_value,
      posted_elements.select_department_value,
      
    ]);

     
    if (![0,1].includes(+posted_elements.inactive_select_value)){
      await block_user(req,'emadd1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


    if (result.count_department_name == 0){
      await block_user(req,'emadd2')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({ success: false, message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
    }

    //3: insert data into db
    
    
    let active_value;
    if(posted_elements.inactive_select_value == 0){
      active_value = null
    }else if (posted_elements.inactive_select_value == 1) {
      active_value = true
    }

   

    await db.tx(async (tx) => {

    let query1 = `
  INSERT INTO accounts_header (account_name, account_no, str_textarea_column1, str_textarea_column5, str_textarea_column2, str_textarea_column3, str_textarea_column4, is_inactive, is_final_account, finance_statement, company_id, account_type_id, main_account_id, is_salesman, is_allow_to_buy_and_sell)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING id;
`;

  let params1 =[
    posted_elements.employee_name_value,
    posted_elements.account_no_value,
    posted_elements.employee_job_value,
    posted_elements.email_input_value,
    posted_elements.other_info_value,
    posted_elements.employee_start_date_value,
    posted_elements.employee_leave_date_value,
    active_value,
    true,
    1,
    req.session.company_id,
    4,
    2,
    posted_elements.is_salesman_value ? true : null,
    posted_elements.is_allow_to_buy_and_sell ? true : null,
  ]
  const insert = await tx.one(query1, params1);
  const newId_header = insert.id

  let query2 = `INSERT INTO accounts_body (parent_id, account_id)
                VALUES ($1, $2)`

  let params2 = [
    posted_elements.select_department_value,
    newId_header
  ]               
   
    await tx.none(query2, params2);
    await history(posted_elements.isUrlParams_salesman ? 21 : 20, 1, newId_header, 0, req, tx)

  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…ÙˆØ¸Ù Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error adding employee:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

// update Employee

// update_Employee
app.post("/update_employee", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;

    //! Permission

      await permissions(req, "employees_permission", "update");
      if (!permissions) {
        return;
      }  
 


    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          const InValidDateFormat = isInValidDateFormat([posted_elements.employee_start_date_value, posted_elements.employee_leave_date_value])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }

          turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.employee_name_value || posted_elements.employee_name_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù Ø§ÙˆÙ„Ø§",
      });
    }          
    
    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );

    let query0 = `SELECT
              (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $2 AND account_type_id = 4 AND is_final_account = true) as count_id,
              (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $3 AND account_type_id = 4 AND (is_final_account = false or is_final_account IS NULL)) as count_department_id,
              (select count(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $4 AND id != $2) as count_account_name
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.id_value,
      posted_elements.select_department_value,
      posted_elements.employee_name_value
    ]);

     
    if (![0,1].includes(+posted_elements.inactive_select_value)){
      await block_user(req,'upemp1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


    if (result.count_id == 0){
      await block_user(req,'upemp2')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


    if (result.count_department_id == 0){
      await block_user(req,'upemp3')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({ success: false, message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
    }

    //3: insert data into db
    
    
    let active_value;
    if(posted_elements.inactive_select_value == 0){
      active_value = null
    }else if (posted_elements.inactive_select_value == 1) {
      active_value = true
    }

    
    

    let query1 = `
    UPDATE accounts_header set account_name = $1, account_no = $2, str_textarea_column1 = $3, str_textarea_column5 = $4, str_textarea_column2 = $5, str_textarea_column3 = $6, str_textarea_column4 = $7, is_inactive = $8, is_salesman = $9, is_allow_to_buy_and_sell = $10 WHERE company_id = $11 AND id = $12;
    `;

  let params1 =[
    posted_elements.employee_name_value,
    posted_elements.account_no_value,
    posted_elements.employee_job_value,
    posted_elements.email_value,
    posted_elements.other_info_value,
    posted_elements.employee_start_date_value,
    posted_elements.employee_leave_date_value,
    active_value,
    posted_elements.is_salesman_value? true : null,
    posted_elements.is_allow_to_buy_and_sell? true : null,
    req.session.company_id,
    posted_elements.id_value,
  ]


  let query2 = `update accounts_body set parent_id = $1 WHERE account_id = $2`

  let params2 = [
    posted_elements.select_department_value,
    posted_elements.id_value,
  ]               


  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    await tx.none(query2, params2);
    await history(20, 2, posted_elements.id_value, 0, req, tx)

  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¸Ù Ø¨Ù†Ø¬Ø§Ø­ : Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ùƒ Ø§Ù„Ù‰ ØµÙØ­Ø© Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error updating employee:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

// Delete_Employee
app.post("/delete_employee", async (req, res) => {
  try {
        // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;

    //! Permission
    if (posted_elements.isUrlParams_salesman){
      await permissions(req, "salesman_permission", "delete");
      if (!permissions) {
        return;
      }  
    }else{
      await permissions(req, "employees_permission", "delete");
      if (!permissions) {
        return;
      }  
    }

    //! sql injection check

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );
    let query0 = `SELECT 
                (select count(id) from accounts_header where company_id = $1 AND id = $2 AND account_type_id = 4 AND is_final_account = true) as count_id,
                (select count(account_id) from transaction_body where account_id = $2) as count_actions,
                (select count(id) from effects where employee_id = $2) as count_effects

              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.id_value,
    ]);
    

    if (result.id_count === 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      await block_user(req,'delmp1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    

    if (result.count_actions > 0 || result.count_effects > 0){
      return res.json({
        success: false,
        message_ar: 'âŒ ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ : Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨',
      });
    }


    
    //3: delete data into db


    let query1 = `DELETE FROM accounts_header WHERE company_id = $1 AND id = $2`;
    let params1 = [req.session.company_id, posted_elements.id_value];


    await db.tx(async (tx) => {
      await tx.none(query1, params1);
      history(posted_elements.isUrlParams_salesman ? 21 : 20, 3, posted_elements.id_value, 0, req, tx)
    })

    await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¸Ù Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error deleting employee:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//_______________________________________________

// get all d employees data
app.post("/get_All_Employees_Data", async (req, res) => {
  try {
 //500500
    
    //! Permission
    await permissions(req, "employees_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.end_date])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


  turn_EmptyValues_TO_null(posted_elements);
//* Start--------------------------------------------------------------



   
    let query1 = `
WITH 
balance_query AS (
    SELECT 
        ah.id,
        COALESCE(
            SUM(
                CASE
                    WHEN ah.main_account_id = 1 THEN
                        COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
                    ELSE
                        COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
                END
            ), 0
        ) AS balance
    FROM 
        accounts_header ah
    LEFT JOIN transaction_body tb ON ah.id = tb.account_id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        AND ah.account_type_id = 4
        AND ah.is_final_account = true
        AND th.is_deleted IS NULL
        AND th.datex <= $2
    GROUP BY
        ah.id
),
base_query AS (
    SELECT 
        ah1.id,
        COALESCE(ah1.account_name, '') AS account_name, 
        COALESCE(ah1.account_no, '') AS account_no, 
        COALESCE(ah1.str_textarea_column1, '') AS job,
        COALESCE(ah1.str_textarea_column5, '') AS email,
        COALESCE(ah1.str_textarea_column2, '') AS another_info,
        COALESCE(ah1.str_textarea_column3, '') AS start_date,
        COALESCE(ah1.str_textarea_column4, '') AS end_date,
        COALESCE(ah1.is_salesman, false) AS is_salesman,
        CASE 
            WHEN ah1.is_inactive = true THEN 'ØºÙŠØ± Ù†Ø´Ø·'
            ELSE 'Ù†Ø´Ø·'
        END AS is_inactive,
        COALESCE(bq.balance, 0) as balance,
        ab.parent_id AS department_id,
        COALESCE(ah2.account_name, '') AS department_name,
        ah1.is_allow_to_buy_and_sell
    FROM 
        accounts_body ab
    LEFT JOIN accounts_header ah1 ON ah1.id = ab.account_id
    LEFT JOIN accounts_header ah2 ON ah2.id = ab.parent_id
    LEFT JOIN balance_query bq ON ah1.id = bq.id   
    WHERE
        ah1.company_id = $1
        AND ah1.account_type_id = 4
        and ah1.is_final_account is true
)
SELECT * 
FROM base_query
ORDER BY 
    CASE 
        WHEN balance = 0 THEN 1  -- Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© ØªØ°Ù‡Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
        ELSE 0                   -- Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£Ø¹Ù„Ù‰
    END,
    balance DESC;  -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
    `;
    
    let data = await db.any(query1, [req.session.company_id, posted_elements.end_date]);
    res.json(data);
  } catch (error) {
    console.error("Error fetching data:", error);
    res.status(500).send("Error: getEmployeesData");
  }
});

  //#endregion

  //#region human_resources_effects

  //#endregion

//#endregion

//#region vendors

//#region get vendor data
app.post("/get_All_vendors_Data", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "vendors_permission", "view");
    if (!permissions) {
      return;
    }
    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.end_date])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


  turn_EmptyValues_TO_null(posted_elements);
//* Start--------------------------------------------------------------



    let query1 = `
WITH 
balance_query AS (
    SELECT 
        ah.id,
        COALESCE(
            SUM(
				COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
            ), 0
        ) AS balance
    FROM 
        accounts_header ah
    LEFT JOIN transaction_body tb ON ah.id = tb.account_id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        AND ah.account_type_id = 3
        AND ah.is_final_account = true
        AND th.is_deleted IS NULL
        AND th.datex <= $2
    GROUP BY
        ah.id
),
main_query AS (
    SELECT 
        A.id, 
        COALESCE(A.account_name, '') as account_name,  
        COALESCE(A.account_no, '') as account_no,  
        COALESCE(A.numeric_column1, 0) as credit_limit,  
        COALESCE(A.str_textarea_column5, '') as email,
        COALESCE(A.str20_column1, '') as tasgel_darepy,
        COALESCE(A.str_textarea_column1, '') as legal_info,   
        COALESCE(A.str_textarea_column2, '') as contact_info,  
        COALESCE(A.str_textarea_column3, '') as delivery_adress,  
        COALESCE(A.str_textarea_column4, '') as banking_info,
        COALESCE(bq.balance, 0) AS balance,
        A.is_allow_to_buy_and_sell
    FROM 
        accounts_header A
	LEFT JOIN balance_query bq ON A.id = bq.id  
    WHERE
        A.company_id = $1
        AND A.account_type_id = 3
        AND A.is_final_account = true
)
SELECT *
FROM 
    main_query mq
ORDER BY 
    CASE 
        WHEN mq.balance = 0 THEN 1  -- Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© ØªØ°Ù‡Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
        ELSE 0                      -- Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£Ø¹Ù„Ù‰
    END, 
    mq.balance DESC;  -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
`;
    let data = await db.any(query1, [req.session.company_id, posted_elements.end_date]);
    last_activity(req)
    res.json(data);
  } catch (error) {
    last_activity(req)
    console.error("Error fetching data:", error);
    res.status(500).send("Error: getVendorsData");
  }
});

//#endregion


app.post("/api/add_imported_vendors", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "vendors_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
 
    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }

    if (posted_elements.posted_array.length > 301) {
      throw new Error(`âš ï¸ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‡Ùˆ 300 ØµÙ. ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù„Ù‰ Ø¯ÙØ¹Ø§Øª Ø£ØµØºØ±.`);
    }

    //! sql injection check - ÙØ­Øµ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ posted_array
    let hasBadSymbols = posted_elements.posted_array.some(row =>
      row.some(cell => sql_anti_injection([cell]))
    );
    
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }
    
    turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }
    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit
    
    const vendorsParent = await db.oneOrNone(`select id from accounts_header where company_id = $1 AND global_id = 14`, [req.session.company_id])

    if (!vendorsParent || !vendorsParent.id){
      throw new Error(`âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Saaici01 `);
    }

    const parent_id = vendorsParent.id

    const db_AllAccounts = await db.any(
      `select id, account_name, is_final_account, account_type_id, main_account_id from accounts_header where company_id = $1`,
      [req.session.company_id]
    );

    
    const company_id = req.session.company_id;
    const account_type_id = 3;
    


    // Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªØ®Ø²ÙŠÙ† Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£ØµÙ†Ø§Ù Ø§Ù„Ù„ÙŠ Ø¨ØªØªØ­Ù‚Ù‚ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù„ÙˆØ¨
    const vendorNamesSet = new Set();
    
    let array1 = [];
    let validRows = []; // Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù„ÙŠ Ø¯Ø®Ù„Øª ÙØ¹Ù„ÙŠÙ‹Ø§
    let index = 1;
    
    for (const row of posted_elements.posted_array) {
      let account_no = row[0] || null;
      let account_name = row[1] || null;
      let credit_limit = row[2] || null;
      let email = row[3] || null;
      let tasgel_darepy = row[4] || null;
      let kanonya = row[5] || null;
      let tawasol_info = row[6] || null;
      let bank_info = row[7] || null;
      let taslem_address = row[8] || null;
      let is_allow_buy = row[9] || null;
    
      if (!account_name) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ±Ø¯ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
      if (account_no === 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…ÙˆØ±Ø¯ ( Ø§Ø®ØªÙŠØ§Ø±Ù‰ )' || account_name === 'Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ±Ø¯ ( Ù…Ø·Ù„ÙˆØ¨ )' || credit_limit === 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ø¦ØªÙ…Ø§Ù†Ù‰ ( Ø§Ø®ØªÙŠØ§Ø±ÙŠ )') {
        console.log(`skip header row`);
        //index++;
        continue;
      }

      if (is_allow_buy && is_allow_buy === 'Ù†Ø¹Ù…'){
        is_allow_buy = true
      }else{
        is_allow_buy = null
      }
    
    
      const isNameExists = db_AllAccounts.some((account) => account.account_name.trim() === account_name);
      if (isNameExists) {
        throw new Error(`âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ±Ø¯ '${account_name}' Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
    
      if (vendorNamesSet.has(account_name)) {
        throw new Error(`âŒ Ø§Ù„Ù…ÙˆØ±Ø¯ '${account_name}' Ù…ÙƒØ±Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
      vendorNamesSet.add(account_name);
    

      if (credit_limit !== null && (credit_limit === "" || isNaN(+credit_limit))) {
        throw new Error(`âŒ Ø­Ø¯ Ø§Ù„Ø¥Ø¦ØªÙ…Ø§Ù† ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ù„Ù…ÙˆØ±Ø¯  ${account_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
    
      array1.push([
        account_name,
        true,
        account_no,
        1,
        company_id,
        account_type_id,
        1,
        credit_limit,
        email,
        tasgel_darepy,
        kanonya,
        tawasol_info,
        taslem_address,
        bank_info,
        is_allow_buy
      ]);
    
      validRows.push(row); // ØªØ®Ø²ÙŠÙ† Ø§Ù„ØµÙ Ø§Ù„ØµØ§Ù„Ø­ ÙÙ‚Ø·
    
      index++;
    }
    
// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {

// Ø¥Ø¯Ø®Ø§Ù„ accounts_header
if (array1.length > 0){


let columnsCount = array1[0].length;
let query1 = `INSERT INTO accounts_header (account_name, is_final_account, account_no, finance_statement, company_id, account_type_id, main_account_id, numeric_column1, str_textarea_column5, str20_column1, str_textarea_column1, str_textarea_column2, str_textarea_column3, str_textarea_column4, is_allow_to_buy_and_sell)
      VALUES ${array1.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}
  RETURNING id;`;

const insertedIds = await tx.many(query1, array1.flat());

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª accounts_body
let array2 = insertedIds.map((inserted) => [
  parent_id, // Ø«Ø§Ø¨Øª Ù„ÙƒÙ„ Ø§Ù„ØµÙÙˆÙ
  inserted.id
]);


let columnsCount2 = array2[0].length;
let query2 = `INSERT INTO accounts_body (parent_id, account_id)
              VALUES ${array2.map((_, i) => 
                `(${Array.from({ length: columnsCount2 }, (_, j) => `$${i * columnsCount2 + j + 1}`).join(', ')})`
              ).join(', ')}`


await tx.none(query2, array2.flat());

}

 // await history(transaction_type, 1, newId_transaction_header, newReference_transaction_header, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
   // const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ù‰ Ø¨Ù†Ø¬Ø§Ø­ `,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error add_imported_customers:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

  //#region add vendor
  app.post("/addNewVendor", async (req, res) => {
    try {
          // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
          // io.emit('blockUser', { userId: req.session.userId });
          
      const posted_elements = req.body;
  
      //! Permission
      await permissions(req, "vendors_permission", "add");
      if (!permissions) {
        return;
      }
  
      //! sql injection check
      // const hasBadSymbols = sql_anti_injection([
      //   posted_elements.employee_name_input,
      //   posted_elements.today,
      //   posted_elements.employee_job_input,
      //   posted_elements.employee_beta2a_input,
      //   posted_elements.employee_adress_input,
      //   posted_elements.employee_phone_input,
      //   posted_elements.employee_emergency_phone_input,
      //   posted_elements.employee_start_date_input,
      //   posted_elements.employee_leave_date_input,
      //   // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      // ]);

      // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      if (!posted_elements.account_name_input_value || posted_elements.account_name_input_value === '') {
        return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ±Ø¯" });
      }
      //* Start--------------------------------------------------------------
  
      //2: validation data befor inserting to db
      // const rows = await db.any(
      //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
      //   [posted_elements.employee_name_input]
      // );
      let query0 = ` select
      (SELECT count(account_name) FROM accounts_header WHERE company_id = $1 AND TRIM(account_name) = $2) as account_name_count,
      (select id from accounts_header where company_id = $1 AND global_id = 14) as parent_id
                `;
      let result = await db.oneOrNone(query0, [
        req.session.company_id,
        posted_elements.account_name_input_value,
      ]);
  
      if (result.account_name_count > 0) {
        // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
        return res.json({ success: false, message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ±Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
      }
  
      //3: insert data into db
      
  
      let query1 = `
    INSERT INTO accounts_header (account_name, is_final_account, account_no, finance_statement, company_id, account_type_id, main_account_id, numeric_column1, str_textarea_column5, str20_column1, str_textarea_column1, str_textarea_column2, str_textarea_column3, str_textarea_column4, is_allow_to_buy_and_sell)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING id;
  `;

  let query2 = `
  INSERT INTO accounts_body (parent_id, account_id)
  values ($1, $2)
  `
  await db.tx(async (tx) => {
    const insert =  await tx.one(query1, [
      posted_elements.account_name_input_value,
      true,
      posted_elements.acc_no_div_value,
      1,
      req.session.company_id,
      3,
      2,
      posted_elements.credit_limit_value,
      posted_elements.email_input_value,
      posted_elements.tasgel_darepy_input_value,
      posted_elements.legal_info_input_value,
      posted_elements.contact_info_input_value,
      posted_elements.delivery_adress_input_value,
      posted_elements.banking_info_input_value,
      posted_elements.is_allow_to_buy_and_sell ? true : null,
    ]);

    const newId_header = insert.id
    await tx.none(query2,[result.parent_id,newId_header])
    await history(19,1,newId_header,0,req,tx)
  })

  last_activity(req)
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ±Ø¯ Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      last_activity(req)
      console.error("Error adding vendors:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#endregion

  //#region update vendor
  app.post("/updateVendor", async (req, res) => {
    try {
          // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
          // io.emit('blockUser', { userId: req.session.userId });
          
      const posted_elements = req.body;
  
      //! Permission
      await permissions(req, "vendors_permission", "update");
      if (!permissions) {
        return;
      }
  
      //! sql injection check
      
      // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      if (!posted_elements.account_name_input_value || posted_elements.account_name_input_value === '' || !posted_elements.account_id_hidden_value || isNaN(posted_elements.account_id_hidden_value) ) {
        return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ±Ø¯" });
      }
      //* Start--------------------------------------------------------------
  
      //2: validation data befor inserting to db
      // const rows = await db.any(
      //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
      //   [posted_elements.employee_name_input]
      // );
  

      let query0 = `
      select
      (SELECT count(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3 AND id != $2) as count_account_name_exist,
      (select count(id) FROM accounts_header WHERE company_id = $1 AND account_type_id = 3) as count_id
  `;
  
      let result = await db.oneOrNone(query0, [
        req.session.company_id,
        posted_elements.account_id_hidden_value,
        posted_elements.account_name_input_value,
      ]);
  
      if (result.count_id === 0) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      if (result.count_account_name_exist > 0) {
        return res.json({
          success: false,
          message_ar: "âŒ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ±Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
        });
      }
              
      let query1 = `
    UPDATE accounts_header set account_name = $1, account_no = $2, numeric_column1 = $3, str_textarea_column5 = $4, str20_column1 = $5, str_textarea_column1 = $6, str_textarea_column2 = $7, str_textarea_column3 = $8, str_textarea_column4 = $9, is_allow_to_buy_and_sell = $10
    WHERE company_id = $11 AND account_type_id = 3 AND id = $12
  `;
      let params1 =  [
        posted_elements.account_name_input_value,
        posted_elements.acc_no_div_value,
        posted_elements.credit_limit_value,
        posted_elements.email_input_value,
        posted_elements.tasgel_darepy_input_value,
        posted_elements.legal_info_input_value,
        posted_elements.contact_info_input_value,
        posted_elements.delivery_adress_input_value,
        posted_elements.banking_info_input_value,
        posted_elements.is_allow_to_buy_and_sell ? true : null,
        req.session.company_id,
        posted_elements.account_id_hidden_value
      ];
  

      await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(19,2,posted_elements.account_id_hidden_value,0,req,tx);
      })

      last_activity(req)
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ±Ø¯ Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      last_activity(req)
      console.error("Error adding vendors:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#endregion

  //#region delete vendor
  app.post("/delete_vendor", async (req, res) => {
    try {
      //! Permission
      await permissions(req, "vendors_permission", "delete");
      if (!permissions) {
        return;
      }
  
      const posted_elements = req.body;
      //! sql injection check
      const hasBadSymbols = sql_anti_injection([
        posted_elements.account_id_hidden_value,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      //* Start--------------------------------------------------------------
  
      if (!posted_elements.account_id_hidden_value || isNaN(posted_elements.account_id_hidden_value)) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
  
      let query0 = `
              select
              (select count(account_id) from transaction_body where account_id = $1) as count_account_id,
              (select count(id) from accounts_header where company_id = $2 AND account_type_id = 3) as count_id
      `

      let result = await db.oneOrNone(query0,[
        posted_elements.account_id_hidden_value,
        req.session.company_id
      ])


      if (result.count_id === 0) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      if (result.count_account_id > 0) {
        return res.json({
          success: false,
          message_ar: 'ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ : ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø°Ù',
        });
      }

      let query1 = `DELETE FROM accounts_header WHERE company_id = $1 AND id = $2 AND account_type_id = 3`;
      let params1 =  [
        req.session.company_id,
        posted_elements.account_id_hidden_value,
      ];
  

      await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(19,3,posted_elements.account_id_hidden_value,0,req,tx);
      })

      last_activity(req)
      return res.json({
        success: true,
        message_ar:
          "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ±Ø¯ Ø¨Ù†Ø¬Ø§Ø­ : Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ùƒ Ø§Ù„Ø§Ù† Ø§Ù„Ù‰ ØµÙØ­Ù‡ Ø§Ù„Ù…ÙˆØ±Ø¯ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙ‡",
      });
    } catch (error) {
      last_activity(req)
      console.error("Error get vendor data:", error);
      res.status(500).json({
        success: false,
        message_ar:
          "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ±Ø¯ : Ù‚Ø¯ ØªÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ø±ØªØ¨Ø·Ù‡ Ø¨Ø§Ù„Ù…ÙˆØ±Ø¯ ÙŠØ¬Ø¨ Ø­Ø°ÙÙ‡Ø§ Ø§ÙˆÙ„Ø§",
      });
    }
  });
  //#endregion

//#endregion

//#region effects

//#region 1: Add effects_add
app.post("/effects_add", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "effects_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;



    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.status(400).json({
        success: false,
        message_ar: "ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£Ø­Ø±Ù ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§ ÙÙŠ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
      });
    }

    const InValidDateFormat = isInValidDateFormat([posted_elements.date_input_val]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.date_input_val,
      type: 'add',
      tableName: 'effects', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.id_hidden_input_val, // if type = 'update' or 'delete' only
    }, req);


    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    
    const year = getYear(posted_elements.date_input_val)
    const newReference = await newReference_fn('effects', year, req);
    const new_referenceFormatting = formatFromFiveDigits(newReference);
    await db.tx(async (tx) => {

    let query1 = `INSERT INTO effects (employee_id, datex, days, hours, values, note, company_id, reference) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id;`;
    let params1 = [
      posted_elements.id_hidden_input_val,
      posted_elements.date_input_val,
      posted_elements.days_input_val,
      posted_elements.hours_input_val,
      posted_elements.values_input_val,
      posted_elements.note_input_val,
      req.session.company_id,
      newReference,
    ];

    

 
    const insert = await tx.one(query1, params1);
      const newId = insert.id
      //! history
      await history(16, 1, newId, newReference, req, tx);
    });

    await last_activity(req);
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ø­ÙˆÙ„ Ù†Ø¬Ø§Ø­ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
    res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¤Ø«Ø± Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error adding effects:", error);
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ø­ÙˆÙ„ ÙØ´Ù„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//#endregion END - Add effects_add

//#region 2: get data to fill dropdownbox of employees
app.post("/getEmployeesData1", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "effects_permission", "view");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `SELECT id, account_name 
FROM accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4 
  AND is_final_account IS TRUE 
  AND is_inactive IS NULL;
`;
    let data = await db.any(query1, [req.session.company_id]);

    res.json(data);
  } catch (error) {
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});
//#endregion

//#region 3: get data for review tables
app.post("/effects_view", async (req, res) => {
  try {
    
    const posted_elements = req.body;

    //! Permission
    await permissions(req, "effects_permission", "view");
    if (!permissions) {
      return;
    }

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
        if (posted_elements.checkbox_aggregation_val && posted_elements.select_aggregation_val == '1') {
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        }


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------

        
        

        let query
        let params;

        if (posted_elements.checkbox_aggregation_val && posted_elements.checkbox_aggregation_val === true){
          
          query = `
SELECT 
    NULL as id, -- Ø¹Ø§Ù…ÙˆØ¯ id Ø¨Ø¨ÙŠØ§Ù†Ø§Øª ÙØ§Ø±ØºØ©
    COALESCE(ah.account_no, '') as account_no, -- Ø¥Ø¶Ø§ÙØ© account_no Ù…Ù† accounts_header
    NULL as datex, -- Ø¹Ø§Ù…ÙˆØ¯ datex Ø¨Ø¨ÙŠØ§Ù†Ø§Øª ÙØ§Ø±ØºØ©
    NULL as reference,
    A.employee_id,
    COALESCE(ah.account_name, '') as account_name,
    SUM(COALESCE(A.days, 0)) as days, -- Ø¬Ù…Ø¹ Ø£ÙŠØ§Ù… Ø§Ù„Ø­Ø¶ÙˆØ±
    SUM(COALESCE(A.hours, 0)) as hours, -- Ø¬Ù…Ø¹ Ø§Ù„Ø³Ø§Ø¹Ø§Øª
    SUM(COALESCE(A.values, 0)) as values, -- Ø¬Ù…Ø¹ Ø§Ù„Ù‚ÙŠÙ…
    '' as note, -- Ø­Ù‚Ù„ note Ø¨Ø¨ÙŠØ§Ù†Ø§Øª ÙØ§Ø±ØºØ©
    CASE
        WHEN ah.is_inactive = true THEN 'ØºÙŠØ± Ù†Ø´Ø·'
        ELSE 'Ù†Ø´Ø·'
    END as is_inactive,
    COALESCE(parent_ah.id, 0) as department_id, -- ID Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨
    COALESCE(parent_ah.account_name, '') as department_name -- Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨
FROM 
    effects A
LEFT JOIN
    accounts_header ah ON A.employee_id = ah.id
LEFT JOIN 
    accounts_body ab ON ah.id = ab.account_id -- Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ accounts_body Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ parent_id
LEFT JOIN 
    accounts_header parent_ah ON ab.parent_id = parent_ah.id -- Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ accounts_header Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ account_name Ù„Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨
WHERE
    A.company_id = $1
    AND ah.account_type_id = 4
    AND ah.is_final_account = true
    AND (A.datex BETWEEN $2 AND $3 )
GROUP BY 
    A.employee_id, ah.account_name, parent_ah.id, parent_ah.account_name, ah.account_no, ah.is_inactive
ORDER BY 
    A.employee_id;

`

  params = [req.session.company_id,posted_elements.start_date,posted_elements.end_date]


        }else{
          query =  `
          SELECT 
              A.id,
              COALESCE(ah.account_no, '') as account_no,
              COALESCE(A.datex, '') as datex,
              CONCAT(
              	tt.doc_prefix, '-',
        		SUBSTRING(A.datex, 1, 4), '-',
        		LPAD(CAST(A.reference AS TEXT), 5, '0')
    		  ) AS referenceconcat,
              A.employee_id,
              COALESCE(ah.account_name, '') as account_name,
              COALESCE(A.days, 0) as days, 
              COALESCE(A.hours, 0) as hours,
              COALESCE(A.values, 0) as values,
              COALESCE(A.note, '') as note,
              CASE 
                  WHEN ah.is_inactive = true THEN 'ØºÙŠØ± Ù†Ø´Ø·'
                  ELSE 'Ù†Ø´Ø·'
              END as is_inactive,
              COALESCE(parent_ah.id, 0) as department_id, -- Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ID Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨
              COALESCE(parent_ah.account_name, '') as department_name -- Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨
          FROM effects A
          LEFT JOIN accounts_header ah ON A.employee_id = ah.id
          LEFT JOIN accounts_body ab ON ah.id = ab.account_id -- Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ accounts_body Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ parent_id
          LEFT JOIN accounts_header parent_ah ON ab.parent_id = parent_ah.id -- Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ accounts_header Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ account_name Ù„Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨
          LEFT JOIN transaction_type tt ON tt.id = 16
          WHERE
              A.company_id = $1
              AND ah.account_type_id = 4
              AND ah.is_final_account = true
              AND (A.datex BETWEEN $2 AND $3 )
              AND (A.employee_id = $4 OR $4 IS NULL)
          ORDER BY
              A.datex DESC,
              A.reference DESC;
          `

          params = [req.session.company_id,posted_elements.start_date,posted_elements.end_date,posted_elements.QKey] 
        }
    


    let data = await db.any(query, params);
    res.json(data);
  } catch (error) {
    console.error("Error getEffectsData1:", error);
    res
      .status(500)
      .json({ success: false, message_ar: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª" });
  }
});
//#endregion

//#region 4: update effects
app.post("/updateeffects", async (req, res) => {
  try {
    const posted_elements = req.body;

    //! Permission
    await permissions(req, "effects_permission", "view");
    if (!permissions) {
      return;
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.effects_id,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* Start--------------------------------------------------------------


    let query1 = `SELECT A.id, A.employee_id, E.employee_name, A.days, A.hours, A.values, A.note, A.datex, A.last_update
      FROM effects A
      LEFT JOIN  employees E on A.employee_id = E.id
      where A.company_id = $1 AND A.id=$2 
      ORDER BY A.datex DESC`;
    let rows = await db.any(query1, [
      req.session.company_id,
      posted_elements.effects_id,
    ]);

    if (rows.length > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: true,
        message_ar: "âœ… data get success",
        rows: rows,
      });
    } else {
      return res.json({
        success: false,
        message_ar: "Faild to get data from server",
      });
    }
  } catch (error) {
    console.error("Error updateeffects:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region 5: Update effects data
app.post("/effects_update", async (req, res) => {
  try {
    const posted_elements = req.body;
    //! Permission
    await permissions(req, "effects_permission", "update");
    if (!permissions) {
      return;
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    const InValidDateFormat = isInValidDateFormat([posted_elements.date_val])
    if (InValidDateFormat){
      return res.json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      type: 'update',
      tableName: 'effects',
      transaction_id: posted_elements.id,
      datex: posted_elements.date_val,
    }, req);

    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

if (!posted_elements.emp_name || posted_elements.emp_name == ''){
return res.json({
  success: false,
  message_ar:
    "Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù Ø§ÙˆÙ„Ø§",
});
}  
    //* Start--------------------------------------------------------------

    let query01 = `select id, datex, reference from effects where id = $1 and company_id = $2`
    let result01 = await db.oneOrNone(query01, [posted_elements.id, req.session.company_id])
    if (!result01){
      await block_user(req,'Seu001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    const year = getYear(result01.datex)
    // const reference = formatFromFiveDigits(posted_elements.reference);
    const reference = result01.reference
    const new_reference = formatFromFiveDigits(reference)
    

    

    let query1 = `UPDATE effects SET employee_id = $1, datex = $2, days = $3, hours = $4, values = $5, note = $6 where id = $7 AND company_id = $8 `;
    let params1 = [
      posted_elements.emp_id,
      posted_elements.date_val,
      posted_elements.days_val,
      posted_elements.hours_val,
      posted_elements.values_val,
      posted_elements.note_val,
      posted_elements.id,
      req.session.company_id,
    ]


  

    await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(16, 2, posted_elements.id, reference, req, tx)
    });

    
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ø«Ø± Ø¨Ù…Ø±Ø¬Ø¹ : ${new_reference}-${year}`,
    });
    
  } catch (error) {
    console.error("Error get employee data:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region 6: Delete attatendace
app.post("/effects_delete", async (req, res) => {
  try {
    const posted_elements = req.body;
    
    //! Permission
    await permissions(req, "effects_permission", "delete");
    if (!permissions) {
      return res.status(403).json({ success: false, message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø¥Ø°Ù† Ù„Ù„Ø­Ø°Ù." });
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: "Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      type: 'delete',
      tableName: 'effects',
      transaction_id: posted_elements.id,
      datex: posted_elements.datex,
    }, req);

    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    //* Start--------------------------------------------------------------

    let query01 = `select id, datex, reference from effects where id = $1 and company_id = $2`
    let result01 = await db.oneOrNone(query01, [posted_elements.id, req.session.company_id])
    if (!result01){
      await block_user(req,'Sed001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    const year = getYear(result01.datex)
    // const reference = formatFromFiveDigits(posted_elements.reference);
    const reference = result01.reference
    const new_reference = formatFromFiveDigits(reference)
    


    let query1 = `delete from effects WHERE company_id = $1 AND id = $2`;
    let params1 = [req.session.company_id, posted_elements.id];




    await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(16, 3, posted_elements.id, reference, req, tx)
    });


    
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø¤Ø«Ø± Ø¨Ù…Ø±Ø¬Ø¹ : ${new_reference}-${year}`,
    });
  } catch (error) {
    console.error("Error during effects deletion:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


//#endregion
//#endregion END - effects

//#region production

app.post("/production_add_ar", async (req, res) => {
  try {
    const posted_elements = req.body;

    //! Permission
    await permissions(req, "production_permission", "add");
    if (!permissions) {
      return;
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.production_amount_input,
      posted_elements.sales_amount_input,
      posted_elements.note1_input,
      posted_elements.date1,
      posted_elements.today,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
    //* Start--------------------------------------------------------------

   

    let query = `
  INSERT INTO production (datex, procution_amount, sales_amount, note, company_id)
  VALUES ($1, $2, $3, $4, $5) RETURNING id;
`;
const insert = await db.one(query, [
      posted_elements.date1,
      posted_elements.production_amount_input,
      posted_elements.sales_amount_input,
      posted_elements.note1_input,
      req.session.company_id,
    ]);

    const newId = insert.id;

    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding production:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

// get all production data
app.post("/get_All_production_Data", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "production_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
    if (InValidDateFormat){
      return res.json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }
  
    turn_EmptyValues_TO_null(posted_elements);


    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query0 = `SELECT 
        COALESCE(SUM(procution_amount - sales_amount), 0) AS opening_balance
    FROM 
        production
    WHERE 
        company_id = $1 
        AND datex < $2; `
        let result = await db.oneOrNone(query0,[req.session.company_id,posted_elements.start_date])
        let opening_balance = result.opening_balance
        

    let query1 = `SELECT
    id,
    datex,
    note,
    procution_amount,
    sales_amount,
    '' as cumulative_balance
FROM
    production
 WHERE
 company_id = $2
 AND (datex BETWEEN $3 AND $4 )
ORDER BY
    datex DESC, id DESC;
;`;

    let data = await db.any(query1, [opening_balance,req.session.company_id,posted_elements.start_date, posted_elements.end_date]);

    let ServerData = {data,opening_balance}

// Ø¯Ù…Ø¬ ØµÙ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø§ÙØªØªØ§Ø­ÙŠ Ù…Ø¹ Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©

    res.json(ServerData);
  } catch (error) {
    console.error("Error fetching data:", error);
    res.status(500).send("Error: getProductionData");
  }
});

// update production
app.post("/production_update_ar", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "production_permission", "update");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.id_input,
      posted_elements.production_amount_input,
      posted_elements.sales_amount_input,
      posted_elements.note1_input,
      posted_elements.date1,
      posted_elements.today,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* Start--------------------------------------------------------------

    let query2 = `UPDATE production
        SET datex = $1,
        procution_amount = $2,
        sales_amount = $3,
        note = $4
        where company_id = $5 AND id = $6`;
    await db.none(query2, [
      posted_elements.date1,
      posted_elements.production_amount_input,
      posted_elements.sales_amount_input,
      posted_elements.note1_input,
      req.session.company_id,
      posted_elements.id_input,
    ]);

    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ùƒ Ø§Ù„Ø§Ù† Ø§Ù„Ù‰ ØµÙØ­Ù‡ Ø§Ù„Ø¬Ø±Ø¯ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙ‡",
    });
  } catch (error) {
    console.error("Error production_update_ar", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

// Delete Production
app.post("/delete_production", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "production_permission", "delete");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.id,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* Start--------------------------------------------------------------



    let query1 = `DELETE FROM production WHERE company_id = $1 AND id = $2`;
    await db.none(query1, [req.session.company_id, posted_elements.id]);

    return res.json({
      success: true,
      message_ar:
        "âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­ : Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ùƒ Ø§Ù„Ø§Ù† Ø§Ù„Ù‰ ØµÙØ­Ù‡ Ø§Ù„Ø¬Ø±Ø¯ ÙˆØ§Ù„Ø§Ù†ØªØ§Ø¬ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙ‡",
    });
  } catch (error) {
    console.error("Error get employee data:", error);
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion END- production

//#region  bread

//#region 1: bread_review
app.post("/get_All_bread_Data", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "bread_permission", "view");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `SELECT
    h.id AS h_id, 
    h.datex, 
    h.vendor_id, 
    v.vendore_name,
    h.note,
    SUM(b.wazn) / 1000 AS total_wazn, 
    SUM(b.amount) AS total_amount
FROM bread_header AS h
left JOIN vendors AS v ON h.vendor_id = v.id
INNER JOIN bread_body AS b ON h.id = b.bread_header_id
where h.company_id = $1
GROUP BY h.id, h.datex, h.vendor_id, v.vendore_name
ORDER BY h.datex DESC, h.id DESC;
`;
    let rows = await db.any(query1, [req.session.company_id]);

    const data = rows.map((row) => ({
      id: row.h_id,
      datex: row.datex,
      vendor_id: row.vendor_id,
      vendore_name: row.vendore_name,
      note: row.note,
      wazn: row.total_wazn,
      amount: row.total_amount,
    }));

    res.json(data);
  } catch (error) {
    console.error("Error get_All_bread_Data:", error);
    res.status(500).send("Error:");
  }
});
//#endregion

//#region 2: add_bread
app.post("/api/bread_add", async (req, res) => {
  const posted_elements = req.body;

  try {
    

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {
      let query1 = `INSERT INTO bread_header
                    (datex, vendor_id, note, company_id)
                    VALUES($1, $2, $3, $4) RETURNING id;`;

      const insert =  await tx.one(query1, [
        posted_elements.datex,
        posted_elements.vendore_id,
        posted_elements.note_inpute_value,
        req.session.company_id,
      ]);

      const newId_bread_header = insert.id;

      for (const element of posted_elements.posted_array) {
        let query2 = `INSERT INTO bread_body
                      (bread_header_id, wazn, amount)
                      VALUES($1, $2, $3);`;

        await tx.none(query2, [
          newId_bread_header,
          element.wazn,
          element.amount,
        ]);

      }
    });

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding account:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø­ÙØ¸ ÙˆØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©",
    });
  }
});

//#endregion

//#region 3: get_bread_Data_for_update_page

app.post("/get_bread_Data_for_update_page", async (req, res) => {
  try {
    const posted_elements = req.body;
    //! Permission
    await permissions(req, "bread_permission", "update");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
let query0 = `select note from bread_header where company_id = $1 AND id = $2`
let rows0 = await db.oneOrNone(query0,[req.session.company_id,posted_elements.h_id])

    let query1 = `SELECT
    wazn, 
    amount
FROM bread_body
WHERE bread_header_id = $1 ;`;
    let rows = await db.any(query1, [posted_elements.h_id]);

    // const data = rows.map((row) => ({
    //   wazn: row.wazn,
    //   amount: row.amount,
    // }));

  const data = {header:rows0 , body:rows}    
    res.json(data);
  } catch (error) {
    console.error("Error get_bread_Data_for_update_page:", error);
    res.status(500).send("Error:");
  }
});

//#endregion

//#region 4: /api/bread_update
//! Update code
app.post("/api/bread_update", async (req, res) => {
  try {
    const posted_elements = req.body;
    await db.tx(async (tx) => {
      // delete data from body as a first stip

      let query0 = `DELETE FROM bread_body
    WHERE bread_header_id = $1;`;

      await tx.none(query0, [posted_elements.h_id]);

      // add data
      // 

      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

      let query1 = `INSERT INTO bread_header
                    (datex, vendor_id, note, company_id)
                    VALUES($1, $2, $3, $4) RETURNING id;`;

      const insert = await tx.one(query1, [
        posted_elements.datex,
        posted_elements.vendore_id,
        posted_elements.note,
        req.session.company_id,
      ]);

      const newId_bread_header = insert.id;

      for (const element of posted_elements.posted_array) {
        let query2 = `INSERT INTO bread_body
                      (bread_header_id, wazn, amount)
                      VALUES($1, $2, $3);`;

        await tx.none(query2, [
          newId_bread_header,
          element.wazn,
          element.amount,
        ]);

      }
    });

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding account:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙˆØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©",
    });
  }
});

//#endregion

//#region 5: /api/bread_delete
//! Delete code
app.post("/api/bread_delete", async (req, res) => {
  //! Permission
  await permissions(req, "bread_permission", "delete");
  if (!permissions) {
    return;
  }

  //* Start--------------------------------------------------------------

  try {
    const posted_elements = req.body;
    await db.tx(async (tx) => {
      // delete data from body as a first stip

      let query0 = `DELETE FROM bread_body
WHERE bread_header_id = $1;`;

      await tx.none(query0, [posted_elements.h_id]);

      let query1 = `DELETE FROM bread_header
                WHERE company_id = $1 AND id = $2;`;

      await tx.none(query1, [req.session.company_id, posted_elements.h_id]);
    });

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø§Ù„Ø­Ø°Ù Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding account:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø­Ø°Ù ÙˆØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©",
    });
  }
});
//#endregion

//#endregion end - update bread

//#region report effects
app.post("/report_effects", async (req, res) => {
  try {
    const posted_elements = req.body;
    //! Permission
    await permissions(req, "effects_permission", "view");
    if (!permissions) {
      return;
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.report_type,
      posted_elements.employee_id,
      posted_elements.month,
      posted_elements.year,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    //* Start--------------------------------------------------------------

    if (posted_elements.report_type === 2) {
      let query1 = `SELECT
      e.id As employee_id,
      e.employee_name,
      SUM(a.days) AS total_days,
      SUM(a.hours) AS total_hours,
      SUM(a.values) AS total_values
    FROM effects a
    LEFT JOIN employees e ON e.id = a.employee_id
    WHERE
      a.company_id = $1
      AND EXTRACT(MONTH FROM to_date(a.datex, 'YYYY-MM-DD')) = $2
      AND EXTRACT(YEAR FROM to_date(a.datex, 'YYYY-MM-DD')) = $3
    GROUP BY e.employee_name, e.id
    ORDER BY e.employee_name ASC`;
      let rows = await db.any(query1, [
        req.session.company_id,
        posted_elements.month,
        posted_elements.year,
      ]);

      if (rows.length > 0) {
        const data = rows.map((row) => ({
          employee_id: row.employee_id,
          employee_name: row.employee_name,
          total_days: row.total_days,
          total_hours: row.total_hours,
          total_values: row.total_values,
        }));

        res.json(data);
      } else {
        return res.json({
          success: false,
          message_ar: "âŒ Ù„Ø§ Ù†ØªØ§Ø¦Ø¬",
        });
      }
    } else {
      // ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„Ù…ÙˆØ¸Ù Ø§Ù„ÙØ±Ø¯Ù‰ Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† Ù†ÙˆØ¹ Ø§Ù„ØªÙ‚Ø±ÙŠØ± 1

      let query1 = `SELECT
      a.id,
      e.id As employee_id,
      e.employee_name,
      a.days,
      a.hours,
      a.values,
      a.note,
      a.datex
    FROM effects a
    LEFT JOIN employees e ON e.id = a.employee_id
    WHERE
      a.company_id = $1
      AND a.employee_id = $2
      AND EXTRACT(MONTH FROM to_date(a.datex, 'YYYY-MM-DD')) = $3
      AND EXTRACT(YEAR FROM to_date(a.datex, 'YYYY-MM-DD')) = $4
    ORDER BY a.datex DESC, e.employee_name ASC;`;
      let rows = await db.any(query1, [
        req.session.company_id,
        posted_elements.employee_id,
        posted_elements.month,
        posted_elements.year,
      ]);

      if (rows.length > 0) {
        const data = rows.map((row) => ({
          id: row.id,
          employee_id: row.employee_id,
          employee_name: row.employee_name,
          days: row.days,
          hours: row.hours,
          values: row.values,
          note: row.note,
          datex: row.datex,
        }));

        res.json(data);
      } else {
        return res.json({
          success: false,
          message_ar: "âŒ Ù„Ø§ Ù†ØªØ§Ø¦Ø¬",
        });
      }
    }
  } catch (error) {
    console.error("Error report_effects:", error);
    res.status(500).json({
      success: false,
      message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
    });
  }
});

//#endregion

//#region  Accounts

app.get("/api/tree", async (req, res) => {
  try {
    const accumulatedValues = is_accumulated_account.join(',');
    let query1 = `
    SELECT h1.id AS account_id,
    h1.account_name AS account_name,
    h1.is_final_account AS is_final_account,
    h1.account_no AS account_no,
    h1.finance_statement AS finance_statement,
    h1.cashflow_statement AS cashflow_statement,
    h1.global_id AS global_id,
    h2.id AS parent_id,
    h2.account_name AS parent_name
FROM accounts_header h1
LEFT JOIN accounts_body b ON h1.id = b.account_id
LEFT JOIN accounts_header h2 ON b.parent_id = h2.id
WHERE h1.company_id = $1
  AND h1.finance_statement IN (1, 2)
  AND (h1.global_id IS NULL OR h1.global_id != 8)
  AND (b.parent_id IS NULL OR b.parent_id NOT IN (${accumulatedValues}))
ORDER BY h1.id asc;`;  // in (1,2 ) ya3ny = 1 or 2 

    // Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
    
    let treeData = await db.any(query1, [req.session.company_id]);
    res.json(treeData);
  } catch (error) {
    console.error("Error fetching tree data:", error);
    res.status(500).send("Server Error");
  }
});


app.post("/api/addGroup-account", async (req, res) => {
  try {
    const posted_elements = req.body;

    // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© (Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù‚Ø¯ ÙØ±Ø¹ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹)

    // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
    const hasPermission = await permissions(req, "accounts_permission", "add");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø§Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
    const hasBadSymbols = sql_anti_injection([
      posted_elements.accountname,
      posted_elements.accountParent,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    //* Start--------------------------------------------------------------
    let result = [];
    const query = `
      SELECT
        (SELECT finance_statement FROM accounts_header WHERE company_id = $1 AND id = $2) AS finance_statement,
        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $2) AS is_final_account,
        (SELECT global_id FROM accounts_header WHERE company_id = $1 AND id = $2) AS global_id,
        (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3) AS count_account_name,
        (SELECT main_account_id FROM accounts_header WHERE company_id = $1 AND id = $2) AS main_account_id
    `;
    
    result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.accountParent,
      posted_elements.accountname,
    ]);
    
    if (result.is_final_account) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù…Ø¬Ù…ÙˆØ¹Ù‡ ÙØ±Ø¹ÙŠØ© Ø¶Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡",
      });
    }


    if (result.finance_statement === null) {
      await block_user(req,'adac1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    
    
    if (result.global_id !== null && is_forbidden_adding_branches.includes(result.global_id)) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ Ø§Ø¶Ø§ÙØ© ÙŠÙ…ÙƒÙ† Ù…Ø¬Ù…ÙˆØ¹Ù‡ ÙØ±Ø¹ÙŠØ© Ø¶Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡",
        message_en: "Cannot add group in this group",
      });
    }
    
    if (result.count_account_name > 0) {
      return res.json({
        success: false,
        message_ar: "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
        message_en: "Account with this name already exists",
      });
    }
    
    await db.tx(async (tx) => {
    // Additional logic here if needed
    
   
    const query1 = `INSERT INTO accounts_header (account_name, is_final_account, finance_statement,company_id, main_account_id)
                          values ($1,$2,$3,$4,$5) RETURNING id; `;
    const query1_parameters = [posted_elements.accountname,false,result.finance_statement,req.session.company_id,result.main_account_id]

    const insert = await tx.one(query1,query1_parameters);
    let new_account_header_id = insert.id;

    const query2 =`INSERT INTO accounts_body (parent_id,account_id)
                                      values($1,$2);`;
    const query2_parameters = [posted_elements.accountParent,new_account_header_id];
      
      await tx.none(query2,query2_parameters);

    })
    // Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø§Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø¨Ù†Ø¬Ø§Ø­",
      message_en: "",
    });
  } catch (error) {
    console.error("Error addGroup-account:", error);
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
      message_en: "An error occurred while deleting the account",
    });
  }
});

app.post("/api/add-account", async (req, res) => {
  

  try {
    const posted_elements = req.body;

    const hasPermission = await permissions(req, "accounts_permission", "add");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø§Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
    const hasBadSymbols = sql_anti_injection([
      posted_elements.account_no,
      posted_elements.account_name,
      posted_elements.account_parent_name_id,
      posted_elements.cash_flow_statement_value,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    //#region validation
    let result = [];
    const query = `
      SELECT
        (SELECT finance_statement FROM accounts_header WHERE company_id = $1 AND id = $2) AS finance_statement,
        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $2) AS is_final_account,
        (SELECT global_id FROM accounts_header WHERE company_id = $1 AND id = $2) AS global_id,
        (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3) AS count_account_name,
        (SELECT main_account_id FROM accounts_header WHERE company_id = $1 AND id = $2) AS main_account_id
    `;

    result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.account_parent_name_id,
      posted_elements.account_name,
    ]);
    

    if (result.is_final_account) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙØ© Ù…Ø¬Ù…ÙˆØ¹Ù‡ ÙØ±Ø¹ÙŠØ© Ø¶Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡",
      });
    }


    if (result.finance_statement === null) {
      await block_user(req,'ada1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
  
    if (result.global_id !== null && is_forbidden_adding_branches.includes(result.global_id)) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ ÙØ±Ø¹Ù‰ Ø¶Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡",
        message_en: "Cannot add group in this group",
      });
    }
    
    if (result.count_account_name > 0) {
      return res.json({
        success: false,
        message_ar: "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
        message_en: "Account with this name already exists",
      });
    }
    //#endregion end- validation

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {
      // Ø£Ø¯Ø®Ù„ into accounts_header
     
      let query1 = `INSERT INTO accounts_header (account_name, account_no, is_final_account, finance_statement, cashflow_statement, account_type_id, main_account_id, company_id)
                        VALUES ($1, $2, $3, $4, $5, $6, $7,$8) RETURNING id;`;
      const insert = await tx.one(query1, [
        posted_elements.account_name,
        posted_elements.account_no,
        true,
        result.finance_statement,
        posted_elements.cash_flow_statement_value,
        1,
        result.main_account_id,
        req.session.company_id,
      ]);
      let new_account_id = insert.id;

      // Ø£Ø¯Ø®Ù„ into accounts_body
      let query2 = `INSERT INTO accounts_body (parent_id, account_id)
                        VALUES ($1, $2)`;
      await tx.none(query2, [
        posted_elements.account_parent_name_id,
        new_account_id,
      ]);
    });

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding account:", error);
    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙØ´Ù„Øª
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

// contextmenu / update new node
app.post("/api/update-account", async (req, res) => {
  

  try {
    const posted_elements = req.body;
    
    const hasPermission = await permissions(req, "accounts_permission", "update");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }


    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
    if (posted_elements.is_group){
      const hasBadSymbols = sql_anti_injection([
        posted_elements.account_id,
        posted_elements.account_name,
        posted_elements.parent_id,
        posted_elements.is_group,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
    }else{
      const hasBadSymbols = sql_anti_injection([
        posted_elements.account_name,
        posted_elements.account_no,
        posted_elements.statment_type_value,
        posted_elements.account_id,
        posted_elements.parent_id,
        posted_elements.is_group,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
    }


    let result = [];
    const query = `
      SELECT
        (SELECT finance_statement FROM accounts_header WHERE company_id = $1 AND id = $2) AS finance_statement,
        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $2) AS is_final_account,
        (SELECT global_id FROM accounts_header WHERE company_id = $1 AND id = $2) AS global_id,
        (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3 AND id != $4) AS count_account_name,
        (SELECT COUNT(main_account_id) FROM accounts_header WHERE company_id = $1 AND id = $2) AS main_account_id
    `;

    result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.parent_id,
      posted_elements.account_name,
      posted_elements.account_id,
    ]);
    
    if (result.is_final_account) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙØ© Ù…Ø¬Ù…ÙˆØ¹Ù‡ ÙØ±Ø¹ÙŠØ© Ø¶Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡",
      });
    }

    if (!posted_elements.is_group){
      if (result.finance_statement === null) {
        await block_user(req,'uda1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }

    
    //! Ù…Ø¹Ù„Ù‚ -- Ù…Ø·Ù„ÙˆØ¨ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø§ÙŠÙ† Ø§ÙƒÙˆÙ†ØªØ³ ÙÙ‰ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø§ÙƒÙˆÙ†Øª Ù‡ÙŠØ¯Ø±Ø² Ø¨Ù†Ø§Ø¡  Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø¨
    if (result.global_id !== null && is_forbidden_adding_branches.includes(result.global_id)) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ ÙØ±Ø¹Ù‰ Ø¶Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡",
        message_en: "Cannot add group in this group",
      });
    }
    
    if (result.count_account_name > 0) {
      return res.json({
        success: false,
        message_ar: "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
        message_en: "Account with this name already exists",
      });
    }

    let query1;
    let query1_parameters;
    let query2;
    let query2_parameters;
    if (posted_elements.is_group){

      
      query1 = `UPDATE accounts_header SET 
      account_name = $1
      WHERE company_id = $2 AND id = $3`;
      query1_parameters = [
        posted_elements.account_name,
        req.session.company_id,
        posted_elements.account_id,
      ]

      query2 = `UPDATE accounts_body SET 
      parent_id = $1
      WHERE account_id = $2`;
      query2_parameters = [
        posted_elements.parent_id,
        posted_elements.account_id
      ]


    }else{
      query1 = `UPDATE accounts_header SET 
      account_name = $1,
      account_no = $2,
      finance_statement = $3,
      cashflow_statement = $4
      WHERE company_id = $5 AND id = $6`;
      query1_parameters = [
        posted_elements.account_name,
        posted_elements.account_no,
        posted_elements.statment_type_value,
        posted_elements.cash_flow_statement_value,
        req.session.company_id,
        posted_elements.account_id,
      ]

      query2 = `UPDATE accounts_body SET 
      parent_id = $1
      WHERE account_id = $2`;
      query2_parameters = [
        posted_elements.parent_id,
        posted_elements.account_id
      ]
    }

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {
      await tx.none(query1, query1_parameters);
      await tx.none(query2, query2_parameters)
    });

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding account:", error);
    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙØ´Ù„Øª
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/rename-account", async (req, res) => {
  try {
    const posted_elements = req.body;

    // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© (Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù‚Ø¯ ÙØ±Ø¹ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹)

    // //! Permission

    const hasPermission = await permissions(req, "accounts_permission", "update");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„ØªØ­Ø¯ÙŠØ« Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    //! sql injection check
    const hasBadSymbols = sql_anti_injection([
      posted_elements.account_id,
      posted_elements.account_rename_input
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: "ØªÙ… Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ø¨Ø³Ø¨Ø¨ ÙˆØ¬ÙˆØ¯ Ø±Ù…ÙˆØ² Ù…Ù…Ù†ÙˆØ¹Ø©. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
        message_ar: "Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    // Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙˆØ§Ø­Ø¯ Ù„Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
    const query = `
      SELECT 
        (SELECT COUNT(*) FROM accounts_header WHERE company_id = $1 AND id = $2) AS account_exists,
        (SELECT global_id FROM accounts_header WHERE company_id = $1 AND id = $2) AS global_id,
        (SELECT COUNT(*) FROM accounts_header WHERE company_id = $1 AND id != $2 AND trim(account_name) = $3) AS account_name_exists
    `;
    const result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.account_id,
      posted_elements.account_rename_input
    ]);

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯
    if (result.account_exists === 0) {
      await block_user(req,'arc01');
      return res.json({
        success: false,
        message_ar: "ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨",
        xx: true,
        message_en: "Cannot delete account with sub-accounts",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°ÙÙ‡
    if (result.global_id !== null && global_id > 0) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¹Ø§Ø¯Ø© ØªÙ…Ø³ÙŠØ© Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ø§Ù†Ù‡ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©",
        message_en: "Cannot delete account with sub-accounts",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„
    if (result.account_name_exists > 0) {
      return res.json({
        success: false,
        message_ar: "Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ : ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠÙ‡",
        message_en: "Cannot delete account with sub-accounts",
      });
    }

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ø³Ù…
    const updateQuery = `
      UPDATE accounts_header 
      SET account_name = $1 
      WHERE company_id = $2 AND id = $3
    `;
    await db.none(updateQuery, [
      posted_elements.account_rename_input,
      req.session.company_id,
      posted_elements.account_id
    ]);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­",
      message_en: "Account deleted successfully",
    });
  } catch (error) {
    console.error("Error rename account:", error);
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
      message_en: "Can't delete this account with sub-accounts in it",
    });
  }
});





// Ù…Ø³Ø§Ø± Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ø§Øª Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨
app.post("/api/delete-account", async (req, res) => {
  try {
    const posted_elements = req.body;

    // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© (Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù‚Ø¯ ÙØ±Ø¹ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹)

    // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
    const hasPermission = await permissions(req, "accounts_permission", "delete");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
    const hasBadSymbols = sql_anti_injection([
      posted_elements.account_id,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    //* Start--------------------------------------------------------------

    const query = `
      SELECT
        (SELECT COUNT(*) FROM accounts_header WHERE company_id = $1 AND id = $2) AS account_exists,
         (SELECT global_id FROM accounts_header WHERE company_id = $1 AND id = $2) AS global_id,
        (SELECT COUNT(*) FROM accounts_body WHERE parent_id = $2) as parentId
    `;

    const result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.account_id
    ]);


    if (result.account_exists === 0){
      await block_user(req,'adc01');
      return res.json({
        success: false,
        message_ar: "ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨",
        xx: true,
        message_en: "Cannot delete account with sub-accounts",
      });
    }

    if (result.global_id !== null && global_id > 0) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ø£Ù†Ù‡ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©",
        message_en: "Cannot delete account as it is a default account",
      });
    }

    if (result.parentid > 0) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„ÙˆØ¬ÙˆØ¯ Ø­Ø³Ø§Ø¨Ø§Øª ÙØ±Ø¹ÙŠØ© Ø¨Ø¯Ø§Ø®Ù„Ù‡",
        message_en: "Cannot delete account with sub-accounts",
      });
    }

    // Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const deleteQuery = `
      DELETE FROM accounts_header 
      WHERE company_id = $1 AND id = $2
    `;
    await db.none(deleteQuery, [req.session.company_id, posted_elements.account_id]);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­",
      message_en: "Account deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting account:", error);
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
      message_en: "An error occurred while deleting the account",
    });
  }
});


// dnd / drag and drop changes
app.post("/api/update-account-parent", async (req, res) => {
  try {
    const { currentAccountId, newParentId } = req.body; // Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§

    const hasPermission = await permissions(req, "accounts_permission", "update");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
    const hasBadSymbols = sql_anti_injection([
      currentAccountId,
      newParentId
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

  



    const query = `
    SELECT
      (SELECT COUNT(*) FROM accounts_header WHERE company_id = $1 AND id = $2) as account_id,
      (SELECT COUNT(*) FROM accounts_header WHERE company_id = $1 AND id = $3) as parent_id,
      (SELECT finance_statement FROM accounts_header WHERE company_id = $1 AND id = $2) AS finance_statement
  `;

  const result = await db.oneOrNone(query, [
    req.session.company_id,
    currentAccountId,
    newParentId
  ]);





    if (result.account_id === 0 || result.parent_id === 0){
      await block_user(req,'udp01');
      return res.json({
        success: false,
        message_ar: "ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨",
        xx: true,
        message_en: "Cannot delete account with sub-accounts",
      });
    }



    const forbiddenValues = is_forbidden_adding_branches.join(','); // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…ØµÙÙˆÙÙ‡ Ø§Ù„Ù‰ Ø³Ù„Ø³Ù‡ Ù†ØµÙŠÙ‡
    
    const query0 = `select
    id
  from
    accounts_header
  where
    company_id = $1
    and id != $2
    and finance_statement = $3
    AND (is_final_account = false OR is_final_account IS NULL)
    AND global_id NOT IN (${forbiddenValues})`
  
    const result0 = await db.any(query0,[
      req.session.company_id,
      currentAccountId,
      result.finance_statement
    ])

 
    const ids_array = result0.map(row => row.id); // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù‚ÙŠÙ… Ø§Ù„Ù€ id Ù…Ù† Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…

    if (!ids_array.includes(newParentId)) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙØ© Ù…Ø¬Ù…ÙˆØ¹Ù‡ ÙØ±Ø¹ÙŠÙ‡ Ø¶Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯",
        message_en: "Cannot delete account with sub-accounts",
      });
    }




    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ø¹Ù‚Ø¯Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const updateQuery = `
          UPDATE accounts_body
          SET parent_id = $1
          WHERE account_id = $2;
      `;
    await db.query(updateQuery, [newParentId, currentAccountId]);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error updating parent:", error);
    // Ø¥Ø±Ø³Ø§Ù„ Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    res.status(500).send("Failed to update parent");
  }
});

// get all final accounts by company_id
app.post("/getAccountsData1", async (req, res) => {
  try {
    // //! Permission
    // await permissions(req, "effects_permission", "view");
    // if (!permissions) {
    //   return;
    // }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
/*
    let query1 = `
    SELECT
      A.id,
      A.account_name,
      A.account_type_id,
      COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite 
    FROM
      accounts_header A
    where
      A.company_id = $1
      AND is_final_account = true AND (global_id != 8 OR global_id IS NULL)`;
      */

      let query1 = `
SELECT
  A.id,
  A.account_name,
  A.account_type_id,
  COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
  NULL AS is_accumulated_depreciation,
  is_allow_to_buy_and_sell
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  AND (global_id != 8 OR global_id IS NULL)

UNION ALL

SELECT
  A.id,
  'Ù…Ø¬Ù…Ø¹ Ø§Ù‡Ù„Ø§Ùƒ - ' || A.account_name AS account_name,
  A.account_type_id,
  COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
  true AS is_accumulated_depreciation,
  null as is_allow_to_buy_and_sell
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  AND (global_id != 8 OR global_id IS NULL)
  AND A.account_type_id = 6;
`;
    let data = await db.any(query1, [req.session.company_id]);

    // const data = rows.map((row) => ({
    //   id: row.id,
    //   account_name: row.account_name,
    //   account_type: row.account_type_id
    // }));
    res.json(data);
  } catch (error) {
    console.error("Error while get accounts Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

//#endregion



//#region itemsLocations

  app.post("/itemsLocations_view", async (req, res) => {
    try {

            //! Permission
            await permissions(req, "itemsLocations_permission", "view");
            if (!permissions) {
              return res.status(403).json({
                success: false,
                message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
              });
            }
  
            
      let query1 = `select id, account_name
  from accounts_header
  where company_id = $1 AND account_type_id = 7 
  order by account_name ASC ;`;  // in (1,2 ) ya3ny = 1 or 2 
  
      // Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
      let data = await db.any(query1,[req.session.company_id]);
      await last_activity(req);

      res.json(data);
    } catch (error) {
      console.error("itemsLocations ERROR:", error);
      res.status(500).send("Server Error");
    }
  });

  app.post("/itemsLocations_add", async (req, res) => {
    try {
      //! Permission
      await permissions(req, "effects_permission", "add");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }
  
      const posted_elements = req.body;
  
  
  
      // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.status(400).json({
          success: false,
          message_ar: "âŒ ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£Ø­Ø±Ù ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§ ÙÙŠ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
        });
      }
  


      turn_EmptyValues_TO_null(posted_elements);

      if (!posted_elements.account_name_input_value || posted_elements.account_name_input_value === '') {
        return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†" });
      }
  
      //* Start Transaction --------------------------------------------------
  
      const query01 = `select count(account_name) as count_account_name from accounts_header where trim(account_name) = $1 and company_id = $2`;
      const result = await db.oneOrNone(query01,[posted_elements.account_name_input_value.trim(), req.session.company_id])

      if (result.count_account_name > 0){
        return res.json({
          success: false,
          message_ar: `Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ù† Ù‚Ø¨Ù„ `,
        });
      }

      

      await db.tx(async (tx) => {
      let query1 = `INSERT INTO accounts_header (account_name, account_type_id, company_id, is_final_account) VALUES ($1, $2, $3, $4) RETURNING id;`;
      let params1 = [
        posted_elements.account_name_input_value,
        7,
        req.session.company_id,
        true
      ];
  
     
        const insert = await tx.one(query1, params1);
        const newId = insert.id;
        //! history
        await history(17, 1, newId, 0, req, tx);
      });
  
      await last_activity(req);
      // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ø­ÙˆÙ„ Ù†Ø¬Ø§Ø­ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
      res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ù†Ø¬Ø§Ø­`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error adding item location:", error);
      // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ø­ÙˆÙ„ ÙØ´Ù„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  
  app.post("/itemsLocations_update", async (req, res) => {
    try {
          // // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
          // io.emit('blockUser', { userId: req.session.userId });
          
      const posted_elements = req.body;
  
      //! Permission
      await permissions(req, "itemsLocations_permission", "update");
      if (!permissions) {
        return;
      }
  
      //! sql injection check
      
      // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      if (!posted_elements.account_name_input_value || posted_elements.account_name_input_value === '' || !posted_elements.account_id_hidden_value || isNaN(posted_elements.account_id_hidden_value) ) {
        return res.json({ success: false, message_ar: "âŒ Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†" });
      }
      //* Start--------------------------------------------------------------
  


      let query0 = ` select
                      (SELECT count(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3 AND id != $2) as count_account_name_exist,
                      (select count(id) FROM accounts_header WHERE company_id = $1 AND account_type_id = 7) as count_id
      `
      let result = await db.oneOrNone(query0, [
        req.session.company_id,
        posted_elements.account_id_hidden_value,
        posted_elements.account_name_input_value,
      ]);
  
      if (result.count_id === 0) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      if (result.count_account_name_exist > 0) {
        return res.json({
          success: false,
          message_ar: "âŒ Ø§Ø³Ù… Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
        });
      }
  
      let query1 = `
    UPDATE accounts_header set account_name = $1
    WHERE id = $2 
  `;
      let params1 =  [
        posted_elements.account_name_input_value,
        posted_elements.account_id_hidden_value
      ];
  

      await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(17,2,posted_elements.account_id_hidden_value,0,req,tx);
      })

      last_activity(req)
      //4: send a response to frontend about success transaction
      res.json({
        success: true,
        message_ar: "âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      last_activity(req)
      console.error("Error updating itemsLocations:", error);
      // send a response to frontend about fail transaction
      res.status(500).json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });

  app.post("/itemsLocations_delete", async (req, res) => {
    try {
      //! Permission
      await permissions(req, "itemsLocations_permission", "delete");
      if (!permissions) {
        return;
      }
  
      const posted_elements = req.body;
      //! sql injection check
      const hasBadSymbols = sql_anti_injection([
        posted_elements.account_id_hidden_value,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      //* Start--------------------------------------------------------------
  
      if (!posted_elements.account_id_hidden_value || isNaN(posted_elements.account_id_hidden_value)) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
  
      let query0 = `
      select
      (select count(account_id) from transaction_body where account_id = $1) as count_account_id,
      (select count(id) from accounts_header where company_id = $2 AND account_type_id = 7) as count_id
  `;
  
      let result = await db.oneOrNone(query0,[
        posted_elements.account_id_hidden_value,
        req.session.company_id
      ])



      if (result.count_id === 0) {
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      if (result.count_account_id > 0) {
        return res.json({
          success: false,
          message_ar: 'ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ : ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø°Ù',
        });
      }


      let query1 = `DELETE FROM accounts_header WHERE id = $1`;
      let params1 =  [
        posted_elements.account_id_hidden_value,
      ];
  

      await db.tx(async (tx) => {
        await tx.none(query1, params1);
        await history(17,3,posted_elements.account_id_hidden_value,0,req,tx);
      })

      last_activity(req)
      return res.json({
        success: true,
        message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ù†Ø¬Ø§Ø­  : Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ùƒ Ø§Ù„Ø§Ù† Ø§Ù„Ù‰ ØµÙØ­Ù‡ Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙ‡",
      });
    } catch (error) {
      last_activity(req)
      console.error("Error get vendor data:", error);
      res.status(500).json({
        success: false,
        message_ar:
          "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ±Ø¯ : Ù‚Ø¯ ØªÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ø±ØªØ¨Ø·Ù‡ Ø¨Ø§Ù„Ù…ÙˆØ±Ø¯ ÙŠØ¬Ø¨ Ø­Ø°ÙÙ‡Ø§ Ø§ÙˆÙ„Ø§",
      });
    }
  });

  app.post("/items_transfer_main_data", async (req, res) => {
    try {
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "items_transfer_permission", "add");
      if (!permissions) {
        return;
      }
  
      const posted_elements = req.body;
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `
       --  Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select 
	ah.id,
	ah.account_name
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.account_type_id = 7
    ;
  `;
  let params1 = [req.session.company_id]
  
  
  let query2 = `
  --  Ø§Ù„Ø§ØµÙ†Ø§Ù
select 
	ah.id,
	ah.account_name,
	ah.item_unite
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.account_type_id = 5
	and ah.is_final_account is true
	and ah.is_inactive is null
;
`;
let params2 = [req.session.company_id]

  
  
  await db.tx(async (tx) => {
  
    const itemsLocationArray = await tx.any(query1, params1);
    const itemsArray = await tx.any(query2, params2);
  
    
    const postedData = {itemsLocationArray, itemsArray};
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get Employees Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false,message_ar: error.message || deafultErrorMessage,});
    }
  });

  app.post("/api/items_transfer_add", async (req, res) => {
    try {
  
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "items_transfer_permission", "add");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }
  
  
  
  
      const posted_elements = req.body;
      const transaction_type = 12 //   ØªØ­ÙˆÙŠÙ„Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
      
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.rowAccountId + obj.rowNote +obj.rowAmount), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.datex,
        posted_elements.location_from,
        posted_elements.location_to,
        posted_elements.note,
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'add',
        tableName: false, // if type = 'update' or 'delete' only
        transaction_id: false, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      
  
      //* Start Transaction --------------------------------------------------
  
      if (!posted_elements.location_from || !posted_elements.location_to){
        return res.json({
          success: false,
          message_ar: 'Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
        });
      }
  
  
      const items_array = posted_elements.posted_array.map(row => parseInt(row.rowAccountId)); // Ø³ØªØ¸Ù‡Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©: [15, 54, 51]
      const locations_array = [+posted_elements.location_from]
      

    
        // ÙØ­Øµ Ø§Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„ÙØ±ÙˆÙ†Øª Ø§Ù†Ø¯ Ø§ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ù„Ø§Ø­Ø¯ Ø§Ù„Ø§ØµÙˆÙ„ ÙÙ‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        const year = getYear(posted_elements.datex)
        const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header',transaction_type, year, req);
        const newId_general_reference = await newId_fn("transaction_header", 'general_reference');
  
        let insert_array2 = []
        let index = 1
        await db.tx(async (tx) => {

          let query1 = `INSERT INTO transaction_header
          (reference, company_id, transaction_type, general_note, datex, general_reference, items_location_id, items_location_id2, is_including_items)
          VALUES($1, $2, $3, $4, $5, $6, $7 , $8, $9) RETURNING id;`;

let params1 = [
newReference_transaction_header,
req.session.company_id,
transaction_type,
posted_elements.note,
posted_elements.datex,
newId_general_reference,
+posted_elements.location_from,
+posted_elements.location_to,
true,
]   

  
const insert = await tx.one(query1, params1);
const newId_transaction_header = insert.id;


        for ( const row of posted_elements.posted_array){

          // Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­ÙˆÙ„ Ù…Ù†Ù‡
          insert_array2.push([
            newId_transaction_header, // transaction_header_id
            +row.rowAccountId, // item_id
            +posted_elements.location_from, //Ø§Ù„Ù…ÙˆÙ‚
            +row.rowAmount * -1, // Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø³Ø§Ù„Ø¨
          ]);
  
  
          // Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­ÙˆÙ„ Ø§Ù„ÙŠÙ‡
          insert_array2.push([
            newId_transaction_header, // transaction_header_id
            +row.rowAccountId, // item_id
            +posted_elements.location_to, //Ø§Ù„Ù…ÙˆÙ‚
            +row.rowAmount, // Ø§Ù„ÙƒÙ…ÙŠØ© 
          ]);
    
          index++;
        }
  
        if (insert_array2.length > 0){
          let columnsCount = insert_array2[0].length;
          let query2 = `INSERT INTO transaction_body
          (transaction_header_id, item_id, item_location_id_tb, item_amount)
          VALUES ${insert_array2.map((_, i) => 
          `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
          ).join(', ')}`;
        await tx.none(query2, insert_array2.flat());
        }
  
        const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
        if (!allow_amounts){
          throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
        } else if (allow_amounts !== true) {
          throw new Error(allow_amounts);
        }
        //! history
        await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
      });
  
      // await update_items_cogs(req,items_array,posted_elements.datex)
      const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error items_transfer_add:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  

  app.post("/get_items_transfer_Data_view", async (req, res) => {
    try {
      
      //! Permission  
      await permissions(req, "items_transfer_permission", "view");
      if (!permissions) {
        return;
      }
        
  
      const posted_elements = req.body;
  
          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }
        
            const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
            if (InValidDateFormat){
              return res.json({
                success: false,
                message_ar: InValidDateFormat_message_ar,
              });
            }
          
  
  
        turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
  
  
  let quer1 = `
  select
	th.id,
	th.datex,
	    CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    COALESCE(th.general_note, '') as general_note, 
    ah1.account_name as location_from,
    ah2.account_name as location_to
from
	transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type  
inner join accounts_header ah1 on ah1.id = th.items_location_id
inner join accounts_header ah2 on ah2.id = th.items_location_id2
where
    th.company_id = $1
    AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
    AND th.transaction_type = 12
    AND th.is_deleted is null
  order by
    th.datex DESC,
    th.reference DESC	
  `;
  
  // ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
  let data = await db.any(quer1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date]);
  
      res.json(data);
    } catch (error) {
      console.error("Error get_items_transfer_Data_view:", error);
      res.status(500).send("Error:");
    }
  });
  

  app.post("/get_items_transfer_data_for_update", async (req, res) => {
    try {
      // //! Permission
      await permissions(req, "items_transfer", "add");
      if (!permissions) {
        return;
      }
  
      const posted_elements = req.body;
  
  
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
          
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      // const InValidDateFormat = isInValidDateFormat([posted_elements.startDate, posted_elements.endDate]);
      // if (InValidDateFormat) {
      //   return res.status(400).json({
      //     success: false,
      //     message_ar: InValidDateFormat_message_ar,
      //   });
      // }
  
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      
  
      let query1 = `
       --  Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select 
	ah.id,
	ah.account_name
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.account_type_id = 7
  and ah.is_inactive is null
    ;
  `;
  let params1 = [req.session.company_id]
  
  
  let query2 = `
  --  Ø§Ù„Ø§ØµÙ†Ø§Ù
select 
	ah.id,
	ah.account_name,
	ah.item_unite
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.account_type_id = 5
	and ah.is_final_account is true
	and ah.is_inactive is null
;
`;
let params2 = [req.session.company_id]
  

  let query3 = `
  --  header data query
select
	th.id,
	th.datex,
	COALESCE(th.general_note, '') as general_note,
	th.items_location_id as location_from,
	th.items_location_id2 as location_to,
	CONCAT(
      tt.doc_prefix, '-',
    	SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat
from
	transaction_header th
 LEFT JOIN transaction_type tt ON tt.id = th.transaction_type 
where
	th.company_id = $1
	and th.id = $2
	and th.is_deleted is null
	and th.transaction_type = 12
  ;
  `;
  let params3 = [req.session.company_id, posted_elements.x]
  

  let query4 = `
  -- body data
select
	tb.id,
	COALESCE(tb.row_note, ''), row_note, 
	tb.item_id,
	ah1.account_name as item_name,
  ah1.item_unite,
  tb.item_amount
from
	transaction_body tb
inner join transaction_header th on th.id = tb.transaction_header_id	
inner join accounts_header ah1 on ah1.id = tb.item_id
where
	th.id = $1
	and th.company_id = $2
	and th.transaction_type = 12
	and th.is_deleted is null
  and tb.item_amount > 0
	`
  let params4 = [posted_elements.x,req.session.company_id]
  await db.tx(async (tx) => {
  
    const itemsLocationsArray = await tx.any(query1, params1);
    const itemsArray = await tx.any(query2, params2);
    const haderDataArray = await tx.oneOrNone(query3, params3);
    const bodyDataArray = await tx.any(query4, params4);
  
    const postedData = {itemsLocationsArray, itemsArray, haderDataArray, bodyDataArray};
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get_calculated_depreacation_values", error);
      res.join;
      res
        .status(500)
        .json({ success: false, message_ar: error.message || deafultErrorMessage,});
    }
  });

  app.post("/api/items_transfer_update", async (req, res) => {
    try {
  
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "items_transfer_permission", "update");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }
  
  
  
  
      const posted_elements = req.body;
      const transaction_type = 12 //   ØªØ­ÙˆÙŠÙ„Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
      
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.rowAccountId + obj.rowNote +obj.rowAmount), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.x,
        posted_elements.datex,
        posted_elements.location_from,
        posted_elements.location_to,
        posted_elements.note,
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'update',
        tableName: 'transaction_header', // if type = 'update' or 'delete' only
        transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      
  
      //* Start Transaction --------------------------------------------------
  
      let query0 = `select id, reference from transaction_header where id = $1 and company_id = $2 and transaction_type = 12`
      let result0 = await db.oneOrNone(query0, [posted_elements.x, req.session.company_id])
      if (!result0) {
        await block_user(req,'Situ01');
        return res.json({
          success: false,
          message_ar: "âŒ ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨",
          xx: true,
          message_en: "Cannot delete account with sub-accounts",
        });
      }



      if (!posted_elements.location_from || !posted_elements.location_to){
        return res.json({
          success: false,
          message_ar: 'Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
        });
      }
  
  
      const items_array = posted_elements.posted_array.map(row => parseInt(row.rowAccountId)); // Ø³ØªØ¸Ù‡Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©: [15, 54, 51]
      const locations_array = [+posted_elements.location_from];
    
        // ÙØ­Øµ Ø§Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„ÙØ±ÙˆÙ†Øª Ø§Ù†Ø¯ Ø§ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ù„Ø§Ø­Ø¯ Ø§Ù„Ø§ØµÙˆÙ„ ÙÙ‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        const year = getYear(posted_elements.datex)

        let insert_array2 = []
        let index = 1

        
        for ( const row of posted_elements.posted_array){

          // Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­ÙˆÙ„ Ù…Ù†Ù‡
          insert_array2.push([
            posted_elements.x, // transaction_header_id
            +row.rowAccountId, // item_id
            +posted_elements.location_from, //Ø§Ù„Ù…ÙˆÙ‚
            +row.rowAmount * -1, // Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ø§Ù„Ø³Ø§Ù„Ø¨
          ]);
  
  
          // Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­ÙˆÙ„ Ø§Ù„ÙŠÙ‡
          insert_array2.push([
            posted_elements.x, // transaction_header_id
            +row.rowAccountId, // item_id
            +posted_elements.location_to, //Ø§Ù„Ù…ÙˆÙ‚
            +row.rowAmount, // Ø§Ù„ÙƒÙ…ÙŠØ© 
          ]);
    
          index++;
        }
  
        await db.tx(async (tx) => {

          let query1 = `UPDATE transaction_header
          set general_note = $1, datex = $2, items_location_id = $3, items_location_id2 = $4 
            WHERE id = $5 AND company_id = $6 AND transaction_type = 12
          ;`;

let params1 = [
posted_elements.note,
posted_elements.datex,
+posted_elements.location_from,
+posted_elements.location_to,
posted_elements.x,
req.session.company_id
]                    

await tx.none(query1, params1); // update

let query02 = 'DELETE FROM transaction_body where transaction_header_id = $1'
let params02 = [posted_elements.x]

await tx.none(query02, params02); // delete



if (insert_array2.length > 0){
  let columnsCount = insert_array2[0].length;
  let query2 = `INSERT INTO transaction_body
  (transaction_header_id, item_id, item_location_id_tb, item_amount)
  VALUES ${insert_array2.map((_, i) => 
  `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;
await tx.none(query2, insert_array2.flat());
}
  
const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
if (!allow_amounts){
  throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
} else if (allow_amounts !== true) {
  throw new Error(allow_amounts);
}
        //! history
        await history(transaction_type,2,posted_elements.x,result0.reference,req,tx);
      });
  
      // await update_items_cogs(req,items_array,posted_elements.datex)
      const new_referenceFormatting = formatFromFiveDigits(result0.reference);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error items_transfer_update:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  
  app.post("/api/items_transfer_delete", async (req, res) => {

    try {
  
      //! Permission
      await permissions(req, "items_transfer_permission", "delete");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }
      const posted_elements = req.body;
  
      const transaction_type = 12 // ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
    
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex])
        if (InValidDateFormat){
          return res.json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
      
  
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: false, // if // if type = 'update' or 'add' only
        type: 'delete',
        tableName: 'transaction_header', // if type = 'update' or 'delete' only
        transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
      
  
      turn_EmptyValues_TO_null(posted_elements);
  
      //* Start Transaction --------------------------------------------------
  
      let reference;
      await db.tx(async (tx) => {
              //! Security hacking check id for company_name and transactio type
              let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
              let rows01 = await tx.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
          
              if (!rows01 || !rows01.id) {
                throw new Error("Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØ­ÙˆÙŠÙ„ Ù…Ø®Ø²ÙˆÙ†  Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹");
              }
              reference = rows01.reference
            
                    //? Clear transaction_body
        let query0 = `Delete FROM transaction_body WHERE transaction_header_id = $1`
        await tx.none(query0,[posted_elements.x])
  
        //? update transaction_header
        let query1 = `update transaction_header set 
                        is_deleted = true
                      WHERE
                        id = $1;`;
  
        await tx.none(query1, [
          posted_elements.x
        ]);
  
        //! history
        await history(transaction_type,3,posted_elements.x,reference,req,tx);
      })
  
  
      const new_referenceFormatting = formatFromFiveDigits(reference);
      const year = getYear(posted_elements.datex)
  
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø­Ø°Ù ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†  Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error items_transfer_delete:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#region items

 //#region 1 : view items - tree
 app.get("/api/tree/items", async (req, res) => {
  try {

    // ØªØ­Ø¯ÙŠØ¯ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø§Ù„Ø­Ø§Ù„Ù‰ Ù„Ù„Ø´Ø±ÙƒÙ‡ Ù„ÙƒÙ‰ ÙŠØªÙ… Ø§Ø³ØªØ«Ù†Ø§Ø¡Ù‡ ÙÙ‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„ØªØ§Ù„Ù‰
    let query = `SELECT id FROM accounts_header WHERE global_id = 12 AND company_id = $1`;
    let result = await db.one(query, [req.session.company_id]);

    let stock_id = parseInt(result.id);


    //! fe el est3lam da han5aly el parent_id eta3 7esap el stock = null >> lazem 3ashan el tree teshta8al 
    let query1 = `
     SELECT h1.id AS account_id,
    h1.account_name AS account_name,
    h1.is_final_account AS is_final_account,
    h1.account_no AS account_no,
    h1.finance_statement AS finance_statement,
    h1.cashflow_statement AS cashflow_statement,
    h1.global_id AS global_id,
    h1.item_revenue_account AS item_revenue_account,
    h1.item_expense_account AS item_expense_account,
    h1.item_sales_price AS item_sales_price,
    h1.item_purshas_price AS item_purshas_price,
    h1.item_amount_reorder_point AS item_amount_reorder_point,
    COALESCE(h1.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
      CASE
        WHEN h1.id = $2 THEN NULL
        ELSE h2.id
      END AS parent_id,
    h2.account_name AS parent_name
FROM accounts_header h1
LEFT JOIN accounts_body b ON h1.id = b.account_id
LEFT JOIN accounts_header h2 ON b.parent_id = h2.id
WHERE h1.company_id = $1
    AND h1.account_type_id = 5
ORDER BY h1.id asc;`;  // in (1,2 ) ya3ny = 1 or 2 

    // Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
    let treeData = await db.any(query1, [req.session.company_id,stock_id]);
    
    res.json(treeData);
  } catch (error) {
    console.error("Error fetching tree data:", error);
    res.status(500).send("Server Error");
  }
});
 //#endregion

//#region 2 : get revenue_account
app.post("/api/get_revenue_accounts", async (req, res) => {
  try {

    let query1 = `select id, account_name, global_id
from accounts_header
where company_id = $1 AND main_account_id = 4 AND is_final_account = true
order by account_name ASC ;`;  // in (1,2 ) ya3ny = 1 or 2 

    // Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
    let data = await db.any(query1,[req.session.company_id]);
    
    res.json(data);
  } catch (error) {
    console.error("api/get_revenue_accounts:", error);
    res.status(500).send("Server Error");
  }
});
//#endregion

  //#region 2: add item group
  app.post("/api/addGroup-item", async (req, res) => {
    try {
      const posted_elements = req.body;
  
      // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© (Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù‚Ø¯ ÙØ±Ø¹ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹)
  
      // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
      const hasPermission = await permissions(req,"items_permission", "add");
      if (!hasPermission) {
        return res.json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø§Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©",
          message_en: "You do not have the necessary permissions to delete this account",
        });
      }
  
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
      const hasBadSymbols = sql_anti_injection([
        posted_elements.accountname,
        posted_elements.accountParent,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
      //* Start--------------------------------------------------------------

      if (!posted_elements.accountname || !posted_elements.accountParent || isNaN(+posted_elements.accountParent)) {
        return res.json({
          success: false,
          message_ar: "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­",
        })
      }

      let result = [];
      const query = `
        SELECT
          (SELECT COUNT(id) FROM accounts_header WHERE company_id = $1 AND id = $2) as parent_exist,
          (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $2) AS is_final_account,
          (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3) AS count_account_name
      `;
      
      result = await db.oneOrNone(query, [
        req.session.company_id,
        posted_elements.accountParent,
        posted_elements.accountname,
      ]);
      

      if (parseInt(result.parent_exist) === 0) {
        await block_user(req,'adai0')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      if (result.is_final_account) {
        await block_user(req,'adai1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
  
  

      
      if (result.count_account_name > 0) {
        return res.json({
          success: false,
          message_ar: "âŒ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
          message_en: "Account with this name already exists",
        });
      }
      
      // Additional logic here if needed
      await db.tx(async (tx) => {    
     
      const query1 = `INSERT INTO accounts_header (account_name, is_final_account, account_type_id,company_id)
                            values ($1,$2,$3,$4) RETURNING id;`;
      const query1_parameters = [posted_elements.accountname,null,5,req.session.company_id]
  
      const insert = await tx.one(query1,query1_parameters);
      let new_account_header_id = insert.id;

  
      const query2 =`INSERT INTO accounts_body (parent_id,account_id)
                                        values($1,$2);`;
      const query2_parameters = [posted_elements.accountParent,new_account_header_id];
  
   
       
        await tx.none(query2,query2_parameters);
  
      })
      // Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  
      // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
      return res.json({
        success: true,
        message_ar: "âœ… ØªÙ… Ø§Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø¨Ù†Ø¬Ø§Ø­",
        message_en: "",
      });
    } catch (error) {
      console.error("Error addGroup-account:", error);
      // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
        message_en: "An error occurred while deleting the account",
      });
    }
  });
  
  //#endregion

//#region add new item
app.post("/api/add_item", async (req, res) => {
  

  try {
    const posted_elements = req.body;

    
    const hasPermission = await permissions(req, "items_permission", "add");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø§Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }


          turn_EmptyValues_TO_null(posted_elements);

    //#region validation

          if(!posted_elements.account_name || !posted_elements.account_parent_name_id || isNaN(+posted_elements.account_parent_name_id)){
            return res.json({
              success: false,
              message_ar: "âŒ  Ø±Ø¬Ø§Ø¡ ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙ‰ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·ÙˆØ¨Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­",
            });
          }


    let result = [];
    const query = `
      SELECT
        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $2) AS is_final_account,
        (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3) AS count_account_parent,
        (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3) AS count_account_name,
        (SELECT id FROM accounts_header WHERE company_id = $1 AND global_id = 17) AS cost_account_id
    `;

    result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.account_parent_name_id,
      posted_elements.account_name,
    ]);
    

    if (result.is_final_account) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙØ© Ù…Ø¬Ù…ÙˆØ¹Ù‡ ÙØ±Ø¹ÙŠØ© Ø¶Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡",
      });
    }


    
    if (result.count_account_parent === 0) {
      await block_user(req,'aai1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    if (result.count_account_name > 0) {
      return res.json({
        success: false,
        message_ar: "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
        message_en: "Account with this name already exists",
      });
    }

    //#endregion end- validation

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {

    

      // Ø£Ø¯Ø®Ù„ into accounts_header
      let query1 = `INSERT INTO accounts_header (account_name, account_no, is_final_account, account_type_id, item_revenue_account, item_expense_account, item_sales_price, item_purshas_price, item_amount_reorder_point, item_unite, company_id)
                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id;`;
      const insert = await tx.one(query1, [
        posted_elements.account_name,
        posted_elements.account_no,
        true,
        5,
        posted_elements.revenue_account_select_value,
        result.cost_account_id,
        posted_elements.sales_price,
        posted_elements.purchase_price,
        posted_elements.reorder_point,
        posted_elements.item_unite_input,
        req.session.company_id
      ]);

      let new_account_id = insert.id;

      // Ø£Ø¯Ø®Ù„ into accounts_body
      let query2 = `INSERT INTO accounts_body (parent_id, account_id)
                        VALUES ($1, $2)`;
      await tx.none(query2, [
        posted_elements.account_parent_name_id,
        new_account_id,
      ]);
    });

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙ†Ù Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error add_item:", error);
    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙØ´Ù„Øª
      message_ar: error.message || deafultErrorMessage,
    });
  }
});



app.post("/api/add_imported_items", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "items_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
 
    if (posted_elements.posted_array.length > 301) {
      throw new Error(`âš ï¸ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‡Ùˆ 300 ØµÙ. ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù„Ù‰ Ø¯ÙØ¹Ø§Øª Ø£ØµØºØ±.`);
    }

    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }

    //! sql injection check - ÙØ­Øµ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ posted_array
    let hasBadSymbols = posted_elements.posted_array.some(row =>
      row.some(cell => sql_anti_injection([cell]))
    );
    
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }
    


    turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }

    
    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit
    
    const db_AllAccounts = await db.any(
      `select id, account_name, is_final_account, account_type_id, main_account_id from accounts_header where company_id = $1`,
      [req.session.company_id]
    );
    const db_items_parent_array = db_AllAccounts.filter(
      (row) => row.is_final_account === null && +row.account_type_id === 5
    );
    
    const company_id = req.session.company_id;
    const account_type_id = 5;
    
    // Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªØ®Ø²ÙŠÙ† Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£ØµÙ†Ø§Ù Ø§Ù„Ù„ÙŠ Ø¨ØªØªØ­Ù‚Ù‚ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù„ÙˆØ¨
    const itemNamesSet = new Set();
    
    let array1 = [];
    let validRows = []; // Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù„ÙŠ Ø¯Ø®Ù„Øª ÙØ¹Ù„ÙŠÙ‹Ø§
    let index = 1;
    
    for (const row of posted_elements.posted_array) {
      let is_final_account = row[0];
      let account_no = row[1] || null;
      let item_name = row[2] || null;
      let item_unite = row[3] || null;
      let item_parent = row[4] || null;
      let item_revenue_account = row[5] || null;
      let item_sales_price = row[6] || null;
      let item_purshase_price = row[7] || null;
      let item_reorder_point = row[8] || null;
    
      if (!item_name || !item_parent) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
      if (account_no === 'Ù…Ø¹Ø±Ù Ø§Ù„ØµÙ†Ù ( Ø§Ø®ØªÙŠØ§Ø±Ù‰ )' || item_name === 'Ø§Ø³Ù… Ø§Ù„ØµÙ†Ù ( Ù…Ø·Ù„ÙˆØ¨ )' || item_unite === 'ÙˆØ­Ø¯Ø© Ø§Ù„Ù‚ÙŠØ§Ø³ ( Ù…Ø·Ù„ÙˆØ¨ )') {
        console.log(`skip header row`);
        //index++;
        continue;
      }
    
      if (is_final_account !== "ØµÙ†Ù" && is_final_account !== "Ù…Ø¬Ù…ÙˆØ¹Ø©") {
        throw new Error(`âŒ ØµÙ†Ù/Ù…Ø¬Ù…ÙˆØ¹Ø© ØºÙŠØ± ØµØ§Ù„Ø­ ÙÙ‰ Ø§Ù„ØµÙ†Ù ${item_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
      const isNameExists = db_AllAccounts.some((account) => account.account_name.trim() === item_name);
      if (isNameExists) {
        throw new Error(`âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³Ù… Ø§Ù„ØµÙ†Ù '${item_name}' Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
    
      if (itemNamesSet.has(item_name)) {
        throw new Error(`âŒ Ø§Ù„ØµÙ†Ù '${item_name}' Ù…ÙƒØ±Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
      itemNamesSet.add(item_name);
    
      if (item_sales_price !== null && (item_sales_price === "" || isNaN(+item_sales_price))) {
        throw new Error(`âŒ Ø³Ø¹Ø± Ø§Ù„Ø¨ÙŠØ¹ ØºÙŠØ± ØµØ§Ù„Ø­ ÙÙ‰ Ø§Ù„ØµÙ†Ù ${item_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
      if (item_purshase_price !== null && (item_purshase_price === "" || isNaN(+item_purshase_price))) {
        throw new Error(`âŒ Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ ØºÙŠØ± ØµØ§Ù„Ø­ ÙÙ‰ Ø§Ù„ØµÙ†Ù ${item_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
      if (item_reorder_point !== null && (item_reorder_point === "" || isNaN(+item_reorder_point))) {
        throw new Error(`âŒ Ù†Ù‚Ø·Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·Ù„Ø¨ ØºÙŠØ± ØµØ§Ù„Ø­ ÙÙ‰ Ø§Ù„ØµÙ†Ù ${item_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
      const parentObject = db_items_parent_array.find((parent) => parent.account_name.trim() === item_parent && !parent.is_final_account && !parent.is_deleted);
      if (!parentObject) {
        throw new Error(`âŒ Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© '${item_parent}' ØºÙŠØ± ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
      item_parent = parentObject.id;
    
      if (is_final_account === "Ù…Ø¬Ù…ÙˆØ¹Ø©") {
        is_final_account = null;
        item_unite = null;
        item_revenue_account = null;
        item_sales_price = null;
        item_purshase_price = null;
        item_reorder_point = null;
      } else if (is_final_account === "ØµÙ†Ù") {
        is_final_account = true;
        if (!item_unite){ throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙˆØ­Ø¯Ø© Ù‚ÙŠØ§Ø³ Ø§Ù„ØµÙ†Ù ${item_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);}
     
        const revenueAccount = db_AllAccounts.find((acc) => acc.account_name.trim() === item_revenue_account && +acc.main_account_id === 4 && acc.is_final_account && !acc.is_deleted);
        
        if (!item_revenue_account || !revenueAccount) {
          throw new Error(`âŒ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø®Ù„ Ù„Ù„ØµÙ†Ù '${item_name}' ØºÙŠØ± ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
        }
        item_revenue_account = revenueAccount.id

      }else{
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ØµÙ†Ù†Ù/Ù…Ø¬Ù…ÙˆØ¹Ø© ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`)
      }
      
    
      array1.push([
        account_no,
        item_name,
        item_unite,
        is_final_account,
        item_revenue_account,
        item_sales_price,
        item_purshase_price,
        item_reorder_point,
        account_type_id,
        company_id,
      ]);
    
      validRows.push(row); // ØªØ®Ø²ÙŠÙ† Ø§Ù„ØµÙ Ø§Ù„ØµØ§Ù„Ø­ ÙÙ‚Ø·
    
      index++;
    }
    
    



// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {

// Ø¥Ø¯Ø®Ø§Ù„ accounts_header
let columnsCount = array1[0].length;
let query1 = `INSERT INTO accounts_header
  (account_no, account_name, item_unite, is_final_account, item_revenue_account, item_sales_price, item_purshas_price, item_amount_reorder_point, account_type_id, company_id)
  VALUES ${array1.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}
  RETURNING id;`;

const insertedIds = await tx.many(query1, array1.flat());

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª accounts_body
let array2 = insertedIds.map((inserted, i) => [
  db_items_parent_array.find(parent => parent.account_name === validRows[i][4]).id,
  inserted.id
]);

let query2 = `INSERT INTO accounts_body (parent_id, account_id)
              VALUES ${array2.map((_, i) =>
                `($${i * 2 + 1}, $${i * 2 + 2})`
              ).join(', ')}`;

await tx.none(query2, array2.flat());


 // await history(transaction_type, 1, newId_transaction_header, newReference_transaction_header, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
   // const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ù‰ Ø¨Ù†Ø¬Ø§Ø­ `,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error add_imported_items:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region update Group
app.post("/api/update-group_items", async (req, res) => {
  

  try {
    const posted_elements = req.body;
    
    const hasPermission = await permissions(req, "items_permission", "update");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }


    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL

      const hasBadSymbols = sql_anti_injection([
        posted_elements.account_id,
        posted_elements.account_name,
        posted_elements.parent_id,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }

      turn_EmptyValues_TO_null(posted_elements);



    let result = [];
    const query = `
      SELECT

        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $4) AS is_final_account_item,
        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $2) AS is_final_account_parent,
        (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3 AND id != $4) AS count_account_name
    `;

    result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.parent_id,
      posted_elements.account_name,
      posted_elements.account_id,
    ]);
    


      if (result.is_final_account_item || result.is_final_account_parent) {
        await block_user(req,'uda1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


    
    if (result.count_account_name > 0) {
      return res.json({
        success: false,
        message_ar: "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
        message_en: "Account with this name already exists",
      });
    }

    let query1;
    let query1_parameters;
    let query2;
    let query2_parameters;


      query1 = `UPDATE accounts_header SET 
      account_name = $1
      WHERE company_id = $2 AND id = $3`;
      query1_parameters = [
        posted_elements.account_name,
        req.session.company_id,
        posted_elements.account_id,
      ]

      query2 = `UPDATE accounts_body SET 
      parent_id = $1
      WHERE account_id = $2`;
      query2_parameters = [
        posted_elements.parent_id,
        posted_elements.account_id
      ]


 

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {
      await tx.none(query1, query1_parameters);
      await tx.none(query2, query2_parameters)
    });

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding account:", error);
    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙØ´Ù„Øª
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//#endregion

//#region drag and drop

app.post("/api/items_tree_drag_and_drop", async (req, res) => {
  try {
 
    // const { currentAccountId, newParentId } = req.body;
    const posted_elements = req.body;

    const hasPermission = await permissions(req, "items_permission", "update");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„ØµÙ†Ù",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }


  
    turn_EmptyValues_TO_null(posted_elements);



    const query = `
    SELECT
      (SELECT COUNT(id) FROM accounts_header WHERE company_id = $1 AND id = $2) as account_id,
      (SELECT COUNT(id) FROM accounts_header WHERE company_id = $1 AND id = $3) as parent_id,
      (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $3) as is_parent_group
  `;

  const result = await db.oneOrNone(query, [
    req.session.company_id,
    posted_elements.currentAccountId,
    posted_elements.newParentId
  ]);


    if (result.account_id === 0 || result.parent_id === 0){
      await block_user(req,'udp01');
      return res.json({
        success: false,
        message_ar: "ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨",
        xx: true,
        message_en: "Cannot delete account with sub-accounts",
      });
    }


    
    if (result.is_parent_group) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙÙ‡ Ø§Ù„ØµÙ†Ù Ø§Ù„Ø­Ø§Ù„Ù‰ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø§Ù„Ù…Ø­Ø¯Ø¯",
        message_en: "Cannot delete account with sub-accounts",
      });
    }


  //   const forbiddenValues = is_forbidden_adding_branches.join(','); // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…ØµÙÙˆÙÙ‡ Ø§Ù„Ù‰ Ø³Ù„Ø³Ù‡ Ù†ØµÙŠÙ‡

    
  //   const query0 = `select
  //   id
  // from
  //   accounts_header
  // where
  //   company_id = $1
  //   and id != $2
  //   and finance_statement = $3
  //   AND (is_final_account = false OR is_final_account IS NULL)
  //   AND global_id NOT IN (${forbiddenValues})`
  
  //   const result0 = await db.any(query0,[
  //     req.session.company_id,
  //     currentAccountId,
  //     result.finance_statement
  //   ])

 
  //   const ids_array = result0.map(row => row.id); // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù‚ÙŠÙ… Ø§Ù„Ù€ id Ù…Ù† Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…

  //   if (!ids_array.includes(newParentId)) {
  //     return res.json({
  //       success: false,
  //       message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø¶Ø§ÙØ© Ù…Ø¬Ù…ÙˆØ¹Ù‡ ÙØ±Ø¹ÙŠÙ‡ Ø¶Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯",
  //       message_en: "Cannot delete account with sub-accounts",
  //     });
  //   }




    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ø¹Ù‚Ø¯Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const updateQuery = `
          UPDATE accounts_body
          SET parent_id = $1
          WHERE account_id = $2;
      `;
    await db.query(updateQuery, [posted_elements.newParentId, posted_elements.currentAccountId]);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error updating parent:", error);
    // Ø¥Ø±Ø³Ø§Ù„ Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    res.status(500).send("Failed to update parent");
  }
});
//#endregion
//#endregion end tree
app.post("/get_All_items_Data_for_table", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "items_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.end_date])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


  turn_EmptyValues_TO_null(posted_elements);
//* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
  WITH 
balance_query AS (
    SELECT 
        ah.id,
        COALESCE(
            SUM(
				COALESCE(tb.item_amount, 0)
            ), 0
        ) AS balance,
        COALESCE(SUM(
    		CASE 
        		WHEN tb.item_amount < 0 THEN -tb.cogs-- ØªØ®ÙÙŠØ¶ ÙÙŠ Ø§Ù„ØªÙƒÙ„ÙØ©
        		ELSE tb.cogs -- Ø²ÙŠØ§Ø¯Ø© ÙÙŠ Ø§Ù„ØªÙƒÙ„ÙØ©
    		END
		), 0) AS value
    FROM 
        accounts_header ah
    LEFT JOIN transaction_body tb ON ah.id = tb.item_id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        AND ah.account_type_id = 5
        AND ah.is_final_account = true
        AND th.is_deleted IS null
        AND th.is_including_items is TRUE
        AND th.datex <= $2
    GROUP BY
        ah.id
),
 main_query as (    
SELECT
    ah.id,
    ah.account_no,
    ah.account_name,
    ah.item_unite,
    ab.parent_id,
    parent_ah.account_name AS parent_account_name,
    COALESCE(bq.balance, 0) AS current_amount,
	COALESCE(bq.value, 0) AS value
FROM
    accounts_header ah
    LEFT JOIN accounts_body ab ON ab.account_id = ah.id
    LEFT JOIN accounts_header parent_ah ON ab.parent_id = parent_ah.id
	LEFT JOIN balance_query bq ON ah.id = bq.id 
WHERE
    ah.company_id = $1
    and ah.is_final_account = true
    and ah.account_type_id = 5
)
  SELECT *
FROM 
    main_query mq
ORDER BY 
    CASE 
        WHEN mq.current_amount = 0 THEN 1  -- Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© ØªØ°Ù‡Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
        ELSE 0                      -- Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£Ø¹Ù„Ù‰
    END, 
    mq.current_amount DESC  -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
    ;
`;
    let data = await db.any(query1, [req.session.company_id, posted_elements.end_date]); // Ù…Ø¹Ù„Ù‚ -- Ù‡Ù†Ø§ Ø§Ù„Ù…ÙØ±ÙˆØ¶ ÙƒØ§Ù† Ø§Ù„ÙƒÙˆØ¯ Ù„Ø­Ø¯ ØªØ§Ø±ÙŠØ® Ø§Ù„ÙŠÙˆÙ… Ø®Ù„Ù‰ Ø¨Ø§Ù„Ùƒ ÙƒÙ…Ø§Ù† ÙÙ‰ Ø´Ø±Ø· Ù…Ø¹Ù„Ù‚ ÙÙ‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…
   

    res.json(data);
  } catch (error) {
    console.error("Error get_All_bread_Data:", error);
    res.status(500).send("Error:");
  }
});


app.post("/getItemsGroupDataForItemsTableView", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "items_permission", "view");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
    select
	ah.id,
	ah.account_name 
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.is_final_account is not true
	and ah.account_type_id = 5
	and ah.is_inactive is not TRUE
    `;
    
    let data = await db.any(query1, [req.session.company_id]);

    res.json(data);
  } catch (error) {
    console.error("Error while get accounts Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});


app.post("/getRevenueAccountsDataForItemsTableView", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "items_permission", "view");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
    select
	ah.id,
	ah.account_name,
  ah.global_id
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.is_final_account is true
	and ah.account_type_id = 1
	and ah.main_account_id = 4
	and ah.is_inactive is not TRUE
    `;
    
    let data = await db.any(query1, [req.session.company_id]);

    res.json(data);
  } catch (error) {
    console.error("Error while get accounts Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});


app.post("/get_data_for_items_table_view_btn", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "items_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let q0 = `
    SELECT COUNT(id) AS count_id 
    FROM accounts_header 
    WHERE id = $1 
      AND company_id = $2 
      AND is_final_account IS TRUE 
      AND account_type_id = 5  
  `;
  
  let result = await db.oneOrNone(q0, [posted_elements.x, req.session.company_id]);
  
  if (!result || parseInt(result.count_id) === 0) {  // ØªØ­ÙˆÙŠÙ„ count_id Ø¥Ù„Ù‰ Ø±Ù‚Ù… Ù‚Ø¨Ù„ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
    await block_user(req, 'Sgdftvb01');
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }
  



    let query1 = `
     -- Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨
SELECT
    ah.id,
    ah.account_name,
    COALESCE(ah.account_no, '') AS account_no,
    ah.item_unite,
    ah.item_sales_price,
    ah.item_purshas_price,
    ah.item_amount_reorder_point,
    ah.item_expense_account,
    ah.item_revenue_account,
    ab.parent_id,
    ah2.account_name AS parent_name
FROM
    accounts_header ah
LEFT JOIN accounts_body ab ON ab.account_id = ah.id
LEFT JOIN accounts_header ah2 ON ab.parent_id = ah2.id -- Ø±Ø¨Ø· Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨
WHERE
    ah.id = $1
    AND ah.company_id = $2
	and ah.account_type_id = $3
	and ah.is_final_account is true
  ;
`;
let params1 = [posted_elements.x, req.session.company_id, 5]





let query2 = `
SELECT
    ah.id,
    ah.account_name
FROM
    accounts_header ah
WHERE
     ah.company_id = $1
	and ah.account_type_id = 1
	and ah.main_account_id = 4
	and ah.is_final_account is true
  and ah.is_inactive is null
ORDER BY
  ah.id ASC  
  ;
`
let params2 = [req.session.company_id]



let query3 = `
select
  ah.id,
  ah.account_name
FROM
    accounts_header ah
WHERE
     ah.company_id = $1
	and ah.account_type_id = 5
	and ah.is_final_account is null
	and ah.is_inactive is null
ORDER BY  
  ah.id ASC  
 ;
`
let params3 = [req.session.company_id]





await db.tx(async (tx) => {

  const item_data = await tx.oneOrNone(query1, params1);
  const revenueArray = await tx.any(query2, params2);
  const groupsArray = await tx.any(query3, params3);

  
  const postedData = { item_data, revenueArray, groupsArray};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_data_for_items_table_view_btn", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});
//#region table 

//#region 1: get data for items table-view

//#endregion
//#region update item 
app.post("/api/update-item", async (req, res) => {
  

  try {
    const posted_elements = req.body;
    
    const hasPermission = await permissions(req, "accounts_permission", "update");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }


    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL

      const hasBadSymbols = sql_anti_injection([
        posted_elements.account_no,
        posted_elements.item_id,
        posted_elements.account_name,
        posted_elements.item_unite_input,
        posted_elements.account_parent_id,
        posted_elements.revenue_account_select_value,
        posted_elements.sales_price,
        posted_elements.purchase_price,
        posted_elements.reorder_point
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
   

      
      turn_EmptyValues_TO_null(posted_elements);


    let result = [];
    const query = `
      SELECT
        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $2) AS is_final_account_for_parent,
        (SELECT is_final_account FROM accounts_header WHERE company_id = $1 AND id = $4) AS is_final_account,
        (SELECT COUNT(id) FROM accounts_header WHERE company_id = $1 AND id = $4) AS count_account_id,
        (SELECT COUNT(id) FROM accounts_header WHERE company_id = $1 AND id = $2) AS count_account_parent,
        (SELECT COUNT(account_name) FROM accounts_header WHERE company_id = $1 AND account_name = $3 AND id != $4) AS count_account_name
    `;

    result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.account_parent_id,
      posted_elements.account_name,
      posted_elements.item_id,
    ]);
    


    if (result.is_final_account_for_parent || !result.is_final_account || result.count_account_id === 0 || result.count_account_parent === 0){
      if (result.finance_statement === null) {
        await block_user(req,'udi1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }

    
    
    if (result.count_account_name > 0) {
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„ØµÙ†Ù Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„",
        message_en: "Account with this name already exists",
      });
    }




    


    let query1;
    let query1_parameters;
    let query2;
    let query2_parameters;


      query1 = `UPDATE accounts_header SET 
      account_name = $1, account_no = $2, item_revenue_account = $3, item_sales_price = $4, item_purshas_price = $5, item_amount_reorder_point = $6 , item_unite = $7
      WHERE company_id = $8 AND id = $9`;
      query1_parameters = [
        posted_elements.account_name,
        posted_elements.account_no,
        posted_elements.revenue_account_select_value,
        posted_elements.sales_price,
        posted_elements.purchase_price,
        posted_elements.reorder_point,
        posted_elements.item_unite_input,
        req.session.company_id,
        posted_elements.item_id,
      ]

      query2 = `UPDATE accounts_body SET 
      parent_id = $1
      WHERE account_id = $2`;
      query2_parameters = [
        posted_elements.account_parent_id,
        posted_elements.item_id
      ]



      const item_data = await db.oneOrNone(
        `SELECT * FROM accounts_header WHERE id = $1 AND company_id = $2`,
        [posted_elements.item_id, req.session.company_id]
      );
  

//! update all account_id  fe table el transaction_body fe 7alt el sales wa el return eza tm ta8yeer el revenue account
      const query3 = `
      UPDATE transaction_body tb
SET account_id = $1
FROM transaction_header th
WHERE th.company_id = $2
  AND th.transaction_type IN (3, 4)
  AND tb.item_id = $3
  AND tb.transaction_header_id = th.id
  ;
  `
  const query3_parameters = [posted_elements.revenue_account_select_value, req.session.company_id, posted_elements.item_id]
      
    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {
      await tx.none(query1, query1_parameters);
      await tx.none(query2, query2_parameters);
    
      if (parseInt(item_data.item_revenue_account) !== parseInt(posted_elements.revenue_account_select_value)) {
        await tx.none(query3, query3_parameters);
      }
    });
    

    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    console.error("Error adding account:", error);
    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false, // Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙØ´Ù„Øª
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region delete item
app.post("/api/delete-item", async (req, res) => {
  try {
    const posted_elements = req.body;

    // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© (Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù‚Ø¯ ÙØ±Ø¹ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹)

    // ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
    const hasPermission = await permissions(req, "items_permission", "delete");
    if (!hasPermission) {
      return res.json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù„Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ØµÙ†Ù",
        message_en: "You do not have the necessary permissions to delete this account",
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ù‚Ù† SQL
    const hasBadSymbols = sql_anti_injection([
      posted_elements.account_id,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start--------------------------------------------------------------

    const query = `
      SELECT
        (SELECT COUNT(id) FROM accounts_header WHERE company_id = $1 AND id = $2) AS account_exists,
        (SELECT COUNT(id) FROM accounts_body WHERE parent_id = $2) as parentId
    `;

    const result = await db.oneOrNone(query, [
      req.session.company_id,
      posted_elements.account_id
    ]);


    if (result.account_exists === 0){
      await block_user(req,'adc01');
      return res.json({
        success: false,
        message_ar: "ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ø­Ø³Ø§Ø¨",
        xx: true,
        message_en: "Cannot delete account with sub-accounts",
      });
    }


    if (result.parentid > 0) {
      return res.json({
        success: false,
        message_ar: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„ÙˆØ¬ÙˆØ¯ Ø­Ø³Ø§Ø¨Ø§Øª ÙØ±Ø¹ÙŠØ© Ø¨Ø¯Ø§Ø®Ù„Ù‡",
        message_en: "Cannot delete account with sub-accounts",
      });
    }

    // Ø­Ø°Ù Ø§Ù„Ø¹Ù‚Ø¯Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const deleteQuery = `
      DELETE FROM accounts_header 
      WHERE company_id = $1 AND id = $2
    `;
    await db.none(deleteQuery, [req.session.company_id, posted_elements.account_id]);

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
      message_en: "Account deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting account:", error);
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
      message_en: "An error occurred while deleting the account",
    });
  }
});
//#endregion

 //#endregion

//#region  transaction

//#region 
app.post("/api/transaction_accounts_types", async (req, res) => {
  try {
    let query1 = `select id, account_type_name
from account_type
where id IN (1, 2, 3, 4 ,5, 6, 8, 9, 10)
order by order_asc ASC;`;  // in (1,2 ) ya3ny = 1 or 2 

    // Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
    let data = await db.any(query1);
    res.json(data);
  } catch (error) {
    console.error("/api/transaction_accounts_types:", error);
    res.status(500).send("Server Error");
  }
});
//#endregion


//#region 
app.post("/api/transaction_items_locations", async (req, res) => {
  try {
    let query1 = `select id, account_name
from accounts_header
where company_id = $1 AND account_type_id = 7 
order by account_name ASC ;`;  // in (1,2 ) ya3ny = 1 or 2 

    // Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
    let data = await db.any(query1,[req.session.company_id]);
    res.json(data);
  } catch (error) {
    console.error("/api/transaction_items_locations:", error);
    res.status(500).send("Server Error");
  }
});
//#endregion

//#region 1: transaction_review
app.post("/get_All_transaction_Data", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "transaction_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
 SELECT
    th.id,
    th.reference,
    CONCAT(
        tt.doc_prefix, '-',          -- Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø±ÙÙŠÙ† (doc_prefix) Ù…Ù† Ø¬Ø¯ÙˆÙ„ transaction_type
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    th.datex,
    COALESCE(th.general_note, '') AS general_note,
    COALESCE(th.total_value, 0) AS total_value
FROM
    transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
WHERE
    th.company_id = $1 AND
    th.transaction_type = 2
    AND (th.is_deleted IS NULL OR th.is_deleted != true)
   	AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
ORDER BY
    th.datex DESC,
    th.reference DESC;

`;
    let data = await db.any(query1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_All_transaction_Data:", error);
    res.status(500).send("Error:");
  }
});
//#endregion


//#region 2: add transaction
app.post("/api/transaction_add", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "transaction_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 2
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.is_accumulated_depreciation + obj.note_row + obj.debit + obj.credit + obj.item_amount + obj.items_location_id ), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.datex,
      posted_elements.total,
      posted_elements.general_note,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'add',
      tableName: false, // if type = 'update' or 'delete' only
      transaction_id: false, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit
    
      let totaldebit = 0;
      let totalCredit = 0;
      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
      posted_elements.posted_array.forEach(item => {        
          totaldebit += parseFloat(item.debit || 0); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù‚ÙŠÙ… Ø¥Ù„Ù‰ Ø£Ø±Ù‚Ø§Ù…
          totalCredit += parseFloat(item.credit || 0);
      });
      if (totaldebit !== totalCredit){
        return res.json({
          success: false,
          message_ar: "âŒ Ø§Ù„Ù‚ÙŠØ¯ ØºÙŠØ± Ù…ØªÙˆØ²Ù† : Ø¨Ø±Ø¬Ø§Ø¡ ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø§Ø±Ù‚Ø§Ù… Ø§Ù„Ù‰ Ø§Ù‚Ø±Ø¨ Ø±Ù‚Ù…ÙŠÙ† Ø¹Ø´Ø±ÙŠÙŠÙ†",
        });
      }


        // //! Security hacking  accounts id
// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND is_final_account IS TRUE`;
let rows02 = await db.any(query02, [req.session.company_id]);

// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
}));

let rowIndex = 1;
// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const account_typeId = rowData.account_typeId;
  const account_id = rowData.account_id;
  const items_location_id = rowData.items_location_id;
  const item_amount = rowData.item_amount;

  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +account_id && +item.account_type_id === +account_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Sta01')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }

  
  //! make sure from itemLocation It
  if (+account_typeId === 5){
      if (!items_location_id){
        return res.json({
          success: false,
          message_ar: `Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
        });
      }
    const locationExists = dbAccounts.some(item => 
      +item.id === +items_location_id && +item.account_type_id === 7
    );
    if (!locationExists) {
      await block_user(req,'Sta2')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
  }

  rowIndex++;
}


const year = getYear(posted_elements.datex);
const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header', transaction_type, year, req);
const newId_general_reference = await newId_fn("transaction_header", 'general_reference');

// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {
  let query1 = `INSERT INTO transaction_header
                (reference, datex, company_id, transaction_type, total_value, general_note, general_reference, is_including_items)
                VALUES($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id;`;

  const insert = await tx.one(query1, [
    newReference_transaction_header,
    posted_elements.datex,
    req.session.company_id,
    transaction_type,
    posted_elements.total,
    posted_elements.general_note,
    newId_general_reference,
    null, // Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø­Ù‚Ù„ is_including_items
  ]);

  const newId_transaction_header = insert.id;

  let insert_array2 = [];
  let items_array = [];
  let locations_array = [];




  for (const element of posted_elements.posted_array) {
    const itemTypeId = 5;
    const items_location_id = +element.account_typeId === itemTypeId ? element.items_location_id : null;
    let item_amount = null;
    if (+element.account_typeId === itemTypeId) {
        item_amount = element.debit ? element.item_amount || null : (element.item_amount * -1) || null;
    }    
    let item_id = null;
    let is_accumulated_depreciation = null
    if (+element.account_typeId === itemTypeId) { // ØµÙ†Ù Ù…Ø®Ø²ÙˆÙ†
      items_array.push(+element.account_id);
      locations_array.push(+element.items_location_id);
      item_id = +element.account_id;
    } else if (+element.account_typeId === 8) { // ØµÙ†Ù Ø®Ø¯Ù…Ø©
      item_id = +element.account_id;
    } else if (+element.account_typeId === 6) { //  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø§ØµÙˆÙ„ ÙˆØ§Ù„Ù…Ø¬Ù…Ø¹Ø§Øª
      is_accumulated_depreciation = element.is_accumulated_depreciation === 'true' ? true : null; // Ø§Ø­Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹
    }
    

    insert_array2.push([
      newId_transaction_header,
      element.account_id,
      element.debit,
      element.credit,
      element.note_row,
      item_id,
      item_amount,
      items_location_id,
      is_accumulated_depreciation,
    ]);
  }

// Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ø£ÙˆÙ„ ØµÙ ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
if (insert_array2.length > 0){
let columnsCount = insert_array2[0].length;
// Ø¨Ù†Ø§Ø¡ Ø¬Ù…Ù„Ø© SQL Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
let query2 = `INSERT INTO transaction_body
  (transaction_header_id, account_id, debit, credit, row_note, item_id, item_amount, item_location_id_tb, is_accumulated_depreciation)
  VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;

await tx.none(query2, insert_array2.flat());
}

  // ØªØ­Ø¯ÙŠØ« is_including_items Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ items_array
  let is_including_items = items_array.length > 0 ? true : null;
  let updateQuery = `UPDATE transaction_header
                     SET is_including_items = $1
                     WHERE id = $2;`;

  await tx.none(updateQuery, [is_including_items, newId_transaction_header]);

  //! history // 500500
  if (items_array.length > 0){

    const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
if (!allow_amounts){
  throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
} else if (allow_amounts !== true) {
  throw new Error(allow_amounts);
}
    await update_items_cogs(items_array,posted_elements.datex, req, tx)
  }
  await history(transaction_type, 1, newId_transaction_header, newReference_transaction_header, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error adding transaction:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion


//#region 2: update transaction
app.post("/api/transaction_update", async (req, res) => {
  try {
    let start_time = performance.now()
    //! Permission
    await permissions(req, "transaction_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 2
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.is_accumulated_depreciation + obj.note_row + obj.debit + obj.credit + obj.item_amount + obj.items_location_id ), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.x,
      posted_elements.total,
      posted_elements.datex,
      posted_elements.general_note,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'update',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit
      let totaldebit = 0;
      let totalCredit = 0;
      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©


      //! Security hacking check id for company_name and transactio type
      let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
      let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
      
      

      if (!rows01 || !rows01.id) {
        return res.json({
          success: false,
          message_ar: 'Ù‡Ø°Ø§ Ø§Ù„Ù‚ÙŠØ¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ù‡ ',
        });
      }
      const reference = rows01.reference

        //! Security hacking  accounts id
// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1`;
let rows02 = await db.any(query02, [req.session.company_id]);

// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
}));

let rowIndex = 1;
// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const account_typeId = rowData.account_typeId;
  const account_id = rowData.account_id;
  const items_location_id = rowData.items_location_id;
  const item_amount = rowData.item_amount;

  totaldebit += parseFloat(rowData.debit || 0);
  totalCredit += parseFloat(rowData.credit || 0);
  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +account_id && +item.account_type_id === +account_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Stu1')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }



  //! make sure from itemLocation It
  if (+account_typeId === 5){
    if (!items_location_id){
      return res.json({
        success: false,
        message_ar: `âŒ Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
      });
    }
    const locationExists = dbAccounts.some(item => 
      +item.id === +items_location_id && +item.account_type_id === 7
    );
    if (!locationExists) {
      await block_user(req,'Sta2')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
  }
  rowIndex++;

}

if (+totaldebit.toFixed(2) !== +totalCredit.toFixed(2)){
  return res.json({
    success: false,
    message_ar: "Ø§Ù„Ù‚ÙŠØ¯ ØºÙŠØ± Ù…ØªÙˆØ§Ø²Ù†",
  });
}
let end_time = performance.now()


//console.log(end_time - start_time);

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {

      //? Clear transaction_body
      let query0 = `Delete FROM transaction_body WHERE transaction_header_id = $1`
      await tx.none(query0,[posted_elements.x])

      //? update INTO transaction_header
      let query1 = `UPDATE transaction_header 
SET 
  datex = $1,
  total_value = $2,
  general_note = $3
WHERE id = $4
AND (datex IS DISTINCT FROM $1 OR total_value IS DISTINCT FROM $2 OR general_note IS DISTINCT FROM $3)
;`;

      await tx.none(query1, [
        posted_elements.datex,
        posted_elements.total,
        posted_elements.general_note,
        posted_elements.x
      ]);

      let insert_array2 = [];
      let items_array = [];
      let locations_array = [];

 
  // let query2 = `INSERT INTO transaction_body
  // (transaction_header_id, account_id, debit, credit, row_note, item_id, item_amount, item_location_id_tb, is_accumulated_depreciation)
  // VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9)`;

  for (const element of posted_elements.posted_array) {
    const itemTypeId = 5;
    const items_location_id = +element.account_typeId === itemTypeId ? element.items_location_id : null;
    let item_amount = null;
    if (+element.account_typeId === itemTypeId) {
      
        item_amount = element.debit ? element.item_amount || null : (element.item_amount * -1) || null;
    }
    
    let item_id = null;
    let is_accumulated_depreciation = null;

    if (+element.account_typeId === itemTypeId) { // ØµÙ†Ù Ù…Ø®Ø²ÙˆÙ†
      items_array.push(+element.account_id);
      locations_array.push(+element.items_location_id);
      item_id = +element.account_id;
    } else if (+element.account_typeId === 8) { // ØµÙ†Ù Ø®Ø¯Ù…Ø©
      item_id = +element.account_id;
    } else if (+element.account_typeId === 6) { //  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø§ØµÙˆÙ„ ÙˆØ§Ù„Ù…Ø¬Ù…Ø¹Ø§Øª
      is_accumulated_depreciation = element.is_accumulated_depreciation === 'true' ? true : null; // Ø§Ø­Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹
    }

    insert_array2.push([
      posted_elements.x,
      element.account_id,
      element.debit,
      element.credit,
      element.note_row,
      item_id,
      item_amount,
      items_location_id,
      is_accumulated_depreciation
    ]);
  }

  
// Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ø£ÙˆÙ„ ØµÙ ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
let columnsCount = insert_array2[0].length;  

// Ø¨Ù†Ø§Ø¡ Ø¬Ù…Ù„Ø© SQL Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
let query2 = `INSERT INTO transaction_body
  (transaction_header_id, account_id, debit, credit, row_note, item_id, item_amount, item_location_id_tb, is_accumulated_depreciation)
  VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;


await tx.none(query2, insert_array2.flat());


  

  // ØªØ­Ø¯ÙŠØ« is_including_items Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ items_array
  let is_including_items = items_array.length > 0 ? true : null;
  let updateQuery = `UPDATE transaction_header
                     SET is_including_items = $1
                     WHERE id = $2;`;

  await tx.none(updateQuery, [is_including_items, posted_elements.x]);

  //! history // 500500
  if (items_array.length > 0){

    const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
    if (!allow_amounts){
      throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
    } else if (allow_amounts !== true) {
      throw new Error(allow_amounts);
    }

    await update_items_cogs(items_array,posted_elements.datex, req, tx)
  }
      
      //! history
      await history(transaction_type,2,posted_elements.x,reference,req,tx);
    });

    const new_referenceFormatting = formatFromFiveDigits(reference);
    const year = getYear(posted_elements.datex)

    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    
    
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error updating transaction:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion



app.post("/api/transaction_delete", async (req, res) => {

  try {

    //! Permission
    await permissions(req, "transaction_permission", "delete");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }
    const posted_elements = req.body;

    const transaction_type = 2
  
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: false, // if // if type = 'update' or 'add' only
      type: 'delete',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }
    

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    let reference;
    await db.tx(async (tx) => {
            //! Security hacking check id for company_name and transactio type
            let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
            let rows01 = await tx.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
        
            if (!rows01 || !rows01.id) {
              throw new Error("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹");
            }
            reference = rows01.reference

            let query2 = `select
            tb.item_id
          from
            transaction_body tb
          inner join accounts_header ah on ah.id = tb.item_id
          where
            tb.transaction_header_id = $1
            and ah.company_id = $2
            and tb.item_id is not null
            and ah.account_type_id = 5
            ;
            `
            let items_array = await tx.any(query2, [posted_elements.x, req.session.company_id]);
            items_array = items_array.map(row => Number(row.item_id));  // ØªØ­ÙˆÙŠÙ„ item_id Ø¥Ù„Ù‰ Ø±Ù‚Ù…

                  //? Clear transaction_body
      let query0 = `Delete FROM transaction_body WHERE transaction_header_id = $1`
      await tx.none(query0,[posted_elements.x])

      //? update transaction_header
      let query1 = `update transaction_header set 
                      is_deleted = true
                    WHERE
                      id = $1;`;

      await tx.none(query1, [
        posted_elements.x
      ]);


      if (items_array && items_array.length > 0) {
        await update_items_cogs(items_array,posted_elements.datex, req, tx)
      }
      
      //! history
      await history(transaction_type,3,posted_elements.x,reference,req,tx);
    })


    const new_referenceFormatting = formatFromFiveDigits(reference);
    const year = getYear(posted_elements.datex)

    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error delete transaction:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//#region 3: get transaction data
app.post("/get_transaction_Data", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "transaction_permission", "update");
    if (!permissions) {
      return;
    }


    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------

    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    const q1 = `
  select 
  	company_id,
  	transaction_type
  from
  	transaction_header
  where
  	id = $1
  	`;
    const result = await db.oneOrNone(q1,[posted_elements.x])

    if(!result || !result.company_id || !result.transaction_type || +result.company_id != +req.session.company_id || +result.transaction_type != 2){
      await block_user(req,'Sgtu1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

//! Ù…Ø·Ù„Ø©Ø¨ Ø§Ù„ØªØ§ÙƒØ¯ Ù…Ù†  ØªØ±Ø§Ù†ÙƒØ³Ø´Ù† Ù‡ÙŠØ¯Ø± Ø§Ù‰ Ø¯Ù‰ ÙŠØ®Øµ Ø§Ù„Ø´Ø±ÙƒÙ‡ ÙˆØ§Ù†Ù‡ Ø¹Ø¨Ø§Ø±Ù‡ Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰

let query1 = `select 
	th.id,
  CONCAT(
    tt.doc_prefix, '-',
    SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
  ) AS referenceconcat,
	th.datex,
  COALESCE(th.general_note, '') as general_note 
from
	transaction_header th
  LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
where
	th.id = $1
	and th.company_id = $2
	and th.is_deleted is null
  ;
  `
  let params1 = [posted_elements.x, req.session.company_id]




    let query2 = ` 
 SELECT
    tb.debit,
    tb.credit,
    tb.row_note,
    ABS(tb.item_amount) as item_amount,
    tb.item_location_id_tb,
    tb.account_id,
    tb.is_accumulated_depreciation,
    ah.account_type_id,
    CASE
        WHEN tb.is_accumulated_depreciation = true THEN 'Ù…Ø¬Ù…Ø¹ Ø¥Ù‡Ù„Ø§Ùƒ - ' || ah.account_name
        ELSE ah.account_name
    END AS account_name,
    COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite
FROM 
    transaction_body tb
INNER JOIN accounts_header ah ON ah.id = tb.account_id
inner join transaction_header th on th.id = tb.transaction_header_id
where
	th.id = $1
	and th.company_id = $2
	and th.transaction_type = 2
order by
	tb.id ASC
;

`;
let params2 = [posted_elements.x, req.session.company_id]

await db.tx(async (tx) => {
  
  const headerData = await tx.oneOrNone(query1, params1);
  const bodyData = await tx.any(query2, params2);


  const postedData = {headerData, bodyData};
  res.json(postedData);
})
await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error get_All_bread_Data:", error);
    res.status(500).send("Error:");
  }
});
//#endregion



//#region sales

//#region get itemsLocations and salesman
app.post("/get_Data_for_sales_qutation_add_page", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "sales_qutation_permission", "add");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 7
  ;
`;
let params1 = [req.session.company_id]

let query2 = `
  select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4
  AND is_final_account IS true
  and is_salesman IS true
  AND is_inactive IS null
  ;
`
let params2 = [req.session.company_id]

let query3 = `
    select 
	th.id,
	th.taxe_package_name as account_name
from
 	settings_tax_header th
where
	th.company_id = $1
	and th.is_inactive is null
order by
	th.taxe_package_name asc 
 
`
let params3 = [req.session.company_id]

let query4 = `
select
    tb.id,
    tb.tax_name,
    tb.tax_rate,
    tb.is_tax_reverse,
    tb.tax_account_id,
    ah.account_name,
    tb.settings_tax_header_id
from
    settings_tax_body tb
left join accounts_header ah on ah.id = tb.tax_account_id    
where
    tb.settings_tax_header_id = ANY($1::int[])
`;


let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
`;

let params5 = [req.session.company_id];


let query6 = `
select
  ah.id,
  ah.account_name
from
  accounts_header ah
where
  ah.company_id = $1
  AND ah.is_final_account is true
  AND is_inactive is null
  AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`

  let params6 = [req.session.company_id];

await db.tx(async (tx) => {

  const itemslocationsArray = await tx.any(query1, params1);
  const salesmanArray = await tx.any(query2, params2);
  const taxHeaderArray = await tx.any(query3, params3);
  const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
  const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
  const itemsDataArray = await tx.any(query5, params5);
  const customersDataArray = await tx.any(query6, params6);

  const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray };
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false,message_ar: error.message || deafultErrorMessage,});
  }
});
//#endregion end get itemslocations and salesman


app.post("/get_data_for_sales_qutation_update", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "sales_qutation_permission", "update");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 7
  ;
`;
let params1 = [req.session.company_id]

let query2 = `
  select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4
  AND is_final_account IS true
  and is_salesman IS true
  AND is_inactive IS null
  ;
`
let params2 = [req.session.company_id]

let query3 = `
    select 
	th.id,
	th.taxe_package_name as account_name 
from
 	settings_tax_header th
where
	th.company_id = $1
	and th.is_inactive is null
order by
	th.taxe_package_name asc 
 
`
let params3 = [req.session.company_id]

let query4 = `
select
    tb.id,
    tb.tax_name,
    tb.tax_rate,
    tb.is_tax_reverse,
    tb.tax_account_id,
    ah.account_name,
    tb.settings_tax_header_id
from
    settings_tax_body tb
left join accounts_header ah on ah.id = tb.tax_account_id    
where
    tb.settings_tax_header_id = ANY($1::int[])
`;


let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
`;

let params5 = [req.session.company_id];


let query6 = `
select
  ah.id,
  ah.account_name
from
  accounts_header ah
where
  ah.company_id = $1
  AND ah.is_final_account is true
  AND is_inactive is null
  AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`

  let params6 = [req.session.company_id];


let query7 = `
select 
	bih.id,
  bih.reference,
	COALESCE(bih.general_note, '') as general_note,
	bih.datex,
	bih.account_id,
	bih.salesman_id,
	bih.is_qutation_status,
	bih.expire_offer_datex,
	bih.is_invoiced,
	bih.qutation_id,
	bih.is_delivered,
	bih.items_location_id,
	bih.is_column2 as is_row_note_show,
	bih.is_column1 as is_row_dicount_show,
	bih.is_column3 as is_row_tax_show,
  CONCAT(
    tt.doc_prefix, '-',
    SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
  ) AS referenceconcat
from
	befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
where 
bih.id = $1
and bih.company_id = $2
and bih.transaction_type = 23
AND bih.is_deleted IS NULL;
`
let params7 = [posted_elements.x, req.session.company_id];

let query8 = `
select
	bib.id,
	bib.item_type_id,
	bib.item_id,
  	ah.account_name,
  	ah.item_unite,
	bib.amount,
	bib.unite_price,
	COALESCE(bib.row_note, '') as row_note,
	bib.is_discount_percentage,
	bib.dicount_value,
	bib.tax_header_id,
	  sth.taxe_package_name

from
	befor_invoce_body bib
LEFT JOIN accounts_header ah on ah.id = bib.item_id 
LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id 
where 
	bib.header_id = $1;
`
let params8 = [posted_elements.x]




await db.tx(async (tx) => {

  const itemslocationsArray = await tx.any(query1, params1);
  const salesmanArray = await tx.any(query2, params2);
  const taxHeaderArray = await tx.any(query3, params3);
  const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
  const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
  const itemsDataArray = await tx.any(query5, params5);
  const customersDataArray = await tx.any(query6, params6);
  const headerDataArray = await tx.oneOrNone(query7, params7);
  const bodyDataArray = await tx.any(query8, params8);
  
  const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, headerDataArray, bodyDataArray };
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});
//#endregion


//#region sales order
  
  //#region get data for sales order add
  app.post("/get_data_for_sales_order_add", async (req, res) => {
    try {
      //! Permission
      await permissions(req, "sales_permission", "add");
      if (!permissions) {
        return;
      }
  
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  

   let query7 = `
select 
	bih.id,
	    CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS account_name
from
	befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
where
	bih.transaction_type = 23
	and bih.company_id = $1
	and bih.is_deleted is NULL
	and bih.is_qutation_status IS NOT FALSE;
   ` 
   let params7 = [req.session.company_id]

  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const salesQutationReferencesArray = await tx.any(query7, params7);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, salesQutationReferencesArray };
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get Employees Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false,message_ar: error.message || deafultErrorMessage,});
    }
  });
  //#endregion get data for sales order add

//#region getting data for sales order update
app.post("/get_data_for_sales_order_update", async (req, res) => {
  try {
    // //! Permission Ù…Ø¹Ù„Ù‚
    // await permissions(req, "sales_permission", "add");
    // if (!permissions) {
    //   return;
    // }

    
    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let transaction_type;
    if(posted_elements.type === 'qutation'){
      transaction_type = 23
    }else if(posted_elements.type === 'order'){
      transaction_type = 24
    }


    let query1 = `
     -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 7
  ;
`;
let params1 = [req.session.company_id]

let query2 = `
  select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4
  AND is_final_account IS true
  and is_salesman IS true
  AND is_inactive IS null
  ;
`
let params2 = [req.session.company_id]

let query3 = `
    select 
	th.id,
	th.taxe_package_name as account_name
from
 	settings_tax_header th
where
	th.company_id = $1
	and th.is_inactive is null
order by
	th.taxe_package_name asc 
 
`
let params3 = [req.session.company_id]

let query4 = `
select
    tb.id,
    tb.tax_name,
    tb.tax_rate,
    tb.is_tax_reverse,
    tb.tax_account_id,
    ah.account_name,
    tb.settings_tax_header_id
from
    settings_tax_body tb
left join accounts_header ah on ah.id = tb.tax_account_id    
where
    tb.settings_tax_header_id = ANY($1::int[])
`;


let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
`;

let params5 = [req.session.company_id];


let query6 = `
select
  ah.id,
  ah.account_name
from
  accounts_header ah
where
  ah.company_id = $1
  AND ah.is_final_account is true
  AND is_inactive is null
  AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`

  let params6 = [req.session.company_id];


let query7 = `
select 
	bih.id,
  bih.reference,
	COALESCE(bih.general_note, '') as general_note,
	bih.datex,
	bih.account_id,
	bih.salesman_id,
	bih.is_qutation_status,
	bih.expire_offer_datex,
	bih.is_invoiced,
	bih.qutation_id,
	bih.is_delivered,
	bih.items_location_id,
	bih.is_column2 as is_row_note_show,
	bih.is_column1 as is_row_dicount_show, 
	bih.is_column3 as is_row_tax_show, 
  CONCAT(
    tt.doc_prefix, '-',
    SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
  ) AS referenceconcat
from
	befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
where 
bih.id = $1
and bih.company_id = $2
and bih.transaction_type = $3
AND bih.is_deleted IS NULL;
`
let params7 = [posted_elements.x, req.session.company_id, transaction_type];

let query8 = `
select
	bib.id,
	bib.item_type_id,
	bib.item_id,
  	ah.account_name,
  	ah.item_unite,
	bib.amount,
	bib.unite_price,
	COALESCE(bib.row_note, '') as row_note,
	bib.is_discount_percentage,
	bib.dicount_value,
	bib.tax_header_id,
	  sth.taxe_package_name

from
	befor_invoce_body bib
LEFT JOIN accounts_header ah on ah.id = bib.item_id 
LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id 
where 
	bib.header_id = $1;
`
let params8 = [posted_elements.x]


let query9 = `
select 
	bih.id,
	    CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS account_name
from
	befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
where
	bih.transaction_type = 23
	and bih.company_id = $1
	and bih.is_deleted is NULL
	and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
   ` 
   qutation_id = isNaN(+posted_elements.qutation_id)? null : posted_elements.qutation_id 
   let params9 = [req.session.company_id, qutation_id]



await db.tx(async (tx) => {

  const itemslocationsArray = await tx.any(query1, params1);
  const salesmanArray = await tx.any(query2, params2);
  const taxHeaderArray = await tx.any(query3, params3);
  const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
  const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
  const itemsDataArray = await tx.any(query5, params5);
  const customersDataArray = await tx.any(query6, params6);
  const headerDataArray = await tx.oneOrNone(query7, params7);
  const bodyDataArray = await tx.any(query8, params8);
  const salesQutationReferencesArray = await tx.any(query9, params9);

  const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, headerDataArray, bodyDataArray, salesQutationReferencesArray};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});
//#endregion getting data fro sales order update


//#endregion sales order


//#endregion


//#region  settings Taxes

  //#region settings Taxes view
  app.post("/get_settings_taxes_Data", async (req, res) => {
    try {

      // //! Permission
      // await permissions(req, "sales_permission", "view");
      // if (!permissions) {
      //   return;
      // }
  
      const posted_elements = req.body;
  
          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }
        
            // const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
            // if (InValidDateFormat){
            //   return res.json({
            //     success: false,
            //     message_ar: InValidDateFormat_message_ar,
            //   });
            // }
          
  
  
        turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
  
  
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `
select 
	id,
  	taxe_package_name,
	CASE 
    	WHEN
      		is_inactive = true THEN 'ØºÙŠØ± Ù†Ø´Ø·'
    	ELSE
     		'Ù†Ø´Ø·'
  	END as is_inactive
from
	settings_tax_header
where 
	company_id = $1
ORDER BY
  id DESC;
  `;
  
      let data = await db.any(query1, [req.session.company_id]);
  
      res.json(data);
    } catch (error) {
      console.error("Error get_settings_taxes_data:", error);
      res.status(500).send("Error:");
    }
  });
  
  //#endregion

  //#region get accounts for taxes add
  app.post("/getAccountsDataForTaxesAdd", async (req, res) => {
    try {
      //! Permission
      // await permissions(req, "effects_permission", "view");
      // if (!permissions) {
      //   return;
      // }
  

      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `SELECT id, account_name FROM accounts_header where company_id = $1 AND account_type_id = 1 AND is_final_account IS TRUE AND main_account_id in(1,2)`;
      let data = await db.any(query1, [req.session.company_id]);
  

      res.json(data);
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get Accounts data for taxes add page Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false,message_ar: error.message || deafultErrorMessage,});
    }
  });

  //#endregion


  //#region add tax
  app.post("/api/tax_add", async (req, res) => {
    try {
  
      //! Permission
      // await permissions(req, "transaction_permission", "add");
      // if (!permissions) {
      //   return res.status(403).json({
      //     success: false,
      //     message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      //   });
      // }
  
      const posted_elements = req.body;
      const transaction_type = 22
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.Desc + obj.rate + obj.reverse_type + obj.account_id ), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.tax_package_name,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      // const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      // if (InValidDateFormat) {
      //   return res.status(400).json({
      //     success: false,
      //     message_ar: InValidDateFormat_message_ar,
      //   });
      // }
  
      // //! settings
      // const settings = await check_settings_validation({
      //   check_futureDate: true,
      //   check_closingDate: true,
      //   datex: posted_elements.datex,
      //   type: 'add',
      //   tableName: false, // if type = 'update' or 'delete' only
      //   transaction_id: false, // if type = 'update' or 'delete' only
      // }, req);
  
      
      // if (!settings.valid) {
      //   return res.json({
      //     success: false,
      //     message_ar: settings.message_ar,
      //   });
      // }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      //* Start Transaction --------------------------------------------------
  
      //! check diffrence between debit and credit
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
        posted_elements.posted_array.forEach(item => {

          if(!item.Desc || item.Desc === '' || !item.rate || isNaN(item.rate) || !item.reverse_type || !item.account_id || isNaN(item.account_id)){
            return res.json({
              success: false,
              message_ar: "âŒ  Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ø«Ù… Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§",
            });
          } 
        });
  
  
          // //! Security hacking  accounts id
  // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  let query02 = `SELECT id
                  FROM
                    accounts_header
                  WHERE
                  company_id = $1
                  AND is_final_account = true
                  AND main_account_id in (1,2)`;
  let rows02 = await db.any(query02, [req.session.company_id]);
  
  // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
  const dbAccounts = rows02.map(row => ({
    id: parseInt(row.id)
    // account_type_id: row.account_type_id
  }));
  
  // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
  for (const rowData of posted_elements.posted_array) {
    const account_id = rowData.account_id;
  
    //! make sure from every account_id
    const accountExists = dbAccounts.some(item => 
      +item.id === +account_id
    );
  
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!accountExists) {
      await block_user(req,'Staxa01')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    
  }
    
      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {
        let query1 = `INSERT INTO settings_tax_header
                      (taxe_package_name, is_inactive, company_id)
                      VALUES($1, $2, $3) RETURNING id;`;
  
        const insert = await tx.one(query1, [
          posted_elements.tax_package_name,
          +posted_elements.inactive_select_val === 0 ? null : true, 
          req.session.company_id
        ]);
  
        const newId_tax_header = insert.id;

        for (const element of posted_elements.posted_array) {
  
          //! make sure if account id != item  then location and amount = null

  
          let query2 = `INSERT INTO settings_tax_body
                        (tax_name, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id)
                        VALUES($1, $2, $3, $4, $5);`;
  
          await tx.none(query2, [
            element.Desc,
            +element.rate,
            +element.reverse_type === 1? null : true,
            element.account_id,
            newId_tax_header
          ]);
        }
  
        //! history
        await history(transaction_type,1,newId_tax_header,0,req,tx);
      });
  
      // const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø§Ø¬`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error adding tax:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });

  app.post("/get_settings_update_Data", async (req, res) => {
    try {
      // //! Permission
      // await permissions(req, "transaction_permission", "update");
      // if (!permissions) {
      //   return;
      // }
  
  
      const posted_elements = req.body;
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
  
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
      const q1 = `
    select 
      count(id) as id_count
    from
      settings_tax_header
    where
      id = $1
      `;
      const result = await db.oneOrNone(q1,[posted_elements.x])
  
      if(result.id_count < 1){
        await block_user(req,'gsud1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
  
  //! Ù…Ø·Ù„Ø©Ø¨ Ø§Ù„ØªØ§ÙƒØ¯ Ù…Ù†  ØªØ±Ø§Ù†ÙƒØ³Ø´Ù† Ù‡ÙŠØ¯Ø± Ø§Ù‰ Ø¯Ù‰ ÙŠØ®Øµ Ø§Ù„Ø´Ø±ÙƒÙ‡ ÙˆØ§Ù†Ù‡ Ø¹Ø¨Ø§Ø±Ù‡ Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰
      let query1 = `
  SELECT
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name
  FROM 
      settings_tax_body tb
  LEFT JOIN accounts_header as ah on ah.id = tb.tax_account_id    
  WHERE
      tb.settings_tax_header_id = $1
  ORDER BY
      tb.id ASC;

  
  `;
      const data = await db.any(query1, [posted_elements.x]);
      
      res.json(data);
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error get_settings_update_Data:", error);
      res.status(500).send("Error:");
    }
  });
  //#endregion


  app.post("/api/tax_update", async (req, res) => {
    try {
      const posted_elements = req.body;
      const transaction_type = 22;
  
      //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ SQL Injection
      const hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map(obj => obj.rowId + obj.Desc + obj.rate + obj.reverse_type + obj.account_id),
        posted_elements.tax_package_name,
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
      //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…ØµÙÙˆÙØ©
      for (const item of posted_elements.posted_array) {
        if (!item.rowId || isNaN(item.rowId) || !item.Desc || item.Desc === '' || !item.rate || isNaN(item.rate) || !item.reverse_type || !item.account_id || isNaN(item.account_id)) {
          return res.json({
            success: false,
            message_ar: "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ø«Ù… Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§",
          });
        }
      }
  
      //! Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const query02 = `SELECT id FROM accounts_header WHERE company_id = $1 AND is_final_account = true AND main_account_id in (1,2)`;
      const rows02 = await db.any(query02, [req.session.company_id]);
      const dbAccounts = rows02.map(row => ({ id: parseInt(row.id) }));
  
      for (const rowData of posted_elements.posted_array) {
        const account_id = rowData.account_id;
        const accountExists = dbAccounts.some(item => +item.id === +account_id);
        if (!accountExists) {
          await block_user(req, 'Sta1');
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
      }
  
      //! ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
      await db.tx(async tx => {
        const query1 = `UPDATE settings_tax_header SET taxe_package_name = $1, is_inactive = $2 WHERE id = $3 AND company_id = $4`;
        const resultQ1 = await tx.result(query1, [
          posted_elements.tax_package_name,
          +posted_elements.inactive_select_val === 0 ? null : true,
          posted_elements.header_Id,
          req.session.company_id,
        ]);
        if (resultQ1.rowCount === 0) throw new Error("No rows were updated, rolling back transaction.");
  
        for (const element of posted_elements.posted_array) {
          const query2 = `UPDATE settings_tax_body SET tax_name = $1, tax_rate = $2, is_tax_reverse = $3, tax_account_id = $4 WHERE id = $5 AND settings_tax_header_id = $6`;
          const resultQ2 = await tx.result(query2, [
            element.Desc,
            +element.rate,
            +element.reverse_type === 1 ? null : true,
            element.account_id,
            element.rowId,
            posted_elements.header_Id,
          ]);
          if (resultQ2.rowCount === 0) throw new Error("No rows were updated, rolling back transaction.");
        }
  
        //! Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ§Ø±ÙŠØ®
        await history(transaction_type, 2, posted_elements.header_Id, 0, req, tx);
      });
  
      //! Ø§Ù„Ù†Ø¬Ø§Ø­
      await last_activity(req);
      return res.json({
        success: true,
        message_ar: "âœ… ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­",
      });
    } catch (error) {
      //! Ø¹Ù†Ø¯ Ø­Ø¯ÙˆØ« Ø®Ø·Ø£
      await last_activity(req);
      console.error("Error update tax:", error);
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  

  app.post("/api/tax_delete", async (req, res) => {
    try {
  
      //! Permission
      // await permissions(req, "transaction_permission", "add");
      // if (!permissions) {
      //   return res.status(403).json({
      //     success: false,
      //     message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      //   });
      // }
  
      const posted_elements = req.body;
      const transaction_type = 22
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.rowId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.tax_package_name,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      // const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      // if (InValidDateFormat) {
      //   return res.status(400).json({
      //     success: false,
      //     message_ar: InValidDateFormat_message_ar,
      //   });
      // }
  
      // //! settings
      // const settings = await check_settings_validation({
      //   check_futureDate: true,
      //   check_closingDate: true,
      //   datex: posted_elements.datex,
      //   type: 'add',
      //   tableName: false, // if type = 'update' or 'delete' only
      //   transaction_id: false, // if type = 'update' or 'delete' only
      // }, req);
  
      
      // if (!settings.valid) {
      //   return res.json({
      //     success: false,
      //     message_ar: settings.message_ar,
      //   });
      // }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      //* Start Transaction --------------------------------------------------
  
      //! check diffrence between debit and credit
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
        posted_elements.posted_array.forEach(item => {

          if(!item.rowId || isNaN(item.rowId)){
            return res.json({
              success: false,
              message_ar: "âŒ  Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ø«Ù… Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§",
            });
          } 
        });
  
        const query = `
        SELECT
          (SELECT COUNT(id) FROM settings_tax_header WHERE id = $1 AND company_id = $2) AS count_id,
          (SELECT COUNT(settings_tax_header_id) FROM transaction_body WHERE settings_tax_header_id = $1) as settings_tax_header_id_count
      `;
  
      const result = await db.oneOrNone(query, [
        posted_elements.header_Id,
        req.session.company_id
      ]);
  
      if (result.count_id === 0){
        await block_user(req,'S-td1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


      if (result.settings_tax_header_id_count > 0){
        return res.json({
          success: false,
          message_ar: 'ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª ØªØªØ¹Ù„Ù‚ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ø¶Ø±ÙŠØ¨Ù‰',
        });
      }
              
  
          // //! Security hacking  accounts id

    
  
      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {
        let query1 = `delete from
                        settings_tax_header
                      WHERE
                        id = $1
                        AND company_id = $2`;
  
         const resultQ1 = await tx.result(query1, [
            posted_elements.header_Id,
            req.session.company_id
          ]);
        


          if (resultQ1.rowCount === 0) {
            throw new Error("No rows were delete, rolling back transaction.");
          }
        

        //! history
        await history(transaction_type,3,posted_elements.header_Id,0,req,tx);
      });
  
      // const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error Deleting tax:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });


//#region sales Qutation
  

//#region 1: sales_qutation_view
app.post("/get_sales_qutation_Data_view", async (req, res) => {
  try {
    
    //! Permission  Ù…Ø¹Ù„Ù‚
    await permissions(req, "sales_qutation_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
select 
    bih.id,
    bih.reference,
    bih.total_value,
    COALESCE(bih.general_note, '') as general_note, 
    bih.datex,
    bih.account_id as customer_id,
    ah1.account_name as customer_name,
    bih.salesman_id as salesman_id,
    ah2.account_name as salesman_name,
    CASE 
        WHEN bih.is_qutation_status IS TRUE THEN 'Ù…Ù‚Ø¨ÙˆÙ„'
        WHEN bih.is_qutation_status IS NULL THEN 'Ù…Ø¹Ù„Ù‚'
        ELSE 'Ù…Ø±ÙÙˆØ¶'
    END AS qutation_status,
    bih.expire_offer_datex,
    bih.is_column2 as is_row_note_show,
    bih.is_column1 as is_row_dicount_show, 
    bih.is_column3 as is_row_tax_show, 
    CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat
from
    befor_invoice_header bih
LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type    
left join accounts_header ah1 on ah1.id = bih.account_id
left join accounts_header ah2 on ah2.id = bih.salesman_id
where
    bih.company_id = $1
    AND bih.transaction_type = 23
    AND (bih.datex BETWEEN $2 AND $3) -- Ø§Ù„ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù‚ÙŠÙ… Ø¨ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù†ØµÙŠØ© ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    AND bih.is_deleted IS NULL
ORDER BY
    bih.datex DESC,
    bih.reference DESC;

`;

    let data = await db.any(query1, [req.session.company_id,posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_sales_qutation_Data_view:", error);
    res.status(500).send("Error:");
  }
});

app.post("/getItemssData1", async (req, res) => {
  try {
    // //! Permission Ù…Ø¹Ù„Ù‚
    // await permissions(req, "effects_permission", "view");
    // if (!permissions) {
    //   return;
    // }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
    `;
    
    let data = await db.any(query1, [req.session.company_id]);


    res.json(data);
  } catch (error) {
    console.error("Error while get accounts Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});

//#endregion


    //#region sales qutation add
    app.post("/api/sales_qutation_add", async (req, res) => {
      try {
    
        //! Permission
        await permissions(req, "sales_qutation_permission", "add");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 23
      
    
        //! sql injection check
        let hasBadSymbols = sql_anti_injection([
          ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
          posted_elements.customerId,
          posted_elements.total,
          posted_elements.datex,
          posted_elements.itemLocationId,
          posted_elements.salesmanId,
          posted_elements.is_RowNote,
          posted_elements.is_RowDiscount,
          posted_elements.general_note,
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        ]);
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar: sql_injection_message_ar,
            message_en: sql_injection_message_en,
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'add',
          tableName: false, // if type = 'update' or 'delete' only
          transaction_id: false, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
       const total = +posted_elements.total

       if (!total || isNaN(total)){
        await block_user(req,'Ssqa001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
       }

    
    // //! Security hacking  accounts id


    // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
    let rows02 = await db.any(query02, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id,
      is_salesman: row.is_salesman
    }));

    //check salesman

    const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
    const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_salesman) {
        await block_user(req,'Ssqa01')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_itemLocation) {
        await block_user(req,'Ssqa02')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const item_typeId = rowData.item_typeId;
      const item_id = rowData.item_id;

    
      //! make sure from every account_id
      const accountExists = dbAccounts.some(item => 
        +item.id === +item_id && +item.account_type_id === +item_typeId
      );
    
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!accountExists) {
        await block_user(req,'Ssqa1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    
    
        // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
        let rows03 = await db.any(query03, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbTaxesHeaderArray = rows03.map(row => ({
          id: parseInt(row.id)
        }));
        
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const row_taxHeaderId = rowData.row_taxHeaderId;
          
          if (row_taxHeaderId){
          //! make sure from every account_id
          const taxExists = dbTaxesHeaderArray.some(item =>
            +item.id === +row_taxHeaderId
          );
          

        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!taxExists) {
            await block_user(req,'Ssqa2')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        }
    

        
        const year = getYear(posted_elements.datex)
        
        const query001 = `SELECT MAX(reference) AS max FROM befor_invoice_header WHERE company_id = $1 AND transaction_Type = 23 AND datex LIKE '${year}-%'; -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø³Ù†Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ§Ø±ÙŠØ® `;
      const Params001 = [req.session.company_id];
      const result001 = await db.oneOrNone(query001, Params001);
      let newReference_transaction_header = 1;
      if (result001 && result001.max && result001.max > 0) {
        newReference_transaction_header = +result001.max + 1;
      }
    
        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let query1 = `INSERT INTO befor_invoice_header
                        (reference,transaction_type, total_value, general_note, datex, account_id, salesman_id, items_location_id, is_column2, is_column1, is_column3, is_qutation_status, company_id)
                        VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12, $13) RETURNING id;`;
    
          const insert = await tx.one(query1, [
            newReference_transaction_header,
            transaction_type,
            total,
            posted_elements.general_note,
            posted_elements.datex,
            posted_elements.customerId,
            posted_elements.salesmanId,
            posted_elements.itemLocationId,
            posted_elements.is_RowNote ? true : null,
            posted_elements.is_RowDiscount ? true : null,
            posted_elements.is_RowTax ? true : null,
            null,
            req.session.company_id
          ]);
    
          const newId_transaction_header = insert.id;
          let insert_array2 = []
          for (const element of posted_elements.posted_array) {
    
            //! make sure if account id != item  then location and amount = null

            if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
              await block_user(req,'Ssqa3')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }

            insert_array2.push([
              newId_transaction_header,
              +element.item_typeId,
              element.item_id,
              +element.row_amount,
              +element.row_unitPrice,
              element.row_note,
              +element.row_discountTypeId === 1? true : null,
              +element.row_discountValue,
              element.row_taxHeaderId
            ]);            
          }

          if (insert_array2.length > 0){
            let columnsCount = insert_array2[0].length;
          let query2 = `INSERT INTO befor_invoce_body
          (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
          VALUES ${insert_array2.map((_, i) => 
            `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
          ).join(', ')}`;
        
        await tx.none(query2, insert_array2.flat());
        }

          //! history
          await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø¨ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error adding sales Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });

    //#endregion sales qutation end

    //#region sales_qutation_update
    app.post("/api/sales_qutation_update", async (req, res) => {
      try {
    
        // //! Permission Ù…Ø¹Ù„Ù‚
        // await permissions(req, "transaction_permission", "add");
        // if (!permissions) {
        //   return res.status(403).json({
        //     success: false,
        //     message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        //   });
        // }



    
        const posted_elements = req.body;
        const transaction_type = 23
      
        const year = getYear(posted_elements.datex)
        //! sql injection check
        let hasBadSymbols = sql_anti_injection([
          ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
          posted_elements.x,
          posted_elements.customerId,
          posted_elements.total,
          posted_elements.datex,
          posted_elements.itemLocationId,
          posted_elements.salesmanId,
          posted_elements.is_RowNote,
          posted_elements.is_RowDiscount,
          posted_elements.general_note,
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        ]);
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar: sql_injection_message_ar,
            message_en: sql_injection_message_en,
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'update',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
       const total = +posted_elements.total

       if (!total || isNaN(total)){
        await block_user(req,'Ssqa001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
       }

    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type
          let query01 = `SELECT id, reference FROM befor_invoice_header WHERE id = $1 AND company_id = $2;`;
          let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
          
          
    
          if (!rows01 || !rows01.id) {
            return res.json({
              success: false,
              message_ar: 'âŒ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ù‡ ',
            });
          }
          const reference = rows01.reference

    // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
    let rows02 = await db.any(query02, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id,
      is_salesman: row.is_salesman
    }));

    //check salesman

    const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
    const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_salesman) {
        await block_user(req,'Ssqa01')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_itemLocation) {
        await block_user(req,'Ssqa02')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const item_typeId = rowData.item_typeId;
      const item_id = rowData.item_id;

    
      //! make sure from every account_id
      const accountExists = dbAccounts.some(item => 
        +item.id === +item_id && +item.account_type_id === +item_typeId
      );
    
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!accountExists) {
        await block_user(req,'Ssqa1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    
    
        // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
        let rows03 = await db.any(query03, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbTaxesHeaderArray = rows03.map(row => ({
          id: parseInt(row.id)
        }));
        
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const row_taxHeaderId = rowData.row_taxHeaderId;
          
          if (row_taxHeaderId){
          //! make sure from every account_id
          const taxExists = dbTaxesHeaderArray.some(item =>
            +item.id === +row_taxHeaderId
          );
          

        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!taxExists) {
            await block_user(req,'Ssqa2')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        }
    




        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let query1 = `update befor_invoice_header
                        set total_value = $1, general_note = $2, datex = $3, account_id = $4, salesman_id = $5, items_location_id = $6, is_column2 = $7, is_column1 = $8, is_column3 = $9
                        where id = $10 and company_id = $11;`;
    
          const resultQ1 = await tx.result(query1, [
            total,
            posted_elements.general_note,
            posted_elements.datex,
            posted_elements.customerId,
            posted_elements.salesmanId,
            posted_elements.itemLocationId,
            posted_elements.is_RowNote ? true : null,
            posted_elements.is_RowDiscount ? true : null,
            posted_elements.is_RowTax ? true : null,
            posted_elements.x,
            req.session.company_id
          ]);
    
          if (resultQ1.rowCount === 0) {
            throw new Error("No rows were update, rolling back sales Qutation Update.");
          }
    
          let query0 = `DELETE from befor_invoce_body where header_id = $1`
          await tx.none(query0,[posted_elements.x])

          let insert_array2 = []
          for (const element of posted_elements.posted_array) {
    
            //! make sure if account id != item  then location and amount = null

            if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
              await block_user(req,'Ssqa3')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }

            insert_array2.push([
              posted_elements.x,
              +element.item_typeId,
              element.item_id,
              +element.row_amount,
              +element.row_unitPrice,
              element.row_note,
              +element.row_discountTypeId === 1? true : null,
              +element.row_discountValue,
              element.row_taxHeaderId
            ]);
            
          }
    
          if (insert_array2.length > 0){
            let columnsCount = insert_array2[0].length;
          let query2 = `INSERT INTO befor_invoce_body
          (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
          VALUES ${insert_array2.map((_, i) => 
            `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
          ).join(', ')}`;
        
        await tx.none(query2, insert_array2.flat());
        }

          //! history
          await history(transaction_type,2,posted_elements.x,reference,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(reference);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø¨ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error updating sales Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion sales_qutation_update

    //#region sales qutation reject
    app.post("/api/sales_qutation_reject", async (req, res) => {
      try {
    
        // //! Permission
        await permissions(req, "sales_qutation_permission", "update");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 23
      
        
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'update',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
        const year = getYear(posted_elements.datex)
    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type

          const query1 = `
          SELECT 
            (SELECT count(id) 
             FROM befor_invoice_header 
             WHERE qutation_id = $1 
               AND company_id = $2 
               AND transaction_type = 24 
               AND is_deleted IS NULL) AS befor_invoice_count, 
            (SELECT count(id) 
             FROM transaction_header 
             WHERE qutation_id = $1 
               AND company_id = $2 
               AND is_deleted IS NULL) AS transaction_header_count,
            (SELECT reference 
             FROM befor_invoice_header 
             WHERE id = $1 
               AND company_id = $2
               AND transaction_type = 23 
               AND is_deleted IS NULL) AS qutation_reference
        `;
        
        const result1 = await db.oneOrNone(query1, [posted_elements.x, req.session.company_id]);
        
        if (result1.befor_invoice_count > 0 || result1.transaction_header_count > 0) {
          return res.json({
            success: false,
            message_ar: 'âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø±ÙØ¶ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØŒ Ø­ÙŠØ« ØªÙ… Ù‚Ø¨ÙˆÙ„Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙ‰ Ø§Ø­Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª.',
          });
        }
        
        if (!result1 || !result1.qutation_reference){
          await block_user(req,'Ssqr01')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }

          let query01 = `update befor_invoice_header set is_qutation_status = false WHERE id = $1 AND company_id = $2 AND is_deleted IS null;`;
          let rows01 = await db.result(query01, [posted_elements.x, req.session.company_id]);

          if (rows01.rowCount === 0) {
            await block_user(req,'Ssqr02')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }

          

        await last_activity(req);
        const new_referenceFormatting = formatFromFiveDigits(result1.qutation_reference);

        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø±ÙØ¶ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø± Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error sales_qutation_reject:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion sales qutation reject


    //#region delete sales Qutation
    app.post("/api/sales_qutation_delete", async (req, res) => {
      try {
    
        //! Permission 
        await permissions(req, "sales_qutation_permission", "delete");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 23
      
      
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    

    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: false,
          type: 'delete',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------

    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type
          let query01 = `
          SELECT reference, datex 
          FROM befor_invoice_header 
          WHERE id = $1 AND company_id = $2;
        `;
        
        let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
        
        if (!rows01) {
          await block_user(req, 'Ssqd01');
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
        
        const datex = rows01.datex;
        const reference = rows01.reference;
        
        const year = getYear(datex)

        let queries = `
          SELECT COUNT(qutation_id) AS count_qutation_id
          FROM befor_invoice_header 
          WHERE reference = $1 
            AND SUBSTRING(datex, 1, 4) = SUBSTRING($2, 1, 4);
        `;
        
        let result = await db.oneOrNone(queries, [reference, datex]);
        
        if (result.count_qutation_id > 0) {
          return res.json({
            success: false,
            message_ar: 'âŒ Ø¹ÙÙˆØ§ : Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø³Ø¹Ø± Ø§Ù„Ø¨ÙŠØ¹ Ù„Ø§Ù†Ù‡ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ',
          });
        }
        

        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let query1 = `update befor_invoice_header
                        set is_deleted = true where id = $1 and company_id = $2;`;
    
          const resultQ1 = await tx.result(query1, [
            posted_elements.x,
            req.session.company_id
          ]);
    
          if (resultQ1.rowCount === 0) {
            throw new Error("No rows were update, rolling back sales Qutation Update.");
          }
    
          let query0 = `DELETE from befor_invoce_body where header_id = $1`
          await tx.none(query0,[posted_elements.x])

          await history(transaction_type,3,posted_elements.x,reference,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(reference);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø¨ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error deleting sales Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion delete sales qutation

//#endregion sales Qutation

//#region sales order


    //#region sales order view
    app.post("/get_sales_order_Data_view", async (req, res) => {
      try {
        //! Permission  Ù…Ø¹Ù„Ù‚
        await permissions(req, "sales_order_permission", "view");
        if (!permissions) {
          return;
        }
          
    
        const posted_elements = req.body;
    
            // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
            const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar:
                  "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
              });
            }
          
              const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
              if (InValidDateFormat){
                return res.json({
                  success: false,
                  message_ar: InValidDateFormat_message_ar,
                });
              }
            
    
    
          turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
    
    
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        let query1 = `
    select 
        bih.id,
        bih.reference,
        bih.total_value,
        COALESCE(bih.general_note, '') as general_note, 
        bih.datex,
        bih.account_id as customer_id,
        ah1.account_name as customer_name,
        bih.salesman_id as salesman_id,
        ah2.account_name as salesman_name,
        CASE 
            WHEN bih.is_invoiced IS TRUE THEN 'Ù…ÙÙˆØªØ±'
            ELSE 'ØºÙŠØ± Ù…ÙÙˆØªØ±'
        END AS is_invoiced,
        bih.expire_offer_datex,
        bih.is_column2 as is_row_note_show,
        bih.is_column1 as is_row_dicount_show, 
        bih.is_column3 as is_row_tax_show, 
        CONCAT(
            tt1.doc_prefix, '-',
            SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS referenceconcat,
         bih.qutation_id,
        CONCAT(
            tt2.doc_prefix, '-',
            SUBSTRING(bih2.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih2.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS qutation_reference
         
    from
        befor_invoice_header bih
    left join accounts_header ah1 on ah1.id = bih.account_id
    left join accounts_header ah2 on ah2.id = bih.salesman_id
    left join befor_invoice_header bih2 on bih2.id = bih.qutation_id
    LEFT JOIN transaction_type tt1 ON tt1.id = bih.transaction_type
    LEFT JOIN transaction_type tt2 ON tt2.id = bih2.transaction_type
    where
        bih.company_id = $1
        AND bih.transaction_type = 24
        AND (bih.datex BETWEEN $2 AND $3) -- Ø§Ù„ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù‚ÙŠÙ… Ø¨ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù†ØµÙŠØ© ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
        AND bih.is_deleted IS NULL
    ORDER BY
        bih.datex DESC,
        bih.reference DESC;
    
    `;
    
        let data = await db.any(query1, [req.session.company_id,posted_elements.start_date, posted_elements.end_date]);
    
        res.json(data);
      } catch (error) {
        console.error("Error get_sales_order_Data_view:", error);
        res.status(500).send("Error:");
      }
    });
    
    //#endregion

    //#region add sales order
    app.post("/api/sales_order_add", async (req, res) => {
      try {
    
        // //! Permission
        await permissions(req, "sales_order_permission", "add");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 24
      
    
        //! sql injection check
        let hasBadSymbols = sql_anti_injection([
          ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
          posted_elements.customerId,
          posted_elements.total,
          posted_elements.datex,
          posted_elements.qutationReferenceId,
          posted_elements.itemLocationId,
          posted_elements.salesmanId,
          posted_elements.is_RowNote,
          posted_elements.is_RowDiscount,
          posted_elements.general_note,
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        ]);
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar: sql_injection_message_ar,
            message_en: sql_injection_message_en,
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
                

        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'add',
          tableName: false, // if type = 'update' or 'delete' only
          transaction_id: false, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
       const total = +posted_elements.total

       if (!total || isNaN(total)){
        await block_user(req,'Ssqa001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
       }

    
    // //! Security hacking  accounts id
   
       // check qutationReferenceId
       let query04;
       let rows04;
       if (posted_elements.qutationReferenceId){
         query04 = `select id, is_qutation_status from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 23 and is_deleted IS NULL`
         rows04 = await db.oneOrNone(query04, [posted_elements.qutationReferenceId, req.session.company_id])
        if (!rows04 || !rows04.id){
          await block_user(req,'Ssqa01')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
        }



    // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
    let rows02 = await db.any(query02, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id,
      is_salesman: row.is_salesman
    }));

    //check salesman

    const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
    const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_salesman) {
        await block_user(req,'Ssqa01')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_itemLocation) {
        await block_user(req,'Ssqa02')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const item_typeId = rowData.item_typeId;
      const item_id = rowData.item_id;

    
      //! make sure from every account_id
      const accountExists = dbAccounts.some(item => 
        +item.id === +item_id && +item.account_type_id === +item_typeId
      );
    
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!accountExists) {
        await block_user(req,'Ssqa1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    
    
        // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
        let rows03 = await db.any(query03, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbTaxesHeaderArray = rows03.map(row => ({
          id: parseInt(row.id)
        }));
        
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const row_taxHeaderId = rowData.row_taxHeaderId;
          
          if (row_taxHeaderId){
          //! make sure from every account_id
          const taxExists = dbTaxesHeaderArray.some(item =>
            +item.id === +row_taxHeaderId
          );
          

        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!taxExists) {
            await block_user(req,'Ssqa2')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        }
    

        
        const year = getYear(posted_elements.datex)
    

        const query001 = `SELECT MAX(reference) AS max FROM befor_invoice_header WHERE company_id = $1 AND transaction_Type = 24 AND datex LIKE '${year}-%'; -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø³Ù†Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ§Ø±ÙŠØ® `;
      const Params001 = [req.session.company_id];
      const result001 = await db.oneOrNone(query001, Params001);
      let newReference_transaction_header = 1;
      if (result001 && result001.max && result001.max > 0) {
        newReference_transaction_header = +result001.max + 1;
      }
  
        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {


          if (rows04 && rows04.is_qutation_status === null) {
            await tx.none(
              `UPDATE befor_invoice_header 
               SET is_qutation_status = true 
               WHERE id = $1 AND company_id = $2`,
              [posted_elements.qutationReferenceId, req.session.company_id]
            );
          }
          


          let query1 = `INSERT INTO befor_invoice_header
                        (reference,transaction_type, total_value, general_note, datex, account_id, salesman_id, items_location_id, is_column2, is_column1, is_column3, qutation_id, company_id)
                        VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12, $13) RETURNING id;`;
    
          const insert = await tx.one(query1, [
            newReference_transaction_header,
            transaction_type,
            total,
            posted_elements.general_note,
            posted_elements.datex,
            posted_elements.customerId,
            posted_elements.salesmanId,
            posted_elements.itemLocationId,
            posted_elements.is_RowNote ? true : null,
            posted_elements.is_RowDiscount ? true : null,
            posted_elements.is_RowTax ? true : null,
            posted_elements.qutationReferenceId,
            req.session.company_id
          ]);
    
          const newId_transaction_header = insert.id;
          let insert_array2 = []
          for (const element of posted_elements.posted_array) {
    
            //! make sure if account id != item  then location and amount = null

            if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
              await block_user(req,'Ssqa3')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }

    

            insert_array2.push([
              newId_transaction_header,
              +element.item_typeId,
              element.item_id,
              +element.row_amount,
              +element.row_unitPrice,
              element.row_note,
              +element.row_discountTypeId === 1? true : null,
              +element.row_discountValue,
              element.row_taxHeaderId
            ]);
    
          }

          if (insert_array2.length > 0){
            let columnsCount = insert_array2[0].length;
          let query2 = `INSERT INTO befor_invoce_body
          (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
          VALUES ${insert_array2.map((_, i) => 
            `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
          ).join(', ')}`;
        
        await tx.none(query2, insert_array2.flat());
        }
        
          //! history
          await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù…Ø± Ø¨ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error adding sales Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregionsales order

        //#region sales_order_update
        app.post("/api/sales_order_update", async (req, res) => {
          try {
        
            //! Permission Ù…Ø¹Ù„Ù‚
            await permissions(req, "sales_order_permission", "update");
            if (!permissions) {
              return res.status(403).json({
                success: false,
                message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
              });
            }
    
    
    
        
            const posted_elements = req.body;
            const transaction_type = 24
          
            const year = getYear(posted_elements.datex)
            //! sql injection check
            let hasBadSymbols = sql_anti_injection([
              ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
              posted_elements.x,
              posted_elements.qutation_id,
              posted_elements.customerId,
              posted_elements.total,
              posted_elements.datex,
              posted_elements.itemLocationId,
              posted_elements.salesmanId,
              posted_elements.is_RowNote,
              posted_elements.is_RowDiscount,
              posted_elements.general_note,
              // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
            ]);
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar: sql_injection_message_ar,
                message_en: sql_injection_message_en,
              });
            }
        
        
            const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
            if (InValidDateFormat) {
              return res.status(400).json({
                success: false,
                message_ar: InValidDateFormat_message_ar,
              });
            }
        
            //! settings
            const settings = await check_settings_validation({
              check_futureDate: true,
              check_closingDate: true,
              datex: posted_elements.datex,
              type: 'update',
              tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
              transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
            }, req);
        
            
            if (!settings.valid) {
              return res.json({
                success: false,
                message_ar: settings.message_ar,
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
        
            
    
            //* Start Transaction --------------------------------------------------
        
           const total = +posted_elements.total
    
           if (!total || isNaN(total)){
            await block_user(req,'Ssqa001')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
           }
    
        
        // //! Security hacking  accounts id


              //! Security hacking check id for company_name and transactio type
              if (posted_elements.qutation_id){
                let query05 = `SELECT count(id) as countQutationId FROM befor_invoice_header WHERE id = $1 AND company_id = $2;`;
                let rows05 = await db.oneOrNone(query05, [posted_elements.qutation_id, req.session.company_id]);
                if (!rows05.countQutationId === 0) {
                  await block_user(req,'Ssqa05')
                  return res.json({
                    success: false,
                    xx: true,
                    message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                  });
                }
              }
         

              let query01 = `SELECT id, reference, qutation_id FROM befor_invoice_header WHERE id = $1 AND company_id = $2;`;
              let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
              
              
        
              if (!rows01 || !rows01.id) {
                return res.json({
                  success: false,
                  message_ar: 'âŒ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ù‡ ',
                });
              }
              const reference = rows01.reference

    
        // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
        let rows02 = await db.any(query02, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbAccounts = rows02.map(row => ({
          id: parseInt(row.id),
          account_type_id: row.account_type_id,
          is_salesman: row.is_salesman
        }));
    
        //check salesman
    
        const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
        const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);
    
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!count_salesman) {
            await block_user(req,'Ssqa01')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
    
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!count_itemLocation) {
            await block_user(req,'Ssqa02')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
    
    
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const item_typeId = rowData.item_typeId;
          const item_id = rowData.item_id;
    
        
          //! make sure from every account_id
          const accountExists = dbAccounts.some(item => 
            +item.id === +item_id && +item.account_type_id === +item_typeId
          );
        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!accountExists) {
            await block_user(req,'Ssqa1')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        
        
            // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
            let rows03 = await db.any(query03, [req.session.company_id]);
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
            const dbTaxesHeaderArray = rows03.map(row => ({
              id: parseInt(row.id)
            }));
            
            // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
            for (const rowData of posted_elements.posted_array) {
              const row_taxHeaderId = rowData.row_taxHeaderId;
              
              if (row_taxHeaderId){
              //! make sure from every account_id
              const taxExists = dbTaxesHeaderArray.some(item =>
                +item.id === +row_taxHeaderId
              );
              
    
            
              // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
              if (!taxExists) {
                await block_user(req,'Ssqa2')
                return res.json({
                  success: false,
                  xx: true,
                  message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                });
              }
            }
            }
        
    
    
    
            // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            await db.tx(async (tx) => {

              //! qutation_id check and update
              const db_qutation_id = rows01.qutation_id || 0
              const posted_qutation_id = posted_elements.qutation_id || 0
              if (+db_qutation_id !== +posted_qutation_id){
                if (+db_qutation_id !== 0) {
                  const q1 = `
                    SELECT 
                      (SELECT COUNT(id) FROM befor_invoice_header WHERE id != $1 AND qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_befor_invoice_header,
                      (SELECT COUNT(id) FROM transaction_header WHERE qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                  `;                  
                  let result1 = await tx.oneOrNone(q1, [+posted_elements.x, +db_qutation_id, req.session.company_id]);                  
                  if (+result1.count_befor_invoice_header === 0 && +result1.count_transaction_header === 0) {
                    const updateQuery1 = `UPDATE befor_invoice_header SET is_qutation_status = NULL WHERE id = $1 AND company_id = $2`;
                    await tx.none(updateQuery1, [+db_qutation_id, req.session.company_id]);
                  }
                }
                if (+posted_qutation_id !== 0) {
                  const updateQuery2 = `UPDATE befor_invoice_header SET is_qutation_status = true WHERE id = $1 AND company_id = $2`;
                  await tx.none(updateQuery2, [+posted_qutation_id, req.session.company_id]);
                }
              }
              


              let query1 = `update befor_invoice_header
                            set total_value = $1, general_note = $2, datex = $3, account_id = $4, salesman_id = $5, items_location_id = $6, is_column_2 = $7, is_column1 = $8, is_column3 = $9, qutation_id = $10
                            where id = $11 and company_id = $12;`;
        
              const resultQ1 = await tx.result(query1, [
                total,
                posted_elements.general_note,
                posted_elements.datex,
                posted_elements.customerId,
                posted_elements.salesmanId,
                posted_elements.itemLocationId,
                posted_elements.is_RowNote ? true : null,
                posted_elements.is_RowDiscount ? true : null,
                posted_elements.is_RowTax ? true : null,
                posted_elements.qutation_id ? +posted_elements.qutation_id : null,
                posted_elements.x,
                req.session.company_id
              ]);
        
              if (resultQ1.rowCount === 0) {
                throw new Error("No rows were update, rolling back sales order Update.");
              }
        
              let query0 = `DELETE from befor_invoce_body where header_id = $1`
              await tx.none(query0,[posted_elements.x])
    
              let insert_array2 = []
              for (const element of posted_elements.posted_array) {
        
                //! make sure if account id != item  then location and amount = null
    
                if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
                  await block_user(req,'Ssqa3')
                  return res.json({
                    success: false,
                    xx: true,
                    message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                  });
                }
    
        

                insert_array2.push([
                  posted_elements.x,
                  +element.item_typeId,
                  element.item_id,
                  +element.row_amount,
                  +element.row_unitPrice,
                  element.row_note,
                  +element.row_discountTypeId === 1? true : null,
                  +element.row_discountValue,
                  element.row_taxHeaderId
                ]);

              }

              if (insert_array2.length > 0){
                let columnsCount = insert_array2[0].length;
              let query2 = `INSERT INTO befor_invoce_body
              (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
              VALUES ${insert_array2.map((_, i) => 
                `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
              ).join(', ')}`;
            
            await tx.none(query2, insert_array2.flat());
            }

              //! history
              await history(transaction_type,2,posted_elements.x,reference,req,tx);
            });
        
            const new_referenceFormatting = formatFromFiveDigits(reference);
            await last_activity(req);
            // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
            return res.json({
              success: true,
              message_ar: `âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù…Ø± Ø¨ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
            });
          } catch (error) {
            await last_activity(req);
            console.error("Error updating sales Order:", error);
        
            // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
            return res.json({
              success: false,
              message_ar: error.message || deafultErrorMessage,
            });
          }
        });
        //#endregion sales_order_update
    

    //#region delete sales order
    app.post("/api/sales_order_delete", async (req, res) => {
      try {
    
        //! Permission Ù…Ø¹Ù„Ù‚
        await permissions(req, "sales_order_permission", "delete");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 24
      
      
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    

    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: false,
          type: 'delete',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------

    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type
          let query01 = `
          SELECT reference, datex, qutation_id
          FROM befor_invoice_header 
          WHERE id = $1 AND company_id = $2 AND transaction_type = $3 AND is_deleted IS NULL;
        `;
        
        let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
        if (!rows01) {
          await block_user(req, 'Ssqd01');
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
        
        const datex = rows01.datex;
        const reference = rows01.reference;
        const qutation_id = rows01.qutation_id;
        
        const year = getYear(datex)

        let queries = `
          SELECT COUNT(order_id) AS count_order_id
          FROM transaction_header 
          WHERE order_id = $1 
                AND company_id = $2
                AND is_deleted IS NULL ;
        `;
        
        let result = await db.oneOrNone(queries, [posted_elements.x, req.session.company_id]);
        
        if (result.count_order_id > 0) {
          return res.json({
            success: false,
            message_ar: 'âŒ Ø¹ÙÙˆØ§ : Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø§Ù„Ø¨ÙŠØ¹ Ù„Ø§Ù†Ù‡ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ',
          });
        }
        
        

        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let result1;
          if (qutation_id){
            const q1 = `select count(id) as id_count from befor_invoice_header where id != $1 AND qutation_id = $2 and Company_id = $3 AND is_deleted IS NULL`            
            result1 = await tx.oneOrNone(q1,[+posted_elements.x, +qutation_id, req.session.company_id])            
            if (+result1.id_count === 0){    
              const q2 = `update befor_invoice_header set is_qutation_status = null where id = $1 AND company_id = $2`
              const p1 = await tx.none(q2,[+qutation_id, req.session.company_id])
            }
          }


          let query1 = `update befor_invoice_header
                        set is_deleted = true where id = $1 and company_id = $2 AND transaction_type = 24;`;
    
          const resultQ1 = await tx.result(query1, [
            posted_elements.x,
            req.session.company_id
          ]);
    
          if (resultQ1.rowCount === 0) {
            throw new Error("No rows were update, rolling back sales Qutation Update.");
          }
    
          let query0 = `DELETE from befor_invoce_body where header_id = $1`
          await tx.none(query0,[posted_elements.x])

          await history(transaction_type,3,posted_elements.x,reference,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(reference);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù…Ø± Ø¨ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error deleting sales Order:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion delete sales order

//#endregion sales order


//#region sales invoice

        //#region sales invoice view

        app.post("/get_sales_invoice_Data_view", async (req, res) => {
          try {
            
            //! Permission  
            await permissions(req, "sales_invoice_permission", "view");
            if (!permissions) {
              return;
            }
              
        
            const posted_elements = req.body;
        
                // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
                const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
                if (hasBadSymbols) {
                  return res.json({
                    success: false,
                    message_ar:
                      "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
                  });
                }
              
                  const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
                  if (InValidDateFormat){
                    return res.json({
                      success: false,
                      message_ar: InValidDateFormat_message_ar,
                    });
                  }
                
        
        
              turn_EmptyValues_TO_null(posted_elements);
            //* Start--------------------------------------------------------------
        
      /*
      -- Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ù…ÙØªÙˆØ­Ù‡
      WITH balances AS (
    SELECT 
        A.id AS customer_id,
        COALESCE(SUM(T.debit), 0) - COALESCE(SUM(T.credit), 0) AS balance
    FROM 
        accounts_header A
    LEFT JOIN 
        transaction_body T ON A.id = T.account_id
    WHERE
        A.company_id = $1
        AND A.account_type_id = 2
    GROUP BY
        A.id
),
ordered_invoices AS (
    SELECT 
        th.id AS invoice_id,
        th.account_id AS customer_id,
        th.total_value AS invoice_value,
        th.datex AS invoice_date
    FROM
        transaction_header th
    WHERE
        th.company_id = $1
        AND th.transaction_type = 3
        AND (th.datex BETWEEN $2 AND $3)
        AND th.is_deleted IS NULL
    ORDER BY
        th.account_id ASC,
        th.datex ASC,
        th.id ASC
),
distributed AS (
    SELECT
        oi.invoice_id,
        oi.customer_id,
        oi.invoice_value,
        oi.invoice_date,
        b.balance,
        GREATEST(
            0,
            LEAST(oi.invoice_value, 
                  b.balance - COALESCE(SUM(oi.invoice_value) OVER (PARTITION BY oi.customer_id ORDER BY oi.invoice_date ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING), 0)
            )
        ) AS remaining_balance
    FROM
        ordered_invoices oi
    LEFT JOIN 
        balances b ON oi.customer_id = b.customer_id
)
SELECT 
    invoice_id,
    customer_id,
    invoice_value,
    invoice_date,
    remaining_balance
FROM
    distributed
WHERE
    remaining_balance > 0
ORDER BY
    customer_id,
    invoice_date;
   
      */
         
      
        let quer1 = `
        -- 1. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡
WITH balances AS (
    SELECT 
        A.id AS customer_id, -- ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
        COALESCE(SUM(T.debit), 0) - COALESCE(SUM(T.credit), 0) AS balance -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯: (Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ù…Ø¯ÙŠÙ† - Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø¯Ø§Ø¦Ù†)
    FROM 
        accounts_header A -- Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª
    LEFT JOIN 
        transaction_body T ON A.id = T.account_id -- Ø±Ø¨Ø· Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø¨Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¹Ø¨Ø± Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø­Ø³Ø§Ø¨
    WHERE
        A.company_id = $1 -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø´Ø±ÙƒØ©
        AND A.account_type_id = 2 -- ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨ (Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡)
    GROUP BY
        A.id -- ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
),

-- 2. ØªØ±ØªÙŠØ¨ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø­Ø³Ø¨ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®
---- Ù‡Ù†Ø¶ÙŠÙ Ø§Ù„Ø§Ø¹Ù…Ø¯Ù‡ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© 3 Ù…Ø±Ø§Øª Ø¨Ø¯Ø£ Ù…Ù† Ø§Ù„Ø¬Ø²Ù‰Ø¡ Ø§Ù„ØªØ§Ù„Ù‰ ÙˆØ­ØªÙ‰ Ø§Ù„Ø§Ø®ÙŠØ±
ordered_invoices AS (
    SELECT 
        th.id as id,
        th.reference as reference,
        th.total_value AS total_value,        
        COALESCE(th.general_note, '') as general_note,
        th.datex AS datex,
        th.account_id AS customer_id,
        ah1.account_name as customer_name,
        th.salesman_id as salesman_id,
        ah2.account_name as salesman_name,
        th.due_date,
        th.is_column1 as is_row_dicount_show,
        th.is_column2 as is_row_note_show,
        th.is_column3 as is_row_tax_show,
        CONCAT(
          tt1.doc_prefix, '-',                  
          SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS referenceconcat,
        th.qutation_id,
        CONCAT(
          tt2.doc_prefix, '-',
          SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS qutation_reference,
        th.order_id,
        CONCAT(
          tt3.doc_prefix, '-',
          SUBSTRING(bih2.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih2.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS order_reference
    FROM
        transaction_header th
 
    left join accounts_header ah1 on ah1.id = th.account_id
    left join accounts_header ah2 on ah2.id = th.salesman_id
    left join befor_invoice_header bih on bih.id = th.qutation_id
    left join befor_invoice_header bih2 on bih2.id = th.order_id
    LEFT JOIN transaction_type tt1 ON tt1.id = th.transaction_type    
    LEFT JOIN transaction_type tt2 ON tt2.id = bih.transaction_type    
    LEFT JOIN transaction_type tt3 ON tt3.id = bih2.transaction_type   
    WHERE
        th.company_id = $1 -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø´Ø±ÙƒØ©
        AND th.transaction_type = 3 -- ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© (ÙØ§ØªÙˆØ±Ø© Ø¨ÙŠØ¹)
        AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
        AND th.is_deleted IS NULL -- ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø­Ø°ÙˆÙØ©
    ORDER BY
        th.account_id ASC, -- ØªØ±ØªÙŠØ¨ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
        th.datex ASC, -- Ø«Ù… Ø­Ø³Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„ÙØ§ØªÙˆØ±Ø©
        th.id ASC -- ÙˆØ£Ø®ÙŠØ±Ù‹Ø§ Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„ÙØ§ØªÙˆØ±Ø©
),

-- 3. ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø±ØµÙŠØ¯ Ø¹Ù„Ù‰ Ø§Ù„ÙÙˆØ§ØªÙŠØ±
distributed AS (
    SELECT
        oi.id,
        oi.reference,
        oi.total_value,
        COALESCE(oi.general_note, '') as general_note,
        oi.datex,
        oi.customer_id,
        oi.customer_name,
        oi.salesman_id,
        oi.salesman_name,
        oi.due_date,
        oi.is_row_dicount_show,
        oi.is_row_note_show,
        oi.is_row_tax_show,
        oi.referenceconcat,
        oi.qutation_id,
        oi.qutation_reference,
        oi.order_id,
        oi.order_reference,
        b.balance, -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ù„Ù„Ø¹Ù…ÙŠÙ„
        -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¨Ø¹Ø¯ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ù…ÙˆØ§Ù„ Ø¹Ù„Ù‰ Ø§Ù„ÙØ§ØªÙˆØ±Ø©
        CASE
            WHEN b.balance <= 0 THEN 0 -- Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ØŒ ÙŠØªÙ… ØªØ®ØµÙŠØµ 0
            ELSE
                -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø±ØµÙŠØ¯ Ù…ØªØ¨Ù‚ÙŠØŒ ÙŠØªÙ… ØªÙˆØ²ÙŠØ¹Ù‡ Ø¹Ù„Ù‰ Ø§Ù„ÙØ§ØªÙˆØ±Ø©
                GREATEST(
                    0, -- Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
                    LEAST(
                        oi.total_value, -- Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø©
                        b.balance - COALESCE(SUM(oi.total_value) OVER (PARTITION BY oi.customer_id ORDER BY oi.datex ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING), 0) -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¨Ø¹Ø¯ ØªÙˆØ²ÙŠØ¹ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
                    )
                )
        END AS remaining_balance -- Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ ÙŠØªÙ… ÙˆØ¶Ø¹ 0 ÙˆØ¥Ù„Ø§ ÙŠØªÙ… Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
    FROM
        ordered_invoices oi -- Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø±ØªØ¨Ø©
    LEFT JOIN 
        balances b ON oi.customer_id = b.customer_id -- Ø±Ø¨Ø· Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ù…Ø¹ Ø§Ù„Ø£Ø±ØµØ¯Ø©
)

-- 4. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø§Ù„ØªÙŠ Ø³ÙŠØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹Ù‡Ø§
SELECT 
    id,
    reference,
    total_value,
    COALESCE(general_note, '') as general_note,
    datex,
    customer_id,
    customer_name,
    salesman_id,
    salesman_name,
    due_date,
    is_row_dicount_show,
    is_row_note_show,
    is_row_tax_show,
    referenceconcat,
    qutation_id,
    qutation_reference,
    order_id,
    order_reference,
    CASE
      WHEN remaining_balance = 0 THEN
        'Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„'  
      WHEN due_date::DATE - $4::DATE > 0 THEN
        CASE
            WHEN remaining_balance <= 0 THEN 
                'Ù…Ø¯ÙÙˆØ¹ Ù…Ù‚Ø¯Ù…Ø§Ù‹' -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ ØµÙØ± Ø£Ùˆ Ø£Ù‚Ù„
            ELSE 
                CONCAT('ÙŠØ³ØªØ­Ù‚ Ø¨Ø¹Ø¯ ', due_date::DATE - $4::DATE, ' ÙŠÙˆÙ…') -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø±ØµÙŠØ¯ Ù…ØªØ¨Ù‚ÙŠ
        END
      WHEN due_date::DATE - $4::DATE = 0 THEN 
        'Ù…Ø³ØªØ­Ù‚ Ø§Ù„ÙŠÙˆÙ…' -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ±Ù‚ ØµÙØ±
      WHEN due_date::DATE - $4::DATE < 0 THEN 
        CONCAT('Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ø° ', ABS($4::DATE - due_date::DATE), ' ÙŠÙˆÙ…') -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ±Ù‚ Ø£Ù‚Ù„ Ù…Ù† ØµÙØ±
    END AS payment_status,
    remaining_balance -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¨Ø¹Ø¯ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø±ØµÙŠØ¯
FROM
    distributed -- Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ²Ø¹Ø©
ORDER BY
      datex DESC,
      reference desc;
    --customer_id, -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
    --datex; -- Ø«Ù… ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„ÙØ§ØªÙˆØ±Ø©

        `;
        
        // ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
        let data = await db.any(quer1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date, today]);

            res.json(data);
          } catch (error) {
            console.error("Error get_sales_invoice_Data_view:", error);
            res.status(500).send("Error:");
          }
        });
        
        //#endregion sales invoice view
    
          //#region get data for sales order add
  app.post("/get_data_for_sales_invoice_add", async (req, res) => {
    try {
      // //! Permission
      await permissions(req, "sales_invoice_add", "add");
      if (!permissions) {
        return;
      }
  
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  

   let query7 = `
select 
	bih.id,
	    CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS account_name
from
	befor_invoice_header bih
LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
where
	bih.transaction_type = 23
	and bih.company_id = $1
	and bih.is_deleted is NULL
	and bih.is_qutation_status IS NOT FALSE;
   ` 
   let params7 = [req.session.company_id]

   let query8 = `
   select 
     bih.id,
         CONCAT(
          tt.doc_prefix, '-',
           SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
           LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
       ) AS account_name
   from
     befor_invoice_header bih
    LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type 
   where
     bih.transaction_type = 24
     and bih.company_id = $1
     and bih.is_deleted is NULL
     and bih.is_invoiced is NULL;
      ` 
      let params8 = [req.session.company_id]

  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const salesQutationReferencesArray = await tx.any(query7, params7);
    const salesOederReferencesArray = await tx.any(query8, params8);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, salesQutationReferencesArray, salesOederReferencesArray };
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get Employees Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false, message_ar: error.message || deafultErrorMessage, });
    }
  });
  //#endregion get data for sales order add

  //#region sales invoice add
  app.post("/api/sales_invoice_add", async (req, res) => {
    try {
  
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_invoice_permission", "add");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }


      const posted_elements = req.body;
      const transaction_type = 3
      let items_array = []
      let locations_array = []
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.customerId,
        posted_elements.total,
        posted_elements.datex,
        posted_elements.dueDate,
        posted_elements.orderReferenceId,
        posted_elements.qutationReferenceId,
        posted_elements.itemLocationId,
        posted_elements.salesmanId,
        posted_elements.is_RowNote,
        posted_elements.is_RowDiscount,
        posted_elements.general_note,
        posted_elements.location_name,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex, posted_elements.dueDate]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'add',
        tableName: false, // if type = 'update' or 'delete' only
        transaction_id: false, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      

      //* Start Transaction --------------------------------------------------
  
     const total = +posted_elements.total

     if (!total || isNaN(total)){
      await block_user(req,'Ssia001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
     }

  
  // //! Security hacking  accounts id
 
     // check qutationReferenceId


     let query04;
     let rows04;
     if (posted_elements.qutationReferenceId){
       query04 = `select id, is_qutation_status from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 23 and is_deleted IS NULL`
       rows04 = await db.oneOrNone(query04, [posted_elements.qutationReferenceId, req.session.company_id])
      if (!rows04 || !rows04.id){
        await block_user(req,'Ssqi01')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
      }




      let query05;
      let rows05;
      if (posted_elements.orderReferenceId){
        query05 = `select count(id) as salesOrderReferenceCount from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 24 and is_deleted IS NULL AND is_invoiced IS NULL`
        rows05 = await db.oneOrNone(query05, [posted_elements.orderReferenceId, req.session.company_id])
       if (rows05.salesOrderReferenceCount === 0){
         await block_user(req,'Ssia02')
         return res.json({
           success: false,
           xx: true,
           message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
         });
       }
       }

  // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
  let rows02 = await db.any(query02, [req.session.company_id]);
  
  // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
  const dbAccounts = rows02.map(row => ({
    id: parseInt(row.id),
    account_type_id: row.account_type_id,
    is_salesman: row.is_salesman
  }));

  //check salesman

  const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
  const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_salesman) {
      await block_user(req,'Ssia03')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_itemLocation) {
      await block_user(req,'Ssia04')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


  // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
  for (const rowData of posted_elements.posted_array) {
    const item_typeId = rowData.item_typeId;
    const item_id = rowData.item_id;

  
    //! make sure from every account_id
    const accountExists = dbAccounts.some(item => 
      +item.id === +item_id && +item.account_type_id === +item_typeId
    );
  
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!accountExists) {
      await block_user(req,'Ssqa5')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    items_array.push(+rowData.item_id)
  }
  
  locations_array.push(+posted_elements.itemLocationId)
  
      // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
      let rows03 = await db.any(query03, [req.session.company_id]);
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
      const dbTaxesHeaderArray = rows03.map(row => ({
        id: parseInt(row.id)
      }));
      

      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
      for (const rowData of posted_elements.posted_array) {
        const row_taxHeaderId = rowData.row_taxHeaderId;
        
        if (row_taxHeaderId){
        //! make sure from every account_id
        const taxExists = dbTaxesHeaderArray.some(item =>
          +item.id === +row_taxHeaderId
        );
        

      
        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
        if (!taxExists) {
          await block_user(req,'Ssia6')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
      }
      }
  


      const year = getYear(posted_elements.datex)
      const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header',3, year, req);
      const newId_general_reference = await newId_fn("transaction_header", 'general_reference');



      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {
 
        if (rows04 && rows04.is_qutation_status === null) {
          await tx.none(
            `UPDATE befor_invoice_header 
             SET is_qutation_status = true 
             WHERE id = $1 AND company_id = $2`,
            [+posted_elements.qutationReferenceId, req.session.company_id]
          );
        }
        

        
        if(rows05){
          if(rows05.salesorderreferencecount && +rows05.salesorderreferencecount > 0){
            await tx.none(
              `UPDATE befor_invoice_header 
               SET is_invoiced = true 
               WHERE id = $1 AND company_id = $2`,
              [+posted_elements.orderReferenceId, req.session.company_id]
            );
          }
        }


        let query1 = `INSERT INTO transaction_header
                      (reference, company_id, transaction_type, total_value, general_note, datex, account_id, salesman_id, due_date, is_column1, is_column2, is_column3, items_location_id, order_id, qutation_id, general_reference, is_including_items)
                      VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12, $13, $14, $15, $16, $17) RETURNING id;`;
  
        const insert = await tx.one(query1, [
          newReference_transaction_header,
          req.session.company_id,
          transaction_type,
          total.toFixed(2),
          posted_elements.general_note,
          posted_elements.datex,
          posted_elements.customerId,
          posted_elements.salesmanId,
          posted_elements.dueDate,
          posted_elements.is_RowDiscount ? true : null,
          posted_elements.is_RowNote ? true : null,
          posted_elements.is_RowTax ? true : null,
          posted_elements.itemLocationId,
          posted_elements.orderReferenceId,
          posted_elements.qutationReferenceId,
          newId_general_reference,
          true
        ]);
  
        const newId_transaction_header = insert.id;

        let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
        let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')

        let other_posted_array = []
        let Val_beforTax = 0
        let taxValue = 0
        let TotalValue = 0
        let insert_array2 = []
        for (const element of posted_elements.posted_array) {
  
          //! make sure if account id != item  then location and amount = null

          if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
            await block_user(req,'Ssia7')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }

          // //! check amount
          
          
         const rowDiscountType = +element.row_discountTypeId || 0
         const rowDiscountValue= +element.row_discountValue || 0
         const rowAmount = +element.row_amount || 0
         const rowUnitePrice = +element.row_unitPrice || 0

          const Xrow_discount_value =
          rowDiscountType === 1
              ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
              : +rowDiscountValue;
              Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
              TotalValue += Val_beforTax
              

          const account_row = DeafultAccounts.filter(item => +item.id === element.item_id);
          
          if (!account_row){
            await block_user(req,'Ssia8')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }
          const account_id = +account_row[0].item_revenue_account
            
          insert_array2.push([
            newId_transaction_header,
            null,
            +Val_beforTax,
            element.row_note,
            +element.row_amount *-1,
            +element.row_unitPrice,
            +account_id,
            +element.row_discountTypeId === 1 ? true : null,
            element.row_discountValue || null,
            element.row_taxHeaderId || null,
            null,
            null,
            +element.item_typeId === 5? element.item_id : null,
            +element.item_typeId === 5? posted_elements.itemLocationId : null
          ]);

          //! check if has taxHeader
          if (element.row_taxHeaderId){
            const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
            if (taxesbodyArray){
              for (const row of taxesbodyArray){
                const taxRate = +row.tax_rate /100
                const taxMultiplier = row.is_tax_reverse ? -1 : 1;
                taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
                TotalValue += taxValue

                const newObject = {
                  taxBodyId: row.id,
                  taxHeaderId: row.settings_tax_header_id,
                  debit: taxValue < 0 ? taxValue*-1 : null,
                  credit: taxValue > 0 ? taxValue : null,
                  account_id: row.tax_account_id,
                  is_tax: true
                }
                other_posted_array.push(newObject)
              }
            }
          }
        }

          

        //! add customer row to transaction
        const newObject = {
          taxBodyId: null,
          taxHeaderId: null,
          debit: TotalValue > 0 ? TotalValue : null,
          credit: TotalValue < 0 ? TotalValue*-1 : null,
          account_id: posted_elements.customerId,
          is_tax: null
        }
        other_posted_array.push(newObject)

        //! insert the other part to transaction
        for (const object of other_posted_array){


        insert_array2.push([
          newId_transaction_header,
          +object.debit || null,
          +object.credit || null,
          null,
          null,
          null,
          +object.account_id,
          null,
          null,
          +object.taxHeaderId || null,
          +object.taxBodyId || null,
          object.is_tax,
          null,
          null
          ]);
        }
        if (insert_array2.length > 0){
          let columnsCount = insert_array2[0].length;
        let query2 = `INSERT INTO transaction_body
        (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id,  is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
        VALUES ${insert_array2.map((_, i) => 
          `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
        ).join(', ')}`;
      
      await tx.none(query2, insert_array2.flat());
      }
      
        //! history
        const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
        if (!allow_amounts){
          throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
        } else if (allow_amounts !== true) {
          throw new Error(allow_amounts);
        }

        await update_items_cogs(items_array,posted_elements.datex, req, tx)
        await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
      });
  
      // await update_items_cogs(req,items_array,posted_elements.datex)
      const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙØ§ØªÙˆØ±Ø© Ù…Ø¨ÙŠØ¹Ø§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error adding sales Invoice:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message,
      });
    }
  });
  //#endregionsales invoice add

  //#region get data for invoice_update_page
  app.post("/get_data_for_sales_invoice_update", async (req, res) => {
    try {
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_invoice_permission", "update");
      if (!permissions) {
        return;
      }
  
      
      const posted_elements = req.body;
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      const transaction_type = 3

      
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    AND is_inactive IS NULL
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
      AND ah.is_inactive IS NULL
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  
  
  let query7 = `
  select 
    th.id,
    th.reference,
    COALESCE(th.general_note, '') as general_note,
    th.datex,
    th.due_date,
    th.account_id,
    th.salesman_id,
    th.qutation_id,
    th.order_id,
    th.is_delivered,
    th.items_location_id,
    th.is_column1 as is_row_dicount_show,
    th.is_column2 as is_row_note_show,
    th.is_column3 as is_row_tax_show,
    CONCAT(
      tt1.doc_prefix, '-',
      SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    CONCAT(
      tt2.doc_prefix, '-',
      SUBSTRING(bih_qutation.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(bih_qutation.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat_qutation,
    CONCAT(
      tt3.doc_prefix, '-',
      SUBSTRING(bih_order.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(bih_order.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat_order
  from
    transaction_header th
	left join befor_invoice_header bih_qutation on bih_qutation.id = th.qutation_id
	left join befor_invoice_header bih_order on bih_order.id = th.order_id
  LEFT JOIN transaction_type tt1 ON tt1.id = th.transaction_type
  LEFT JOIN transaction_type tt2 ON tt2.id = bih_qutation.transaction_type
  LEFT JOIN transaction_type tt3 ON tt3.id = bih_order.transaction_type
  where 
  th.id = $1
  and th.company_id = $2
  and th.transaction_type = $3
  AND th.is_deleted IS NULL
  `
  let params7 = [posted_elements.x, req.session.company_id, transaction_type];
  
  let query8 = `
  select
    tb.id,
    tb.item_id,
      ah.account_name,
      ah.item_unite,
      ah.account_type_id as item_type_id,
    ABS(tb.item_amount) AS amount,
    tb.item_price as unite_price,
    COALESCE(tb.row_note, '') as row_note,
    tb.is_discount_percentage,
    tb.dicount_value,
    tb.settings_tax_header_id as tax_header_id,
      sth.taxe_package_name
  from
    transaction_body tb
  LEFT JOIN accounts_header ah on ah.id = tb.item_id
  LEFT JOIN settings_tax_header sth on sth.id = tb.settings_tax_header_id
  left join account_type at on at.id = ah.account_type_id
  where 
    tb.transaction_header_id = $1
    AND tb.item_id is NOT NULL
    ;
  `
  let params8 = [posted_elements.x]
  
  
  let query9 = `
  select 
    bih.id,
        CONCAT(
          tt.doc_prefix, '-',
          SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
          LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS account_name
  from
    befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
  where
    bih.transaction_type = 23
    and bih.company_id = $1
    and bih.is_deleted is NULL
    and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
     ` 
     qutationId = isNaN(+posted_elements.qutationId) ? null : posted_elements.qutationId

     let params9 = [req.session.company_id, qutationId]
  
     let query10 = `
     select 
       bih.id,
           CONCAT(
              tt.doc_prefix, '-',
             SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
             LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
         ) AS account_name
     from
       befor_invoice_header bih
       LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
     where
       bih.transaction_type = 24
       and bih.company_id = $1
       and bih.is_deleted is NULL
       and (bih.is_invoiced IS NULL or bih.id = $2);
        ` 
        
        
        orderId = isNaN(+posted_elements.orderId) ? null : posted_elements.orderId
        let params10 = [req.session.company_id, orderId]
  
  
  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const headerData = await tx.any(query7, params7);
    const bodyData = await tx.any(query8, params8);
    const salesQutationReferencesArray = await tx.any(query9, params9);
    const salesOrderReferencesArray = await tx.any(query10, params10);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, headerData, bodyData, salesQutationReferencesArray, salesOrderReferencesArray};
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get_data_for_sales_invoice_update  Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false, message_ar: error.message || deafultErrorMessage,});
    }
  });

  app.post("/get_data_for_qutationToInvoice", async (req, res) => {
    try {
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_invoice_permission", "add");
      if (!permissions) {
        return;
      }
  
      
      const posted_elements = req.body;
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      const transaction_type = 23

  
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    AND is_inactive IS NULL
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
      AND ah.is_inactive IS NULL
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  
  
  let query7 = `
  select 
    bih.id,
    bih.reference,
    COALESCE(bih.general_note, '') as general_note,
    bih.datex,
    NULL as due_date,
    bih.account_id,
    bih.salesman_id,
    bih.qutation_id,
    bih.is_delivered,
    bih.items_location_id,
    bih.is_column2 as is_row_note_show,
    bih.is_column1 as is_row_dicount_show, 
    bih.is_column3 as is_row_tax_show, 
    CONCAT(
      tt1.doc_prefix, '-',
      SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    CONCAT(
      tt2.doc_prefix, '-',
      SUBSTRING(qt.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(qt.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat_qutation,
	NULL AS referenceconcat_order
  from
    befor_invoice_header bih
    left join befor_invoice_header qt on qt.id = bih.qutation_id
    LEFT JOIN transaction_type tt1 ON tt1.id = bih.transaction_type
    LEFT JOIN transaction_type tt2 ON tt2.id = qt.transaction_type
  where 
  bih.id = $1
  and bih.company_id = $2
  and bih.transaction_type = $3
  AND bih.is_deleted IS NULL
  `
  let params7 = [posted_elements.x, req.session.company_id, transaction_type];
  
  let query8 = `
  select
    bib.id,
    bib.item_id,
      ah.account_name,
      ah.item_unite,
      ah.account_type_id as item_type_id,
    bib.amount as amount,
    bib.unite_price as unite_price,
    COALESCE(bib.row_note, '') as row_note,
    bib.is_discount_percentage,
    bib.dicount_value,
    bib.tax_header_id as tax_header_id,
      sth.taxe_package_name
  from
    befor_invoce_body bib
  LEFT JOIN accounts_header ah on ah.id = bib.item_id
  LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id
  left join account_type at on at.id = ah.account_type_id
  where 
    bib.header_id = $1
    ;
  `
  let params8 = [posted_elements.x]
  
  
  let query9 = `
  select 
    bih.id,
        CONCAT(
          tt.doc_prefix, '-',
          SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
          LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS account_name
  from
    befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
  where
    bih.transaction_type = 23
    and bih.company_id = $1
    and bih.is_deleted is NULL
    and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
     ` 
     qutation_id = isNaN(+posted_elements.x) ? null : posted_elements.x

     let params9 = [req.session.company_id, qutation_id]
  
     let query10 = `
     select 
       bih.id,
           CONCAT(
              tt.doc_prefix, '-',
             SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
             LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
         ) AS account_name
     from
       befor_invoice_header bih
      LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type 
     where
       bih.transaction_type = 24
       and bih.company_id = $1
       and bih.is_deleted is NULL
       and (bih.is_invoiced IS NULL or bih.id = $2);
        ` 
        
        // order_id = isNaN(+posted_elements.order_id) ? null : posted_elements.order_id
        order_id = null
        
        let params10 = [req.session.company_id, order_id]
  
  
  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const headerData = await tx.any(query7, params7);
    const bodyData = await tx.any(query8, params8);
    const salesQutationReferencesArray = await tx.any(query9, params9);
    const salesOrderReferencesArray = await tx.any(query10, params10);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, headerData, bodyData, salesQutationReferencesArray, salesOrderReferencesArray};
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get_data_for_sales_invoice_update  Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false,message_ar: error.message || deafultErrorMessage,});
    }
  });


  app.post("/get_data_for_orderToInvoice", async (req, res) => {
    try {
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_invoice_permission", "add");
      if (!permissions) {
        return;
      }
  
      
      const posted_elements = req.body;
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      const transaction_type = 24

  
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    AND is_inactive IS NULL
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
      AND ah.is_inactive IS NULL
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  
  
  let query7 = `
  select 
    bih.id,
    bih.reference,
    COALESCE(bih.general_note, '') as general_note,
    bih.datex,
    NULL as due_date,
    bih.account_id,
    bih.salesman_id,
    bih.qutation_id,
    bih.is_delivered,
    bih.items_location_id,
    bih.is_column2 as is_row_note_show,
    bih.is_column1 as is_row_dicount_show, 
    bih.is_column3 as is_row_tax_show, 
    CONCAT(
      tt1.doc_prefix, '-',
      SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    CONCAT(
      tt2.doc_prefix, '-',
      SUBSTRING(qt.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(qt.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat_qutation,
	NULL AS referenceconcat_order
  from
    befor_invoice_header bih
    left join befor_invoice_header qt on qt.id = bih.qutation_id
    LEFT JOIN transaction_type tt1 ON tt1.id = bih.transaction_type
    LEFT JOIN transaction_type tt2 ON tt2.id = qt.transaction_type
  where 
  bih.id = $1
  and bih.company_id = $2
  and bih.transaction_type = $3
  AND bih.is_deleted IS NULL
  `

  
  let params7 = [posted_elements.x, req.session.company_id, transaction_type];
  
  let query8 = `
  select
    bib.id,
    bib.item_id,
      ah.account_name,
      ah.item_unite,
      ah.account_type_id as item_type_id,
    bib.amount as amount,
    bib.unite_price as unite_price,
    COALESCE(bib.row_note, '') as row_note,
    bib.is_discount_percentage,
    bib.dicount_value,
    bib.tax_header_id as tax_header_id,
      sth.taxe_package_name
  from
    befor_invoce_body bib
  LEFT JOIN accounts_header ah on ah.id = bib.item_id
  LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id
  left join account_type at on at.id = ah.account_type_id
  where 
    bib.header_id = $1
    ;
  `
  let params8 = [posted_elements.x]
  
  
  let query9 = `
  select 
    bih.id,
        CONCAT(
          tt.doc_prefix, '-',
          SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
          LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS account_name
  from
    befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
  where
    bih.transaction_type = 23
    and bih.company_id = $1
    and bih.is_deleted is NULL
    and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
     ` 
     qutation_id = isNaN(+posted_elements.qutationId) ? null : posted_elements.qutationId

     let params9 = [req.session.company_id, qutation_id]
  
     let query10 = `
     select 
       bih.id,
           CONCAT(
              tt.doc_prefix, '-',
             SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
             LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
         ) AS account_name
     from
       befor_invoice_header bih
       LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
     where
       bih.transaction_type = 24
       and bih.company_id = $1
       and bih.is_deleted is NULL
       and (bih.is_invoiced IS NULL or bih.id = $2);
        ` 
        
        order_id = isNaN(+posted_elements.x) ? null : posted_elements.x
        
        let params10 = [req.session.company_id, order_id]
  
  
  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const headerData = await tx.any(query7, params7);
    const bodyData = await tx.any(query8, params8);
    const salesQutationReferencesArray = await tx.any(query9, params9);
    const salesOrderReferencesArray = await tx.any(query10, params10);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, headerData, bodyData, salesQutationReferencesArray, salesOrderReferencesArray};
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get_data_for_sales_invoice_update  Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false, message_ar: error.message || deafultErrorMessage, });
    }
  });
  //#endregion end - get data for invoice_update_page

  //#region sales invoice update
  app.post("/api/sales_invoice_update", async (req, res) => {
    try {
  
      // //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_invoice_permission", "update");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }



  
      const posted_elements = req.body;
      const transaction_type = 3
      let items_array = []
      let locations_array = []
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.x,
        posted_elements.customerId,
        posted_elements.total,
        posted_elements.datex,
        posted_elements.dueDate,
        posted_elements.orderReferenceId,
        posted_elements.qutationReferenceId,
        posted_elements.itemLocationId,
        posted_elements.salesmanId,
        posted_elements.is_RowNote,
        posted_elements.is_RowDiscount,
        posted_elements.general_note,
        posted_elements.location_name,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex, posted_elements.dueDate]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'update',
        tableName: 'transaction_header', // if type = 'update' or 'delete' only
        transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      

      //* Start Transaction --------------------------------------------------
  
     const total = +posted_elements.total

     if (!total || isNaN(total)){
      await block_user(req,'Ssiu001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
     }

  
  // //! Security hacking  accounts id
 
     // check qutationReferenceId

     let query_1 = `select reference from transaction_header where id = $1 AND company_id = $2 AND is_deleted IS NULL`
     const result_1 = await db.oneOrNone(query_1,[posted_elements.x, req.session.company_id])
     if (!result_1){
      await block_user(req,'Ssqu02')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
     }


     let query04;
     let rows04;
     if (posted_elements.qutationReferenceId){      
       query04 = `select id, is_qutation_status from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 23 and is_deleted IS NULL`
       rows04 = await db.oneOrNone(query04, [posted_elements.qutationReferenceId, req.session.company_id])
      if (!rows04 || !rows04.id){
        await block_user(req,'Ssqu03')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
      }




      let query05;
      let rows05;
      if (posted_elements.orderReferenceId){
        query05 = `select count(id) as salesOrderReferenceCount from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 24 and is_deleted IS NULL AND is_invoiced IS NULL`
        rows05 = await db.oneOrNone(query05, [posted_elements.orderReferenceId, req.session.company_id])
       if (rows05.salesOrderReferenceCount === 0){
         await block_user(req,'Ssiau04')
         return res.json({
           success: false,
           xx: true,
           message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
         });
       }
       }

  // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
  let rows02 = await db.any(query02, [req.session.company_id]);
  
  // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
  const dbAccounts = rows02.map(row => ({
    id: parseInt(row.id),
    account_type_id: row.account_type_id,
    is_salesman: row.is_salesman
  }));

  //check salesman

  const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
  const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_salesman) {
      await block_user(req,'Ssqu05')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_itemLocation) {
      await block_user(req,'Ssqu06')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


  // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
  for (const rowData of posted_elements.posted_array) {
    const item_typeId = rowData.item_typeId;
    const item_id = rowData.item_id;

  
    //! make sure from every account_id
    const accountExists = dbAccounts.some(item => 
      +item.id === +item_id && +item.account_type_id === +item_typeId
    );
  
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!accountExists) {
      await block_user(req,'Ssqu07')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    items_array.push(+rowData.item_id)
  }
  
  locations_array.push(+posted_elements.itemLocationId)
  
      // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
      let rows03 = await db.any(query03, [req.session.company_id]);
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
      const dbTaxesHeaderArray = rows03.map(row => ({
        id: parseInt(row.id)
      }));
      

      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
      for (const rowData of posted_elements.posted_array) {
        const row_taxHeaderId = rowData.row_taxHeaderId;
        
        if (row_taxHeaderId){
        //! make sure from every account_id
        const taxExists = dbTaxesHeaderArray.some(item =>
          +item.id === +row_taxHeaderId
        );
        

      
        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
        if (!taxExists) {
          await block_user(req,'Ssqu08')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
      }
      }
   
      const year = getYear(posted_elements.datex)

      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {

        let query01 = `SELECT qutation_id, order_id FROM transaction_header WHERE id = $1 AND company_id = $2 AND is_deleted IS NULL;`;
        let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
        
 

              //! qutation_id check and update
              const db_qutation_id = rows01.qutation_id || 0
              const posted_qutation_id = posted_elements.qutationReferenceId || 0
              if (+db_qutation_id !== +posted_qutation_id){
                if (+db_qutation_id !== 0) {
                  const q1 = `
                    SELECT 
                      (SELECT COUNT(id) FROM befor_invoice_header WHERE qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_befor_invoice_header,
                      (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                  `;                  
                  let result1 = await tx.oneOrNone(q1, [+posted_elements.x, +db_qutation_id, req.session.company_id]);                  
                  if (+result1.count_befor_invoice_header === 0 && +result1.count_transaction_header === 0) {
                    const updateQuery1 = `UPDATE befor_invoice_header SET is_qutation_status = NULL WHERE id = $1 AND company_id = $2`;
                    await tx.none(updateQuery1, [+db_qutation_id, req.session.company_id]);
                  }
                }
                if (+posted_qutation_id !== 0) {
                  const updateQuery2 = `UPDATE befor_invoice_header SET is_qutation_status = true WHERE id = $1 AND company_id = $2`;
                  await tx.none(updateQuery2, [+posted_qutation_id, req.session.company_id]);
                }
              }


              //! order_id check and update
              const db_order_id = rows01.order_id || 0
              const posted_order_id = posted_elements.orderReferenceId || 0
              if (+db_order_id !== +posted_order_id){
                if (+db_order_id !== 0) {
                  const q01 = `
                    SELECT 
                      (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND order_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                  `;                  
                  let result01 = await tx.oneOrNone(q01, [+posted_elements.x, +db_order_id, req.session.company_id]);                  
                  if (+result01.count_transaction_header === 0) {
                    const updateQuery01 = `UPDATE befor_invoice_header SET is_invoiced = NULL WHERE id = $1 AND company_id = $2`;
                    await tx.none(updateQuery01, [+db_order_id, req.session.company_id]);
                  }
                }
                if (+posted_order_id !== 0) {
                  const updateQuery02 = `UPDATE befor_invoice_header SET is_invoiced = true WHERE id = $1 AND company_id = $2`;
                  await tx.none(updateQuery02, [+posted_order_id, req.session.company_id]);
                }
              }              


        let query1 = `update transaction_header
                      set total_value = $1,
                        general_note = $2,
                        datex = $3,
                        account_id = $4,
                        salesman_id = $5,
                        due_date = $6,
                        is_column1 = $7,
                        is_column2 = $8,
                        is_column3 = $9,
                        items_location_id = $10,
                        order_id = $11,
                        qutation_id = $12
                      Where
                        id = $13
                        AND company_id = $14
                      ;`;
  
        await tx.none(query1, [
          total.toFixed(2),
          posted_elements.general_note,
          posted_elements.datex,
          posted_elements.customerId,
          posted_elements.salesmanId,
          posted_elements.dueDate,
          posted_elements.is_RowDiscount ? true : null,
          posted_elements.is_RowNote ? true : null,
          posted_elements.is_RowTax ? true : null,
          posted_elements.itemLocationId,
          posted_elements.orderReferenceId,
          posted_elements.qutationReferenceId,
          posted_elements.x,
          req.session.company_id
        ]);
  
        const query_delete = `delete from transaction_body where transaction_header_id = $1`
        await tx.none(query_delete,[posted_elements.x])

        let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
        let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')

        let other_posted_array = []
        let Val_beforTax = 0
        let taxValue = 0
        let TotalValue = 0
        let insert_array2 = []
        for (const element of posted_elements.posted_array) {
  
          //! make sure if account id != item  then location and amount = null

          if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
            await block_user(req,'Ssia3')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }

          
         const rowDiscountType = +element.row_discountTypeId || 0
         const rowDiscountValue= +element.row_discountValue || 0
         const rowAmount = +element.row_amount || 0
         const rowUnitePrice = +element.row_unitPrice || 0

          const Xrow_discount_value =
          rowDiscountType === 1
              ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
              : +rowDiscountValue;
              Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
              TotalValue += Val_beforTax
              

          const account_row = DeafultAccounts.filter(item => +item.id === element.item_id);
          
          if (!account_row){
            await block_user(req,'Ssia4')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }
          const account_id = +account_row[0].item_revenue_account
          
          
  
          insert_array2.push([
            posted_elements.x,
            null,
            +Val_beforTax,
            element.row_note,
            +element.row_amount *-1,
            +element.row_unitPrice,
            +account_id,
            +element.row_discountTypeId === 1 ? true : null,
            element.row_discountValue || null,
            element.row_taxHeaderId || null,
            null,
            null,
            +element.item_typeId === 5? element.item_id : null,
            +element.item_typeId === 5? posted_elements.itemLocationId : null
          ]);

          //! check if has taxHeader
          if (element.row_taxHeaderId){
            const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
            if (taxesbodyArray){
              for (const row of taxesbodyArray){
                const taxRate = +row.tax_rate /100
                const taxMultiplier = row.is_tax_reverse ? -1 : 1;
                taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
                TotalValue += taxValue

                const newObject = {
                  taxBodyId: row.id,
                  taxHeaderId: row.settings_tax_header_id,
                  debit: taxValue < 0 ? taxValue*-1 : null,
                  credit: taxValue > 0 ? taxValue : null,
                  account_id: row.tax_account_id,
                  is_tax: true
                }
                other_posted_array.push(newObject)
              }
            }
          }
        }

          

        //! add customer row to transaction
        const newObject = {
          taxBodyId: null,
          taxHeaderId: null,
          debit: TotalValue > 0 ? TotalValue : null,
          credit: TotalValue < 0 ? TotalValue*-1 : null,
          account_id: posted_elements.customerId,
          is_tax: null
        }
        other_posted_array.push(newObject)

        //! insert the other part to transaction
        for (const object of other_posted_array){

          insert_array2.push([
          posted_elements.x,
          +object.debit || null,
          +object.credit || null,
          null,
          null,
          null,
          +object.account_id,
          null,
          null,
          +object.taxHeaderId || null,
          +object.taxBodyId || null,
          object.is_tax,
          null,
          null
          ]);
        }
  
        if (insert_array2.length > 0){
          let columnsCount = insert_array2[0].length;
        let query2 = `INSERT INTO transaction_body
        (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id,  is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
        VALUES ${insert_array2.map((_, i) => 
          `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
        ).join(', ')}`;
      
      await tx.none(query2, insert_array2.flat());
      }

      const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
      if (!allow_amounts){
        throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
      } else if (allow_amounts !== true) {
        throw new Error(allow_amounts);
      }
        //! history
        await update_items_cogs(items_array,posted_elements.datex, req, tx)
        await history(transaction_type,2,posted_elements.x,result_1.reference,req,tx);
      });
  
      // await update_items_cogs(req,items_array,posted_elements.datex)
      const new_referenceFormatting = formatFromFiveDigits(result_1.reference);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„  ÙØ§ØªÙˆØ±Ø© Ù…Ø¨ÙŠØ¹Ø§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error sales_invouce_update:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#endregion sales invoice update

  //#region delete sales invoice
  app.post("/api/sales_invoice_delete", async (req, res) => {
    try {
  
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_invoice_permission", "delete");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }



  
      const posted_elements = req.body;
      const transaction_type = 3
    
  
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'delete',
        tableName: 'transaction_header', // if type = 'update' or 'delete' only
        transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      

      //* Start Transaction --------------------------------------------------
  

  
  // //! Security hacking  accounts id
 
 
      let query1 = `select reference, datex from transaction_header where id = $1 and company_id = $2 and is_deleted IS NULL `
      let result1 = await db.oneOrNone(query1,[posted_elements.x, req.session.company_id])

      if (!result1){
        await block_user(req,'Ssid001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
      
      const year = getYear(result1.datex)


      let query2 = `select item_id from transaction_body where transaction_header_id = $1 AND item_id IS NOT NULL`;
      let result2 = await db.any(query2, [posted_elements.x]);
      
      if (!result2 || result2.length === 0) {
        await block_user(req, 'Ssid002');
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ø£Ø±Ù‚Ø§Ù…
      const items_array = result2.map(row => row.item_id);
      
    
      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {


        let query01 = `SELECT qutation_id, order_id FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = 3 AND is_deleted IS NULL;`;
        let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
        
 

              //! qutation_id check and update
              const db_qutation_id = rows01.qutation_id || 0
                if (+db_qutation_id !== 0) {
                  const q1 = `
                    SELECT 
                      (SELECT COUNT(id) FROM befor_invoice_header WHERE qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_befor_invoice_header,
                      (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                  `;                  
                  let result1 = await tx.oneOrNone(q1, [+posted_elements.x, +db_qutation_id, req.session.company_id]);                  
                  if (+result1.count_befor_invoice_header === 0 && +result1.count_transaction_header === 0) {
                    const updateQuery1 = `UPDATE befor_invoice_header SET is_qutation_status = NULL WHERE id = $1 AND company_id = $2`;
                    await tx.none(updateQuery1, [+db_qutation_id, req.session.company_id]);
                  }
                }



              //! order_id check and update
              const db_order_id = rows01.order_id || 0
                if (+db_order_id !== 0) {
                  const q01 = `
                    SELECT 
                      (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND order_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                  `;                  
                  let result01 = await tx.oneOrNone(q01, [+posted_elements.x, +db_order_id, req.session.company_id]);                  
                  if (+result01.count_transaction_header === 0) {
                    const updateQuery01 = `UPDATE befor_invoice_header SET is_invoiced = NULL WHERE id = $1 AND company_id = $2`;
                    await tx.none(updateQuery01, [+db_order_id, req.session.company_id]);
                  }
                }



        let query1 = `update transaction_header
                      set is_deleted = true
                      Where
                        id = $1
                        AND company_id = $2
                        AND transaction_type = 3
                      ;`;
  
                    
            
            

        const resultQ1 = await tx.result(query1, [
          posted_elements.x,
          req.session.company_id
        ]);

        if (resultQ1.rowCount === 0) {
          await block_user(req,'Ssid1')
          throw new Error(
            'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
          );
        }
  
        const query_delete = `delete from transaction_body where transaction_header_id = $1`
        await tx.none(query_delete,[posted_elements.x])


        //! history
        await update_items_cogs(items_array,result1.datex, req, tx)
        await history(transaction_type,3,posted_elements.x,result1.reference,req,tx);
      });

      // await update_items_cogs(req,items_array,result1.datex)
      const new_referenceFormatting = formatFromFiveDigits(result1.reference);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø­Ø°Ù  ÙØ§ØªÙˆØ±Ø© Ù…Ø¨ÙŠØ¹Ø§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error sales_invouce_delete:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });
  //#endregion
//#endregion sales invoice

//#region purshases

  //#region purshases Qutation

//#region 1: sales_qutation_view
app.post("/get_purshases_qutation_Data_view", async (req, res) => {
  try {
    
    //! Permission
    await permissions(req, "purshases_qutation_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
select 
    bih.id,
    bih.reference,
    bih.total_value,
    COALESCE(bih.general_note, '') as general_note, 
    bih.datex,
    bih.account_id as vendor_id,
    ah1.account_name as vendor_name,
    CASE 
        WHEN bih.is_qutation_status IS TRUE THEN 'Ù…Ù‚Ø¨ÙˆÙ„'
        WHEN bih.is_qutation_status IS NULL THEN 'Ù…Ø¹Ù„Ù‚'
        ELSE 'Ù…Ø±ÙÙˆØ¶'
    END AS qutation_status,
    bih.expire_offer_datex,
    bih.is_column2 as is_row_note_show,
    bih.is_column1 as is_row_dicount_show, 
    bih.is_column3 as is_row_tax_show, 
    CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat
from
    befor_invoice_header bih
left join accounts_header ah1 on ah1.id = bih.account_id
LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type
where
    bih.company_id = $1
    AND bih.transaction_type = 25
    AND (bih.datex BETWEEN $2 AND $3) -- Ø§Ù„ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù‚ÙŠÙ… Ø¨ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù†ØµÙŠØ© ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    AND bih.is_deleted IS NULL
ORDER BY
    bih.datex DESC,
    bih.reference DESC;

`;

    let data = await db.any(query1, [req.session.company_id,posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_purshases_qutation_Data_view:", error);
    res.status(500).send("Error:");
  }
});


app.post("/get_Data_for_purshases_qutation_add_page", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "purshases_qutation_ViewArray", "add"); // Ù…Ø¹Ù„Ù‚
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 7
  ;
`;
let params1 = [req.session.company_id]

/*
let query2 = `
  select
	id as id,
	account_name as account_name
from
	accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4
  AND is_final_account IS true
  and is_salesman IS true
  AND is_inactive IS null
  ;
`
let params2 = [req.session.company_id]
*/

let query3 = `
    select 
	th.id,
	th.taxe_package_name as account_name
from
 	settings_tax_header th
where
	th.company_id = $1
	and th.is_inactive is null
order by
	th.taxe_package_name asc 
 
`
let params3 = [req.session.company_id]

let query4 = `
select
    tb.id,
    tb.tax_name,
    tb.tax_rate,
    tb.is_tax_reverse,
    tb.tax_account_id,
    ah.account_name,
    tb.settings_tax_header_id
from
    settings_tax_body tb
left join accounts_header ah on ah.id = tb.tax_account_id    
where
    tb.settings_tax_header_id = ANY($1::int[])
`;


let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
`;

let params5 = [req.session.company_id];


let query6 = `
select
  ah.id,
  ah.account_name
from
  accounts_header ah
where
  ah.company_id = $1
  AND ah.is_final_account is true
  AND is_inactive is null
  AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`

  let params6 = [req.session.company_id];

await db.tx(async (tx) => {

  const itemslocationsArray = await tx.any(query1, params1);
  // const salesmanArray = await tx.any(query2, params2);
  const taxHeaderArray = await tx.any(query3, params3);
  const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
  const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
  const itemsDataArray = await tx.any(query5, params5);
  const vendorsDataArray = await tx.any(query6, params6);

  const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray };
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_Data_for_purshases_qutation_add_page", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});
/*
app.post("/getItemssData1", async (req, res) => {
  try {
    // //! Permission
    // await permissions(req, "effects_permission", "view");
    // if (!permissions) {
    //   return;
    // }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
    SELECT
      A.id,
      A.account_name,
      A.account_type_id,
      COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite 
    FROM
      accounts_header A
    WHERE
      A.company_id = $1
      AND is_final_account = true
      AND account_type_id IN (5, 8)
    `;
    
    let data = await db.any(query1, [req.session.company_id]);

    // const data = rows.map((row) => ({
    //   id: row.id,
    //   account_name: row.account_name,
    //   account_type: row.account_type_id
    // }));
    res.json(data);
  } catch (error) {
    console.error("Error while get accounts Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: "âŒ Error while get accounts Data" });
  }
});
*/
//#endregion


    //#region purshases qutation add
    app.post("/api/purshases_qutation_add", async (req, res) => {
      try {
    
        //! Permission Ù…Ø¹Ù„Ù‚
        await permissions(req, "purshases_qutation_permission", "add");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 25
      
    
        //! sql injection check
        let hasBadSymbols = sql_anti_injection([
          ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
          posted_elements.vendorId,
          posted_elements.total,
          posted_elements.datex,
          posted_elements.itemLocationId,
          // posted_elements.salesmanId,
          posted_elements.is_RowNote,
          posted_elements.is_RowDiscount,
          posted_elements.general_note,
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        ]);
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar: sql_injection_message_ar,
            message_en: sql_injection_message_en,
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'add',
          tableName: false, // if type = 'update' or 'delete' only
          transaction_id: false, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
       const total = +posted_elements.total

       if (!total || isNaN(total)){
        await block_user(req,'Ssqa001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
       }

    
    // //! Security hacking  accounts id


    // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
    let rows02 = await db.any(query02, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id,
      // is_salesman: row.is_salesman
    }));

    //check salesman

    // const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
    

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      /*
      if (!count_salesman) {
        await block_user(req,'Spqa01')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
        */

      const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_itemLocation) {
        await block_user(req,'Spqa02')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const item_typeId = rowData.item_typeId;
      const item_id = rowData.item_id;

    
      //! make sure from every account_id
      const accountExists = dbAccounts.some(item => 
        +item.id === +item_id && +item.account_type_id === +item_typeId
      );
    
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!accountExists) {
        await block_user(req,'Spqa1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    
    
        // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
        let rows03 = await db.any(query03, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbTaxesHeaderArray = rows03.map(row => ({
          id: parseInt(row.id)
        }));
        
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const row_taxHeaderId = rowData.row_taxHeaderId;
          
          if (row_taxHeaderId){
          //! make sure from every account_id
          const taxExists = dbTaxesHeaderArray.some(item =>
            +item.id === +row_taxHeaderId
          );
          

        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!taxExists) {
            await block_user(req,'Spqa2')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        }
    

        
        const year = getYear(posted_elements.datex)
        
        const query001 = `SELECT MAX(reference) AS max FROM befor_invoice_header WHERE company_id = $1 AND transaction_Type = 25 AND datex LIKE '${year}-%'; -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø³Ù†Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ§Ø±ÙŠØ® `;
      const Params001 = [req.session.company_id];
      const result001 = await db.oneOrNone(query001, Params001);
      let newReference_transaction_header = 1;
      if (result001 && result001.max && result001.max > 0) {
        newReference_transaction_header = +result001.max + 1;
      }
          
        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let query1 = `INSERT INTO befor_invoice_header
                        (reference,transaction_type, total_value, general_note, datex, account_id, items_location_id, is_column2, is_column1, is_column3, is_qutation_status, company_id)
                        VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12) RETURNING id;`;
    
          const insert = await tx.one(query1, [
            newReference_transaction_header,
            transaction_type,
            total,
            posted_elements.general_note,
            posted_elements.datex,
            posted_elements.vendorId,
            posted_elements.itemLocationId,
            posted_elements.is_RowNote ? true : null,
            posted_elements.is_RowDiscount ? true : null,
            posted_elements.is_RowTax ? true : null,
            null,
            req.session.company_id
          ]);
    
          const newId_transaction_header = insert.id;
            let insert_array2 = []
          for (const element of posted_elements.posted_array) {
    
            //! make sure if account id != item  then location and amount = null

            if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
              await block_user(req,'Spqa3')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }

    
            insert_array2.push([
              newId_transaction_header,
              +element.item_typeId,
              element.item_id,
              +element.row_amount,
              +element.row_unitPrice,
              element.row_note,
              +element.row_discountTypeId === 1? true : null,
              +element.row_discountValue,
              element.row_taxHeaderId
            ]);
    
          }
    
          if (insert_array2.length > 0){
            let columnsCount = insert_array2[0].length;
          let query2 = `INSERT INTO befor_invoce_body
          (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
          VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;

  await tx.none(query2, insert_array2.flat());
}

          //! history
          await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø´Ø±Ø§Ø¡ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error adding purshases Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });

    //#endregion sales qutation end

    //#region get_data_for_purshases_qutation_update
    app.post("/get_data_for_purshases_qutation_update", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        await permissions(req, "purshases_qutation_permission", "update");
        if (!permissions) {
          return;
        }
    
        const posted_elements = req.body;
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        let query1 = `
         -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
    select
      id as id,
      account_name as account_name
    from
      accounts_header 
    WHERE company_id = $1 
      AND account_type_id = 7
      ;
    `;
    let params1 = [req.session.company_id]
    
    let query2 = `
      select
      id as id,
      account_name as account_name
    from
      accounts_header 
    WHERE company_id = $1 
      AND account_type_id = 4
      AND is_final_account IS true
      and is_salesman IS true
      AND is_inactive IS null
      ;
    `
    let params2 = [req.session.company_id]
    
    let query3 = `
        select 
      th.id,
      th.taxe_package_name as account_name
    from
       settings_tax_header th
    where
      th.company_id = $1
      and th.is_inactive is null
    order by
      th.taxe_package_name asc 
     
    `
    let params3 = [req.session.company_id]
    
    let query4 = `
    select
        tb.id,
        tb.tax_name,
        tb.tax_rate,
        tb.is_tax_reverse,
        tb.tax_account_id,
        ah.account_name,
        tb.settings_tax_header_id
    from
        settings_tax_body tb
    left join accounts_header ah on ah.id = tb.tax_account_id    
    where
        tb.settings_tax_header_id = ANY($1::int[])
    `;
    
    
    let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
    `;
    
    let params5 = [req.session.company_id];
    
    
    let query6 = `
    select
      ah.id,
      ah.account_name
    from
      accounts_header ah
    where
      ah.company_id = $1
      AND ah.is_final_account is true
      AND is_inactive is null
      AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`
    
      let params6 = [req.session.company_id];
    
    
    let query7 = `
    select 
      bih.id,
      bih.reference,
      COALESCE(bih.general_note, '') as general_note,
      bih.datex,
      bih.account_id,
      bih.is_qutation_status,
      bih.expire_offer_datex,
      bih.is_invoiced,
      bih.qutation_id,
      bih.is_delivered,
      bih.items_location_id,
      bih.is_column2 as is_row_note_show,
      bih.is_column1 as is_row_dicount_show, 
      bih.is_column3 as is_row_tax_show, 
      CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS referenceconcat
    from
      befor_invoice_header bih
    LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
    where 
    bih.id = $1
    and bih.company_id = $2
    and bih.transaction_type = 25
    AND bih.is_deleted IS NULL;
    `
    let params7 = [posted_elements.x, req.session.company_id];
    
    let query8 = `
    select
      bib.id,
      bib.item_type_id,
      bib.item_id,
        ah.account_name,
        ah.item_unite,
      bib.amount,
      bib.unite_price,
      COALESCE(bib.row_note, '') as row_note,
      bib.is_discount_percentage,
      bib.dicount_value,
      bib.tax_header_id,
        sth.taxe_package_name
    
    from
      befor_invoce_body bib
    LEFT JOIN accounts_header ah on ah.id = bib.item_id 
    LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id 
    where 
      bib.header_id = $1;
    `
    let params8 = [posted_elements.x]
    
    
    
    
    await db.tx(async (tx) => {
    
      const itemslocationsArray = await tx.any(query1, params1);
      const salesmanArray = await tx.any(query2, params2);
      const taxHeaderArray = await tx.any(query3, params3);
      const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
      const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
      const itemsDataArray = await tx.any(query5, params5);
      const vendorsDataArray = await tx.any(query6, params6);
      const headerDataArray = await tx.oneOrNone(query7, params7);
      const bodyDataArray = await tx.any(query8, params8);
      
      const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, headerDataArray, bodyDataArray };
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get Employees Data", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage,});
      }
    });
    //#endregion end

    //#region purshases_qutation_update
    app.post("/api/purshases_qutation_update", async (req, res) => {
      try {
    
        //! Permission
        await permissions(req, "purshases_qutation_update", "update");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 25
      
        const year = getYear(posted_elements.datex)
        //! sql injection check
        let hasBadSymbols = sql_anti_injection([
          ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
          posted_elements.x,
          posted_elements.vendorId,
          posted_elements.total,
          posted_elements.datex,
          posted_elements.itemLocationId,
          posted_elements.is_RowNote,
          posted_elements.is_RowDiscount,
          posted_elements.general_note,
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        ]);
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar: sql_injection_message_ar,
            message_en: sql_injection_message_en,
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'update',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
       const total = +posted_elements.total

       if (!total || isNaN(total)){
        await block_user(req,'Ssqa001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
       }

    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type
          let query01 = `SELECT id, reference FROM befor_invoice_header WHERE id = $1 AND company_id = $2;`;
          let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
          
          
    
          if (!rows01 || !rows01.id) {
            return res.json({
              success: false,
              message_ar: 'âŒ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ù‡ ',
            });
          }
          const reference = rows01.reference

    // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
    let rows02 = await db.any(query02, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id,
      // is_salesman: row.is_salesman
    }));

    //check salesman

    // const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      // if (!count_salesman) {
      //   await block_user(req,'Ssqa01')
      //   return res.json({
      //     success: false,
      //     xx: true,
      //     message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      //   });
      // }
      const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_itemLocation) {
        await block_user(req,'Spqa02')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const item_typeId = rowData.item_typeId;
      const item_id = rowData.item_id;

    
      //! make sure from every account_id
      const accountExists = dbAccounts.some(item => 
        +item.id === +item_id && +item.account_type_id === +item_typeId
      );
    
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!accountExists) {
        await block_user(req,'Spqa1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    
    
        // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
        let rows03 = await db.any(query03, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbTaxesHeaderArray = rows03.map(row => ({
          id: parseInt(row.id)
        }));
        
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const row_taxHeaderId = rowData.row_taxHeaderId;
          
          if (row_taxHeaderId){
          //! make sure from every account_id
          const taxExists = dbTaxesHeaderArray.some(item =>
            +item.id === +row_taxHeaderId
          );
          

        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!taxExists) {
            await block_user(req,'Spqa2')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        }
    




        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let query1 = `update befor_invoice_header
                        set total_value = $1, general_note = $2, datex = $3, account_id = $4, items_location_id = $5, is_column2 = $6, is_column1 = $7, is_column3 = $8
                        where id = $9 and company_id = $10 and transaction_type = $11 AND is_deleted IS NULL;`;
    
          const resultQ1 = await tx.result(query1, [
            total,
            posted_elements.general_note,
            posted_elements.datex,
            posted_elements.vendorId,
            posted_elements.itemLocationId,
            posted_elements.is_RowNote ? true : null,
            posted_elements.is_RowDiscount ? true : null,
            posted_elements.is_RowTax ? true : null,
            posted_elements.x,
            req.session.company_id,
            transaction_type
          ]);
    
          if (resultQ1.rowCount === 0) {
            throw new Error("No rows were update, rolling back purshases Qutation Update.");
          }
    
          let query0 = `DELETE from befor_invoce_body where header_id = $1`
          await tx.none(query0,[posted_elements.x])

          let insert_array2 = []
          for (const element of posted_elements.posted_array) {
    
            //! make sure if account id != item  then location and amount = null

            if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
              await block_user(req,'Ssqa3')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }


            insert_array2.push([
              posted_elements.x,
              +element.item_typeId,
              element.item_id,
              +element.row_amount,
              +element.row_unitPrice,
              element.row_note,
              +element.row_discountTypeId === 1? true : null,
              +element.row_discountValue,
              element.row_taxHeaderId
            ]);
    
          }
    
          if (insert_array2.length > 0){
            let columnsCount = insert_array2[0].length;              
          let query2 = `INSERT INTO befor_invoce_body
          (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
          VALUES ${insert_array2.map((_, i) => 
            `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
          ).join(', ')}`;
          await tx.none(query2, insert_array2.flat());
          }

          //! history
          await history(transaction_type,2,posted_elements.x,reference,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(reference);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error updating purshase Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion sales_qutation_update

    //#region sales qutation reject
    app.post("/api/purshases_qutation_reject", async (req, res) => {
      try {
    
        //! Permission
        await permissions(req, "purshases_qutation_permission", "update");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 25
      
        
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'update',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
        const year = getYear(posted_elements.datex)
    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type

          const query1 = `
          SELECT 
            (SELECT count(id) 
             FROM befor_invoice_header 
             WHERE qutation_id = $1 
               AND company_id = $2 
               AND transaction_type = 26
               AND is_deleted IS NULL) AS befor_invoice_count, 
            (SELECT count(id) 
             FROM transaction_header 
             WHERE qutation_id = $1 
               AND company_id = $2 
               AND is_deleted IS NULL) AS transaction_header_count,
            (SELECT reference 
             FROM befor_invoice_header 
             WHERE id = $1 
               AND company_id = $2
               AND transaction_type = 25
               AND is_deleted IS NULL) AS qutation_reference
        `;
        
        const result1 = await db.oneOrNone(query1, [posted_elements.x, req.session.company_id]);
        
        if (result1.befor_invoice_count > 0 || result1.transaction_header_count > 0) {
          return res.json({
            success: false,
            message_ar: 'âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø±ÙØ¶ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØŒ Ø­ÙŠØ« ØªÙ… Ù‚Ø¨ÙˆÙ„Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙ‰ Ø§Ø­Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª.',
          });
        }
        
        if (!result1 || !result1.qutation_reference){
          await block_user(req,'Spqr01')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }

          let query01 = `update befor_invoice_header set is_qutation_status = false WHERE id = $1 AND company_id = $2 AND is_deleted IS null;`;
          let rows01 = await db.result(query01, [posted_elements.x, req.session.company_id]);

          if (rows01.rowCount === 0) {
            await block_user(req,'Spqr02')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }

          

        await last_activity(req);
        const new_referenceFormatting = formatFromFiveDigits(result1.qutation_reference);

        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø±ÙØ¶ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø± Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error sales_qutation_reject:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion sales qutation reject


    //#region delete sales Qutation
    app.post("/api/purshases_qutation_delete", async (req, res) => {
      try {
    
        //! Permission Ù…Ø¹Ù„Ù‚
        await permissions(req, "purshases_qutation_permission", "delete");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 25
      
      
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    

    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: false,
          type: 'delete',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------

    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type
          let query01 = `
          SELECT reference, datex 
          FROM befor_invoice_header 
          WHERE id = $1 AND company_id = $2;
        `;
        
        let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
        
        if (!rows01) {
          await block_user(req, 'Spqd01');
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
        
        const datex = rows01.datex;
        const reference = rows01.reference;
        
        const year = getYear(datex)

        let queries = `
          SELECT COUNT(qutation_id) AS count_qutation_id
          FROM befor_invoice_header 
          WHERE reference = $1 
            AND SUBSTRING(datex, 1, 4) = SUBSTRING($2, 1, 4);
        `;
        
        let result = await db.oneOrNone(queries, [reference, datex]);
        
        if (result.count_qutation_id > 0) {
          return res.json({
            success: false,
            message_ar: 'âŒ Ø¹ÙÙˆØ§ : Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ Ù„Ø§Ù†Ù‡ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ',
          });
        }
        

        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let query1 = `update befor_invoice_header
                        set is_deleted = true where id = $1 and company_id = $2 and transaction_type = 25;`;
    
          const resultQ1 = await tx.result(query1, [
            posted_elements.x,
            req.session.company_id
          ]);
    
          if (resultQ1.rowCount === 0) {
            throw new Error("No rows were update, rolling back purshases Qutation Update.");
          }
    
          let query0 = `DELETE from befor_invoce_body where header_id = $1`
          await tx.none(query0,[posted_elements.x])

          await history(transaction_type,3,posted_elements.x,reference,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(reference);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error deleting purshasing Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion delete sales qutation

//#endregion sales Qutation

  
//#region purshases order

    //#region purshases order view
    app.post("/get_purshases_order_Data_view", async (req, res) => {
      try {
        
        //! Permission 
        await permissions(req, "purshases_order_permission", "view");
        if (!permissions) {
          return;
        }
          
    
        const posted_elements = req.body;
    
            // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
            const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar:
                  "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
              });
            }
          
              const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
              if (InValidDateFormat){
                return res.json({
                  success: false,
                  message_ar: InValidDateFormat_message_ar,
                });
              }
            
    
    
          turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
    
    
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        let query1 = `
    select 
        bih.id,
        bih.reference,
        bih.total_value,
        COALESCE(bih.general_note, '') as general_note, 
        bih.datex,
        bih.account_id as vendor_id,
        ah1.account_name as vendor_name,
        CASE 
            WHEN bih.is_invoiced IS TRUE THEN 'Ù…ÙÙˆØªØ±'
            ELSE 'ØºÙŠØ± Ù…ÙÙˆØªØ±'
        END AS is_invoiced,
        bih.expire_offer_datex,
        bih.is_column2 as is_row_note_show,
        bih.is_column1 as is_row_dicount_show, 
        bih.is_column3 as is_row_tax_show, 
        CONCAT(
            tt1.doc_prefix, '-',
            SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS referenceconcat,
         bih.qutation_id,
        CONCAT(
            tt2.doc_prefix, '-',
            SUBSTRING(bih2.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih2.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS qutation_reference
         
    from
        befor_invoice_header bih
    left join accounts_header ah1 on ah1.id = bih.account_id
    left join befor_invoice_header bih2 on bih2.id = bih.qutation_id
    LEFT JOIN transaction_type tt1 ON tt1.id = bih.transaction_type
    LEFT JOIN transaction_type tt2 ON tt2.id = bih2.transaction_type
    where
        bih.company_id = $1
        AND bih.transaction_type = 26
        AND (bih.datex BETWEEN $2 AND $3) -- Ø§Ù„ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù‚ÙŠÙ… Ø¨ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù†ØµÙŠØ© ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
        AND bih.is_deleted IS NULL
    ORDER BY
        bih.datex DESC,
        bih.reference DESC;
    
    `;
    
        let data = await db.any(query1, [req.session.company_id,posted_elements.start_date, posted_elements.end_date]);
    
        res.json(data);
      } catch (error) {
        console.error("Error get_sales_order_Data_view:", error);
        res.status(500).send("Error:");
      }
    });
    
    //#endregion

    //#region add purshases order
    app.post("/api/purshases_order_add", async (req, res) => {
      try {
    
        //! Permission
        await permissions(req, "purshases_order_permission", "add");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 26
      
    
        //! sql injection check
        let hasBadSymbols = sql_anti_injection([
          ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
          posted_elements.vendorId,
          posted_elements.total,
          posted_elements.datex,
          posted_elements.qutationReferenceId,
          posted_elements.itemLocationId,
          // posted_elements.salesmanId,
          posted_elements.is_RowNote,
          posted_elements.is_RowDiscount,
          posted_elements.general_note,
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        ]);
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar: sql_injection_message_ar,
            message_en: sql_injection_message_en,
          });
        }
    
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
                

        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: posted_elements.datex,
          type: 'add',
          tableName: false, // if type = 'update' or 'delete' only
          transaction_id: false, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------
    
       const total = +posted_elements.total

       if (!total || isNaN(total)){
        await block_user(req,'Spqa001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
       }

    
    // //! Security hacking  accounts id
   
       // check qutationReferenceId
       let query04;
       let rows04;
       if (posted_elements.qutationReferenceId){
         query04 = `select id, is_qutation_status from befor_invoice_header where id = $1 and company_id = $2 and is_deleted IS NULL`
         rows04 = await db.oneOrNone(query04, [posted_elements.qutationReferenceId, req.session.company_id])
        if (!rows04 || !rows04.id){
          await block_user(req,'Spqa01')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
        }



    // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
    let rows02 = await db.any(query02, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id,
      // is_salesman: row.is_salesman
    }));

    //check salesman

    // const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      // if (!count_salesman) {
      //   await block_user(req,'Ssqa01')
      //   return res.json({
      //     success: false,
      //     xx: true,
      //     message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      //   });
      // }

      const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!count_itemLocation) {
        await block_user(req,'Spqa02')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }


    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const item_typeId = rowData.item_typeId;
      const item_id = rowData.item_id;

    
      //! make sure from every account_id
      const accountExists = dbAccounts.some(item => 
        +item.id === +item_id && +item.account_type_id === +item_typeId
      );
    
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!accountExists) {
        await block_user(req,'Spqa1')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    
    
        // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
        let rows03 = await db.any(query03, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbTaxesHeaderArray = rows03.map(row => ({
          id: parseInt(row.id)
        }));
        
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const row_taxHeaderId = rowData.row_taxHeaderId;
          
          if (row_taxHeaderId){
          //! make sure from every account_id
          const taxExists = dbTaxesHeaderArray.some(item =>
            +item.id === +row_taxHeaderId
          );
          

        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!taxExists) {
            await block_user(req,'Spqa2')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        }
    
        const year = getYear(posted_elements.datex)
    

        const query001 = `SELECT MAX(reference) AS max FROM befor_invoice_header WHERE company_id = $1 AND transaction_Type = 26 AND datex LIKE '${year}-%'; -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø³Ù†Ø© ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ§Ø±ÙŠØ® `;
      const Params001 = [req.session.company_id];
      const result001 = await db.oneOrNone(query001, Params001);
      let newReference_transaction_header = 1;
      if (result001 && result001.max && result001.max > 0) {
        newReference_transaction_header = +result001.max + 1;
      }
  
        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {


          if (rows04 && rows04.is_qutation_status === null) {
            await tx.none(
              `UPDATE befor_invoice_header 
               SET is_qutation_status = true 
               WHERE id = $1 AND company_id = $2`,
              [posted_elements.qutationReferenceId, req.session.company_id]
            );
          }
          


          let query1 = `INSERT INTO befor_invoice_header
                        (reference,transaction_type, total_value, general_note, datex, account_id, items_location_id, is_column2, is_column1, is_column3, qutation_id, company_id)
                        VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12) RETURNING id;`;
    
          const insert = await tx.one(query1, [
            newReference_transaction_header,
            transaction_type,
            total,
            posted_elements.general_note,
            posted_elements.datex,
            posted_elements.vendorId,
            posted_elements.itemLocationId,
            posted_elements.is_RowNote ? true : null,
            posted_elements.is_RowDiscount ? true : null,
            posted_elements.is_Rowtax ? true : null,
            posted_elements.qutationReferenceId,
            req.session.company_id
          ]);
    
          const newId_transaction_header = insert.id;
          
          let insert_array2 = []
          for (const element of posted_elements.posted_array) {
    
            //! make sure if account id != item  then location and amount = null

            if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
              await block_user(req,'Spqa3')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }


            insert_array2.push([
              newId_transaction_header,
              +element.item_typeId,
              element.item_id,
              +element.row_amount,
              +element.row_unitPrice,
              element.row_note,
              +element.row_discountTypeId === 1? true : null,
              +element.row_discountValue,
              element.row_taxHeaderId
            ]);
          }
    
          if (insert_array2.length > 0){
            let columnsCount = insert_array2[0].length;  
          let query2 = `INSERT INTO befor_invoce_body
          (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
          VALUES ${insert_array2.map((_, i) => 
            `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
          ).join(', ')}`;
        
        await tx.none(query2, insert_array2.flat());
        }

          //! history
          await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù…Ø± Ø´Ø±Ø§Ø¡  : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error adding sales Qutation:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregionsales order

    //#region get_data_for_purshases_order_add
    app.post("/get_data_for_purshases_order_add", async (req, res) => {
      try {
        //! Permission
        await permissions(req, "purshases_order_permission", "add"); // Ù…Ø¹Ù„Ù‚
        if (!permissions) {
          return;
        }
    
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        let query1 = `
         -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
    select
      id as id,
      account_name as account_name
    from
      accounts_header 
    WHERE company_id = $1 
      AND account_type_id = 7
      ;
    `;
    let params1 = [req.session.company_id]
    
    // let query2 = `
    //   select
    //   id as id,
    //   account_name as account_name
    // from
    //   accounts_header 
    // WHERE company_id = $1 
    //   AND account_type_id = 4
    //   AND is_final_account IS true
    //   and is_salesman IS true
    //   AND is_inactive IS null
    //   ;
    // `
    // let params2 = [req.session.company_id]
    
    let query3 = `
        select 
      th.id,
      th.taxe_package_name as account_name
    from
       settings_tax_header th
    where
      th.company_id = $1
      and th.is_inactive is null
    order by
      th.taxe_package_name asc 
     
    `
    let params3 = [req.session.company_id]
    
    let query4 = `
    select
        tb.id,
        tb.tax_name,
        tb.tax_rate,
        tb.is_tax_reverse,
        tb.tax_account_id,
        ah.account_name,
        tb.settings_tax_header_id
    from
        settings_tax_body tb
    left join accounts_header ah on ah.id = tb.tax_account_id    
    where
        tb.settings_tax_header_id = ANY($1::int[])
    `;
    
    
    let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
    `;
    
    let params5 = [req.session.company_id];
    
    
    let query6 = `
    select
      ah.id,
      ah.account_name
    from
      accounts_header ah
    where
      ah.company_id = $1
      AND ah.is_final_account is true
      AND is_inactive is null
      AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`
    
      let params6 = [req.session.company_id];
    
  
     let query7 = `
  select 
    bih.id,
        CONCAT(
          tt.doc_prefix, '-',
          SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
          LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS account_name
  from
    befor_invoice_header bih
  LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
  where
    bih.transaction_type = 25
    and bih.company_id = $1
    and bih.is_deleted is NULL
    and bih.is_qutation_status IS NOT FALSE;
     ` 
     let params7 = [req.session.company_id]
  
    await db.tx(async (tx) => {
    
      const itemslocationsArray = await tx.any(query1, params1);
      // const salesmanArray = await tx.any(query2, params2);
      const taxHeaderArray = await tx.any(query3, params3);
      const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
      const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
      const itemsDataArray = await tx.any(query5, params5);
      const vendorsDataArray = await tx.any(query6, params6);
      const purshasesQutationReferencesArray = await tx.any(query7, params7);
    
      const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, purshasesQutationReferencesArray };
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get Employees Data", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage, });
      }
    });
    //#endregion end get data for purshases order update

    //#region purshases_order_update
        app.post("/api/purshases_order_update", async (req, res) => {
          try {
        
            //! Permission Ù…Ø¹Ù„Ù‚
            await permissions(req, "purshases_order_permission", "update");
            if (!permissions) {
              return res.status(403).json({
                success: false,
                message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
              });
            }
    
    
    
        
            const posted_elements = req.body;
            const transaction_type = 26
          
            const year = getYear(posted_elements.datex)
            //! sql injection check
            let hasBadSymbols = sql_anti_injection([
              ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
              posted_elements.x,
              posted_elements.qutation_id,
              posted_elements.vendorId,
              posted_elements.total,
              posted_elements.datex,
              posted_elements.itemLocationId,
              posted_elements.is_RowNote,
              posted_elements.is_RowDiscount,
              posted_elements.general_note,
              // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
            ]);
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar: sql_injection_message_ar,
                message_en: sql_injection_message_en,
              });
            }
        
        
            const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
            if (InValidDateFormat) {
              return res.status(400).json({
                success: false,
                message_ar: InValidDateFormat_message_ar,
              });
            }
        
            //! settings
            const settings = await check_settings_validation({
              check_futureDate: true,
              check_closingDate: true,
              datex: posted_elements.datex,
              type: 'update',
              tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
              transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
            }, req);
        
            
            if (!settings.valid) {
              return res.json({
                success: false,
                message_ar: settings.message_ar,
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
        
            
    
            //* Start Transaction --------------------------------------------------
        
           const total = +posted_elements.total
    
           if (!total || isNaN(total)){
            await block_user(req,'Spqa001')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
           }
    
        
        // //! Security hacking  accounts id


              //! Security hacking check id for company_name and transactio type
              if (posted_elements.qutation_id){
                let query05 = `SELECT count(id) as countQutationId FROM befor_invoice_header WHERE id = $1 AND company_id = $2 and transaction_type = 25;`;
                let rows05 = await db.oneOrNone(query05, [posted_elements.qutation_id, req.session.company_id]);
                if (!rows05.countQutationId === 0) {
                  await block_user(req,'Spqa05')
                  return res.json({
                    success: false,
                    xx: true,
                    message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                  });
                }
              }
         

              let query01 = `SELECT id, reference, qutation_id FROM befor_invoice_header WHERE id = $1 AND company_id = $2 and transaction_type = 26;`;
              let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
              
              

              if (!rows01 || !rows01.id) {
                return res.json({
                  success: false,
                  message_ar: 'âŒ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ù‡ ',
                });
              }
              const reference = rows01.reference

    
        // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
        let rows02 = await db.any(query02, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbAccounts = rows02.map(row => ({
          id: parseInt(row.id),
          account_type_id: row.account_type_id,
          is_salesman: row.is_salesman
        }));
    
        //check salesman
    
        // const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
    
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          // if (!count_salesman) {
          //   await block_user(req,'Ssqa01')
          //   return res.json({
          //     success: false,
          //     xx: true,
          //     message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          //   });
          // }
          const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!count_itemLocation) {
            await block_user(req,'Ssqa02')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
    
    
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const item_typeId = rowData.item_typeId;
          const item_id = rowData.item_id;
    
        
          //! make sure from every account_id
          const accountExists = dbAccounts.some(item => 
            +item.id === +item_id && +item.account_type_id === +item_typeId
          );
        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!accountExists) {
            await block_user(req,'Ssqa1')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
        }
        
        
            // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
            let rows03 = await db.any(query03, [req.session.company_id]);
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
            const dbTaxesHeaderArray = rows03.map(row => ({
              id: parseInt(row.id)
            }));
            
            // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
            for (const rowData of posted_elements.posted_array) {
              const row_taxHeaderId = rowData.row_taxHeaderId;
              
              if (row_taxHeaderId){
              //! make sure from every account_id
              const taxExists = dbTaxesHeaderArray.some(item =>
                +item.id === +row_taxHeaderId
              );
              
    
            
              // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
              if (!taxExists) {
                await block_user(req,'Spqa2')
                return res.json({
                  success: false,
                  xx: true,
                  message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                });
              }
            }
            }
        
    
    
    
            // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            await db.tx(async (tx) => {

              //! qutation_id check and update
              const db_qutation_id = rows01.qutation_id || 0
              const posted_qutation_id = posted_elements.qutation_id || 0
              if (+db_qutation_id !== +posted_qutation_id){
                if (+db_qutation_id !== 0) {
                  const q1 = `
                    SELECT 
                      (SELECT COUNT(id) FROM befor_invoice_header WHERE id != $1 AND qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_befor_invoice_header,
                      (SELECT COUNT(id) FROM transaction_header WHERE qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                  `;                  
                  let result1 = await tx.oneOrNone(q1, [+posted_elements.x, +db_qutation_id, req.session.company_id]);                  
                  if (+result1.count_befor_invoice_header === 0 && +result1.count_transaction_header === 0) {
                    const updateQuery1 = `UPDATE befor_invoice_header SET is_qutation_status = NULL WHERE id = $1 AND company_id = $2`;
                    await tx.none(updateQuery1, [+db_qutation_id, req.session.company_id]);
                  }
                }
                if (+posted_qutation_id !== 0) {
                  const updateQuery2 = `UPDATE befor_invoice_header SET is_qutation_status = true WHERE id = $1 AND company_id = $2`;
                  await tx.none(updateQuery2, [+posted_qutation_id, req.session.company_id]);
                }
              }
              

              let query1 = `update befor_invoice_header
                            set total_value = $1, general_note = $2, datex = $3, account_id = $4, items_location_id = $5, is_column2 = $6, is_column1 = $7, is_column3 = $8, qutation_id = $9
                            where id = $10 and company_id = $11;`;
        
              const resultQ1 = await tx.result(query1, [
                total,
                posted_elements.general_note,
                posted_elements.datex,
                posted_elements.vendorId,
                posted_elements.itemLocationId,
                posted_elements.is_RowNote ? true : null,
                posted_elements.is_RowDiscount ? true : null,
                posted_elements.is_Rowtax ? true : null,
                posted_elements.qutation_id ? +posted_elements.qutation_id : null,
                posted_elements.x,
                req.session.company_id
              ]);
        
              if (resultQ1.rowCount === 0) {
                throw new Error("No rows were update, rolling back purshases order Update.");
              }
        
              let query0 = `DELETE from befor_invoce_body where header_id = $1`
              await tx.none(query0,[posted_elements.x])
    
              let insert_array2 = []
              for (const element of posted_elements.posted_array) {
        
                //! make sure if account id != item  then location and amount = null
    
                if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
                  await block_user(req,'Spqa3')
                  return res.json({
                    success: false,
                    xx: true,
                    message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                  });
                }
    
      
                insert_array2.push([
                  posted_elements.x,
                  +element.item_typeId,
                  element.item_id,
                  +element.row_amount,
                  +element.row_unitPrice,
                  element.row_note,
                  +element.row_discountTypeId === 1? true : null,
                  +element.row_discountValue,
                  element.row_taxHeaderId
                ]);
        
              }

              if (insert_array2.length > 0){
                let columnsCount = insert_array2[0].length;
              let query2 = `INSERT INTO befor_invoce_body
              (header_id, item_type_id, item_id, amount, unite_price, row_note, is_discount_percentage, dicount_value, tax_header_id)
              VALUES ${insert_array2.map((_, i) => 
                `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
              ).join(', ')}`;
            
            await tx.none(query2, insert_array2.flat());
            }
        
              //! history
              await history(transaction_type,2,posted_elements.x,reference,req,tx);
            });
        
            const new_referenceFormatting = formatFromFiveDigits(reference);
            await last_activity(req);
            // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
            return res.json({
              success: true,
              message_ar: `âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù…Ø± Ø´Ø±Ø§Ø¡ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
            });
          } catch (error) {
            await last_activity(req);
            console.error("Error updating purshases Order:", error);
        
            // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
            return res.json({
              success: false,
              message_ar: error.message || deafultErrorMessage,
            });
          }
        });
        //#endregion sales_order_update
    
    //#region get_data_for_purshases_order_update
    app.post("/get_data_for_purshases_order_update", async (req, res) => {
      try {
        //! Permission
        await permissions(req, "purshases_order_permission", "update");
        if (!permissions) {
          return;
        }
    
        
        const posted_elements = req.body;
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        let transaction_type;
        if(posted_elements.type === 'qutation'){
          transaction_type = 25
        }else if(posted_elements.type === 'order'){
          transaction_type = 26
        }
    
    
        let query1 = `
         -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
    select
      id as id,
      account_name as account_name
    from
      accounts_header 
    WHERE company_id = $1 
      AND account_type_id = 7
      ;
    `;
    let params1 = [req.session.company_id]
    
    // let query2 = `
    //   select
    //   id as id,
    //   account_name as account_name
    // from
    //   accounts_header 
    // WHERE company_id = $1 
    //   AND account_type_id = 4
    //   AND is_final_account IS true
    //   and is_salesman IS true
    //   AND is_inactive IS null
    //   ;
    // `
    // let params2 = [req.session.company_id]
    
    let query3 = `
        select 
      th.id,
      th.taxe_package_name as account_name
    from
       settings_tax_header th
    where
      th.company_id = $1
      and th.is_inactive is null
    order by
      th.taxe_package_name asc 
     
    `
    let params3 = [req.session.company_id]
    
    let query4 = `
    select
        tb.id,
        tb.tax_name,
        tb.tax_rate,
        tb.is_tax_reverse,
        tb.tax_account_id,
        ah.account_name,
        tb.settings_tax_header_id
    from
        settings_tax_body tb
    left join accounts_header ah on ah.id = tb.tax_account_id    
    where
        tb.settings_tax_header_id = ANY($1::int[])
    `;
    
    
    let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
    `;
    
    let params5 = [req.session.company_id];
    
    
    let query6 = `
    select
      ah.id,
      ah.account_name
    from
      accounts_header ah
    where
      ah.company_id = $1
      AND ah.is_final_account is true
      AND is_inactive is null
      AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`
    
      let params6 = [req.session.company_id];
    
    
    let query7 = `
    select 
      bih.id,
      bih.reference,
      COALESCE(bih.general_note, '') as general_note,
      bih.datex,
      bih.account_id,
      bih.is_qutation_status,
      bih.expire_offer_datex,
      bih.is_invoiced,
      bih.qutation_id,
      bih.is_delivered,
      bih.items_location_id,
      bih.is_column2 as is_row_note_show,
      bih.is_column1 as is_row_dicount_show, 
      bih.is_column3 as is_row_tax_show, 
      CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS referenceconcat
    from
      befor_invoice_header bih
    LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
    where 
    bih.id = $1
    and bih.company_id = $2
    and bih.transaction_type = $3
    AND bih.is_deleted IS NULL;
    `
    let params7 = [posted_elements.x, req.session.company_id, transaction_type];
    
    let query8 = `
    select
      bib.id,
      bib.item_type_id,
      bib.item_id,
        ah.account_name,
        ah.item_unite,
      bib.amount,
      bib.unite_price,
      COALESCE(bib.row_note, '') as row_note,
      bib.is_discount_percentage,
      bib.dicount_value,
      bib.tax_header_id,
        sth.taxe_package_name
    
    from
      befor_invoce_body bib
    LEFT JOIN accounts_header ah on ah.id = bib.item_id 
    LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id 
    where 
      bib.header_id = $1;
    `
    let params8 = [posted_elements.x]
    
    
    let query9 = `
    select 
      bih.id,
          CONCAT(
            tt.doc_prefix, '-',
            SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS account_name
    from
      befor_invoice_header bih
    LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
    where
      bih.transaction_type = 25
      and bih.company_id = $1
      and bih.is_deleted is NULL
      and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
       ` 
       qutation_id = isNaN(+posted_elements.qutation_id)? null : posted_elements.qutation_id 
       let params9 = [req.session.company_id, qutation_id]
    
    
    
    await db.tx(async (tx) => {
    
      const itemslocationsArray = await tx.any(query1, params1);
      // const salesmanArray = await tx.any(query2, params2);
      const taxHeaderArray = await tx.any(query3, params3);
      const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
      const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
      const itemsDataArray = await tx.any(query5, params5);
      const vendorsDataArray = await tx.any(query6, params6);
      const headerDataArray = await tx.oneOrNone(query7, params7);
      const bodyDataArray = await tx.any(query8, params8);
      const purshasesQutationReferencesArray = await tx.any(query9, params9);
    
      const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, headerDataArray, bodyDataArray, purshasesQutationReferencesArray};
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get_data_for_purshases_order_update", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage,});
      }
    });
    //#endregion end- Get_data_for_purshases_order_update

    //#region delete sales order
    app.post("/api/purshases_order_delete", async (req, res) => {
      try {
    
        //! Permission Ù…Ø¹Ù„Ù‚
        await permissions(req, "purshases_order_permission", "delete");
        if (!permissions) {
          return res.status(403).json({
            success: false,
            message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
          });
        }



    
        const posted_elements = req.body;
        const transaction_type = 26
      
      
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }
    

    
        //! settings
        const settings = await check_settings_validation({
          check_futureDate: true,
          check_closingDate: true,
          datex: false,
          type: 'delete',
          tableName: 'befor_invoice_header', // if type = 'update' or 'delete' only
          transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
        }, req);
    
        
        if (!settings.valid) {
          return res.json({
            success: false,
            message_ar: settings.message_ar,
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
    
        

        //* Start Transaction --------------------------------------------------

    
    // //! Security hacking  accounts id

          //! Security hacking check id for company_name and transactio type
          let query01 = `
          SELECT reference, datex, qutation_id
          FROM befor_invoice_header 
          WHERE id = $1 AND company_id = $2 AND transaction_type = $3 AND is_deleted IS NULL;
        `;
        
        let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
        if (!rows01) {
          await block_user(req, 'Spqd01');
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
        
        const datex = rows01.datex;
        const reference = rows01.reference;
        const qutation_id = rows01.qutation_id;
        
        const year = getYear(datex)

        let queries = `
          SELECT COUNT(order_id) AS count_order_id
          FROM transaction_header 
          WHERE order_id = $1 
                AND company_id = $2
                AND is_deleted IS NULL ;
        `;
        
        let result = await db.oneOrNone(queries, [posted_elements.x, req.session.company_id]);
        
        if (result.count_order_id > 0) {
          return res.json({
            success: false,
            message_ar: 'âŒ Ø¹ÙÙˆØ§ : Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø¹Ø±Ø¶ Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ Ù„Ø§Ù†Ù‡ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ',
          });
        }
        
        

        // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        await db.tx(async (tx) => {
          let result1;
          if (qutation_id){
            const q1 = `select count(id) as id_count from befor_invoice_header where id != $1 AND qutation_id = $2 and Company_id = $3 AND is_deleted IS NULL`            
            result1 = await tx.oneOrNone(q1,[+posted_elements.x, +qutation_id, req.session.company_id])            
            if (+result1.id_count === 0){    
              const q2 = `update befor_invoice_header set is_qutation_status = null where id = $1 AND company_id = $2`
              const p1 = await tx.none(q2,[+qutation_id, req.session.company_id])
            }
          }


          let query1 = `update befor_invoice_header
                        set is_deleted = true where id = $1 and company_id = $2 AND transaction_type = 26;`;
    
          const resultQ1 = await tx.result(query1, [
            posted_elements.x,
            req.session.company_id
          ]);
    
          if (resultQ1.rowCount === 0) {
            throw new Error("No rows were update, rolling back purshases Qutation Update.");
          }
    
          let query0 = `DELETE from befor_invoce_body where header_id = $1`
          await tx.none(query0,[posted_elements.x])

          await history(transaction_type,3,posted_elements.x,reference,req,tx);
        });
    
        const new_referenceFormatting = formatFromFiveDigits(reference);
        await last_activity(req);
        // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
        return res.json({
          success: true,
          message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù…Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
        });
      } catch (error) {
        await last_activity(req);
        console.error("Error deleting purshases Order:", error);
    
        // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
        return res.json({
          success: false,
          message_ar: error.message || deafultErrorMessage,
        });
      }
    });
    //#endregion delete sales order

//#endregion purshases order


//#endregion end-purshases

//#region purshases invoice

        //#region purshases invoice view


        app.post("/get_purshases_invoice_Data_view", async (req, res) => {
          try {
            
            //! Permission  
            await permissions(req, "sales_purshases_permission", "view");
            if (!permissions) {
              return;
            }
              
        
            const posted_elements = req.body;
        
                // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
                const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
                if (hasBadSymbols) {
                  return res.json({
                    success: false,
                    message_ar:
                      "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
                  });
                }
              
                  const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
                  if (InValidDateFormat){
                    return res.json({
                      success: false,
                      message_ar: InValidDateFormat_message_ar,
                    });
                  }
                
        
        
              turn_EmptyValues_TO_null(posted_elements);
            //* Start--------------------------------------------------------------
        
      /*
      -- Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ù…ÙØªÙˆØ­Ù‡
      WITH balances AS (
    SELECT 
        A.id AS customer_id,
        COALESCE(SUM(T.debit), 0) - COALESCE(SUM(T.credit), 0) AS balance
    FROM 
        accounts_header A
    LEFT JOIN 
        transaction_body T ON A.id = T.account_id
    WHERE
        A.company_id = $1
        AND A.account_type_id = 2
    GROUP BY
        A.id
),
ordered_invoices AS (
    SELECT 
        th.id AS invoice_id,
        th.account_id AS customer_id,
        th.total_value AS invoice_value,
        th.datex AS invoice_date
    FROM
        transaction_header th
    WHERE
        th.company_id = $1
        AND th.transaction_type = 3
        AND (th.datex BETWEEN $2 AND $3)
        AND th.is_deleted IS NULL
    ORDER BY
        th.account_id ASC,
        th.datex ASC,
        th.id ASC
),
distributed AS (
    SELECT
        oi.invoice_id,
        oi.customer_id,
        oi.invoice_value,
        oi.invoice_date,
        b.balance,
        GREATEST(
            0,
            LEAST(oi.invoice_value, 
                  b.balance - COALESCE(SUM(oi.invoice_value) OVER (PARTITION BY oi.customer_id ORDER BY oi.invoice_date ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING), 0)
            )
        ) AS remaining_balance
    FROM
        ordered_invoices oi
    LEFT JOIN 
        balances b ON oi.customer_id = b.customer_id
)
SELECT 
    invoice_id,
    customer_id,
    invoice_value,
    invoice_date,
    remaining_balance
FROM
    distributed
WHERE
    remaining_balance > 0
ORDER BY
    customer_id,
    invoice_date;
   
      */
         
      
        let quer1 = `
        -- 1. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†
WITH balances AS (
    SELECT 
        A.id AS vendor_id, -- ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ù…ÙˆØ±Ø¯
        COALESCE(SUM(T.credit), 0) - COALESCE(SUM(T.debit), 0) AS balance -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯: (Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø¯Ø§Ø¦Ù† - Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ù…Ø¯ÙŠÙ†)
    FROM 
        accounts_header A -- Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª
    LEFT JOIN 
        transaction_body T ON A.id = T.account_id -- Ø±Ø¨Ø· Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø¨Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¹Ø¨Ø± Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø­Ø³Ø§Ø¨
    WHERE
        A.company_id = $1 -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø´Ø±ÙƒØ©
        AND A.account_type_id = 3 -- ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨ (Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†)
    GROUP BY
        A.id -- ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
),

-- 2. ØªØ±ØªÙŠØ¨ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø­Ø³Ø¨ Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®
---- Ù‡Ù†Ø¶ÙŠÙ Ø§Ù„Ø§Ø¹Ù…Ø¯Ù‡ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© 3 Ù…Ø±Ø§Øª Ø¨Ø¯Ø£ Ù…Ù† Ø§Ù„Ø¬Ø²Ù‰Ø¡ Ø§Ù„ØªØ§Ù„Ù‰ ÙˆØ­ØªÙ‰ Ø§Ù„Ø§Ø®ÙŠØ±
ordered_invoices AS (
    SELECT 
        th.id as id,
        th.reference as reference,
        th.total_value AS total_value,        
        COALESCE(th.general_note, '') as general_note,
        th.datex AS datex,
        th.account_id AS vendor_id,
        ah1.account_name as vendor_name,
        th.salesman_id as salesman_id,
        ah2.account_name as salesman_name,
        th.due_date,
        th.is_column1 as is_row_dicount_show,
        th.is_column2 as is_row_note_show,
        th.is_column3 as is_row_tax_show,
        CONCAT(
          tt1.doc_prefix, '-',
          SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS referenceconcat,
        th.qutation_id,
        CONCAT(
          tt2.doc_prefix, '-',
          SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS qutation_reference,
        th.order_id,
        CONCAT(
          tt3.doc_prefix, '-',
          SUBSTRING(bih2.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih2.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
        ) AS order_reference
    FROM
        transaction_header th
    left join accounts_header ah1 on ah1.id = th.account_id
    left join accounts_header ah2 on ah2.id = th.salesman_id
    left join befor_invoice_header bih on bih.id = th.qutation_id
    left join befor_invoice_header bih2 on bih2.id = th.order_id
    left JOIN transaction_type tt1 ON tt1.id = th.transaction_type
    left JOIN transaction_type tt2 ON tt2.id = bih.transaction_type
    left JOIN transaction_type tt3 ON tt3.id = bih2.transaction_type
    WHERE
        th.company_id = $1 -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø´Ø±ÙƒØ©
        AND th.transaction_type = 6 -- ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© (ÙØ§ØªÙˆØ±Ø© Ø´Ø±Ø§Ø¡)
        AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
        AND th.is_deleted IS NULL -- ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø­Ø°ÙˆÙØ©
    ORDER BY
        th.account_id ASC, -- ØªØ±ØªÙŠØ¨ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
        th.datex ASC, -- Ø«Ù… Ø­Ø³Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„ÙØ§ØªÙˆØ±Ø©
        th.id ASC -- ÙˆØ£Ø®ÙŠØ±Ù‹Ø§ Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„ÙØ§ØªÙˆØ±Ø©
),

-- 3. ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø±ØµÙŠØ¯ Ø¹Ù„Ù‰ Ø§Ù„ÙÙˆØ§ØªÙŠØ±
distributed AS (
    SELECT
        oi.id,
        oi.reference,
        oi.total_value,
        COALESCE(oi.general_note, '') as general_note,
        oi.datex,
        oi.vendor_id,
        oi.vendor_name,
        oi.salesman_id,
        oi.salesman_name,
        oi.due_date,
        oi.is_row_dicount_show,
        oi.is_row_note_show,
        oi.is_row_tax_show,
        oi.referenceconcat,
        oi.qutation_id,
        oi.qutation_reference,
        oi.order_id,
        oi.order_reference,
        b.balance, -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ù„Ù„Ù…ÙˆØ±Ø¯
        -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¨Ø¹Ø¯ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ù…ÙˆØ§Ù„ Ø¹Ù„Ù‰ Ø§Ù„ÙØ§ØªÙˆØ±Ø©
        CASE
            WHEN b.balance <= 0 THEN 0 -- Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ØŒ ÙŠØªÙ… ØªØ®ØµÙŠØµ 0
            ELSE
                -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø±ØµÙŠØ¯ Ù…ØªØ¨Ù‚ÙŠØŒ ÙŠØªÙ… ØªÙˆØ²ÙŠØ¹Ù‡ Ø¹Ù„Ù‰ Ø§Ù„ÙØ§ØªÙˆØ±Ø©
                GREATEST(
                    0, -- Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
                    LEAST(
                        oi.total_value, -- Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø©
                        b.balance - COALESCE(SUM(oi.total_value) OVER (PARTITION BY oi.vendor_id ORDER BY oi.datex ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING), 0) -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¨Ø¹Ø¯ ØªÙˆØ²ÙŠØ¹ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
                    )
                )
        END AS remaining_balance -- Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ ÙŠØªÙ… ÙˆØ¶Ø¹ 0 ÙˆØ¥Ù„Ø§ ÙŠØªÙ… Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
    FROM
        ordered_invoices oi -- Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø±ØªØ¨Ø©
    LEFT JOIN 
        balances b ON oi.vendor_id = b.vendor_id -- Ø±Ø¨Ø· Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ù…Ø¹ Ø§Ù„Ø£Ø±ØµØ¯Ø©
)

-- 4. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø§Ù„ØªÙŠ Ø³ÙŠØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹Ù‡Ø§
SELECT 
    id,
    reference,
    total_value,
    COALESCE(general_note, '') as general_note,
    datex,
    vendor_id,
    vendor_name,
    salesman_id,
    salesman_name,
    due_date,
    is_row_dicount_show,
    is_row_note_show,
    is_row_tax_show,
    referenceconcat,
    qutation_id,
    qutation_reference,
    order_id,
    order_reference,
    CASE
      WHEN remaining_balance = 0 THEN
        'Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„'  
      WHEN due_date::DATE - $4::DATE > 0 THEN
        CASE
            WHEN remaining_balance <= 0 THEN 
                'Ù…Ø¯ÙÙˆØ¹ Ù…Ù‚Ø¯Ù…Ø§Ù‹' -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ ØµÙØ± Ø£Ùˆ Ø£Ù‚Ù„
            ELSE 
                CONCAT('ÙŠØ³ØªØ­Ù‚ Ø¨Ø¹Ø¯ ', due_date::DATE - $4::DATE, ' ÙŠÙˆÙ…') -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø±ØµÙŠØ¯ Ù…ØªØ¨Ù‚ÙŠ
        END
      WHEN due_date::DATE - $4::DATE = 0 THEN 
        'Ù…Ø³ØªØ­Ù‚ Ø§Ù„ÙŠÙˆÙ…' -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ±Ù‚ ØµÙØ±
      WHEN due_date::DATE - $4::DATE < 0 THEN 
        CONCAT('Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ø° ', ABS($4::DATE - due_date::DATE), ' ÙŠÙˆÙ…') -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ±Ù‚ Ø£Ù‚Ù„ Ù…Ù† ØµÙØ±
    END AS payment_status,
    remaining_balance -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¨Ø¹Ø¯ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø±ØµÙŠØ¯
FROM
    distributed -- Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ²Ø¹Ø©
ORDER BY
      datex DESC,
      reference desc;
    --vendor_id, -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
    -- datex; -- Ø«Ù… ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„ÙØ§ØªÙˆØ±Ø©

        `;
        
        // ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
        let data = await db.any(quer1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date, today]);


            res.json(data);
          } catch (error) {
            console.error("Error get_purshases_invoice_Data_view:", error);
            res.status(500).send("Error:");
          }
        });
        //#endregion sales invoice view

        app.post("/get_data_for_purshasesQutationToInvoice", async (req, res) => {
          try {
            //! Permission
            await permissions(req, "purshases_invoice_permission", "add");
            if (!permissions) {
              return;
            }
        
            
            const posted_elements = req.body;
            const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar:
                  "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
            //* Start--------------------------------------------------------------
            // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
        
            const transaction_type = 25
      
        
        
            let query1 = `
             -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
        select
          id as id,
          account_name as account_name
        from
          accounts_header 
        WHERE company_id = $1 
          AND account_type_id = 7
          AND is_inactive IS NULL
          ;
        `;
        let params1 = [req.session.company_id]
        
        // let query2 = `
        //   select
        //   id as id,
        //   account_name as account_name
        // from
        //   accounts_header 
        // WHERE company_id = $1 
        //   AND account_type_id = 4
        //   AND is_final_account IS true
        //   and is_salesman IS true
        //   AND is_inactive IS null
        //   ;
        // `
        // let params2 = [req.session.company_id]
        
        let query3 = `
            select 
          th.id,
          th.taxe_package_name as account_name
        from
           settings_tax_header th
        where
          th.company_id = $1
          and th.is_inactive is null
        order by
          th.taxe_package_name asc 
         
        `
        let params3 = [req.session.company_id]
        
        let query4 = `
        select
            tb.id,
            tb.tax_name,
            tb.tax_rate,
            tb.is_tax_reverse,
            tb.tax_account_id,
            ah.account_name,
            tb.settings_tax_header_id
        from
            settings_tax_body tb
        left join accounts_header ah on ah.id = tb.tax_account_id    
        where
            tb.settings_tax_header_id = ANY($1::int[])
            AND ah.is_inactive IS NULL
        `;
        
        
        let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
        `;
        
        let params5 = [req.session.company_id];
        
        
        let query6 = `
        select
          ah.id,
          ah.account_name
        from
          accounts_header ah
        where
          ah.company_id = $1
          AND ah.is_final_account is true
          AND is_inactive is null
          AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`
        
          let params6 = [req.session.company_id];
        
        
        let query7 = `
        select 
          bih.id,
          bih.reference,
          COALESCE(bih.general_note, '') as general_note,
          bih.datex,
          NULL as due_date,
          bih.account_id,
          bih.qutation_id,
          bih.is_delivered,
          bih.items_location_id,
          bih.is_column2 as is_row_note_show,
          bih.is_column1 as is_row_dicount_show,
          bih.is_column3 as is_row_tax_show,
          CONCAT(
            tt1.doc_prefix, '-',
            SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS referenceconcat,
          CONCAT(
            tt2.doc_prefix, '-',
            SUBSTRING(qt.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(qt.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS referenceconcat_qutation,
        NULL AS referenceconcat_order
        from
          befor_invoice_header bih
          left join befor_invoice_header qt on qt.id = bih.qutation_id
          LEFT JOIN transaction_type tt1 ON tt1.id = bih.transaction_type
          LEFT JOIN transaction_type tt2 ON tt2.id = qt.transaction_type
        where 
        bih.id = $1
        and bih.company_id = $2
        and bih.transaction_type = $3
        AND bih.is_deleted IS NULL
        `
        let params7 = [posted_elements.x, req.session.company_id, transaction_type];
        
        let query8 = `
        select
          bib.id,
          bib.item_id,
            ah.account_name,
            ah.item_unite,
            ah.account_type_id as item_type_id,
          bib.amount as amount,
          bib.unite_price as unite_price,
          COALESCE(bib.row_note, '') as row_note,
          bib.is_discount_percentage,
          bib.dicount_value,
          bib.tax_header_id as tax_header_id,
            sth.taxe_package_name
        from
          befor_invoce_body bib
        LEFT JOIN accounts_header ah on ah.id = bib.item_id
        LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id
        left join account_type at on at.id = ah.account_type_id
        where 
          bib.header_id = $1
          ;
        `
        let params8 = [posted_elements.x]
        
        
        let query9 = `
        select 
          bih.id,
              CONCAT(
                tt.doc_prefix, '-',
                SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
                LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
            ) AS account_name
        from
          befor_invoice_header bih
        LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
        where
          bih.transaction_type = 25
          and bih.company_id = $1
          and bih.is_deleted is NULL
          and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
           ` 
           qutation_id = isNaN(+posted_elements.x) ? null : posted_elements.x
      
           let params9 = [req.session.company_id, qutation_id]
        
           let query10 = `
           select 
             bih.id,
                 CONCAT(
                  tt.doc_prefix, '-',
                   SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
                   LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
               ) AS account_name
           from
             befor_invoice_header bih
            LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type 
           where
             bih.transaction_type = 26
             and bih.company_id = $1
             and bih.is_deleted is NULL
             and (bih.is_invoiced IS NULL or bih.id = $2);
              ` 
              
              // order_id = isNaN(+posted_elements.order_id) ? null : posted_elements.order_id
              order_id = null
              
              let params10 = [req.session.company_id, order_id]
        
        
        await db.tx(async (tx) => {
        
          const itemslocationsArray = await tx.any(query1, params1);
          // const salesmanArray = await tx.any(query2, params2);
          const taxHeaderArray = await tx.any(query3, params3);
          const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
          const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
          const itemsDataArray = await tx.any(query5, params5);
          const vendorsDataArray = await tx.any(query6, params6);
          const headerData = await tx.any(query7, params7);
          const bodyData = await tx.any(query8, params8);
          const purshasesQutationReferencesArray = await tx.any(query9, params9);
          const purshasesOrderReferencesArray = await tx.any(query10, params10);
        
          const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, headerData, bodyData, purshasesQutationReferencesArray, purshasesOrderReferencesArray};
          res.json(postedData);
        })
        
        
            await last_activity(req)
          } catch (error) {
            await last_activity(req)
            console.error("Error while get_data_for_purshasesQutationToInvoice  Data", error);
            res.join;
            res
              .status(500)
              .json({ success: false, message_ar: error.message || deafultErrorMessage,});
          }
        });

        app.post("/get_data_for_purshasesOrderToInvoice", async (req, res) => {
          try {
            //! Permission
            await permissions(req, "purshases_invoice_permission", "add");
            if (!permissions) {
              return;
            }
        
            
            const posted_elements = req.body;
            const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar:
                  "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
            //* Start--------------------------------------------------------------
            // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
        
            const transaction_type = 26
      
        
        
            let query1 = `
             -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
        select
          id as id,
          account_name as account_name
        from
          accounts_header 
        WHERE company_id = $1 
          AND account_type_id = 7
          AND is_inactive IS NULL
          ;
        `;
        let params1 = [req.session.company_id]
        
        // let query2 = `
        //   select
        //   id as id,
        //   account_name as account_name
        // from
        //   accounts_header 
        // WHERE company_id = $1 
        //   AND account_type_id = 4
        //   AND is_final_account IS true
        //   and is_salesman IS true
        //   AND is_inactive IS null
        //   ;
        // `
        // let params2 = [req.session.company_id]
        
        let query3 = `
            select 
          th.id,
          th.taxe_package_name as account_name
        from
           settings_tax_header th
        where
          th.company_id = $1
          and th.is_inactive is null
        order by
          th.taxe_package_name asc 
         
        `
        let params3 = [req.session.company_id]
        
        let query4 = `
        select
            tb.id,
            tb.tax_name,
            tb.tax_rate,
            tb.is_tax_reverse,
            tb.tax_account_id,
            ah.account_name,
            tb.settings_tax_header_id
        from
            settings_tax_body tb
        left join accounts_header ah on ah.id = tb.tax_account_id    
        where
            tb.settings_tax_header_id = ANY($1::int[])
            AND ah.is_inactive IS NULL
        `;
        
        
        let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
        `;
        
        let params5 = [req.session.company_id];
        
        
        let query6 = `
        select
          ah.id,
          ah.account_name
        from
          accounts_header ah
        where
          ah.company_id = $1
          AND ah.is_final_account is true
          AND is_inactive is null
          AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`
        
          let params6 = [req.session.company_id];
        
        
        let query7 = `
        select 
          bih.id,
          bih.reference,
          COALESCE(bih.general_note, '') as general_note,
          bih.datex,
          NULL as due_date,
          bih.account_id,
          bih.qutation_id,
          bih.is_delivered,
          bih.items_location_id,
          bih.is_column2 as is_row_note_show,
          bih.is_column1 as is_row_dicount_show,
          bih.is_column3 as is_row_tax_show,
          CONCAT(
            tt1.doc_prefix, '-',
            SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS referenceconcat,
          CONCAT(
            tt2.doc_prefix, '-',
            SUBSTRING(qt.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(qt.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS referenceconcat_qutation,
        NULL AS referenceconcat_order
        from
          befor_invoice_header bih
          left join befor_invoice_header qt on qt.id = bih.qutation_id
          LEFT JOIN transaction_type tt1 ON tt1.id = bih.transaction_type
          LEFT JOIN transaction_type tt2 ON tt2.id = qt.transaction_type
        where 
        bih.id = $1
        and bih.company_id = $2
        and bih.transaction_type = $3
        AND bih.is_deleted IS NULL
        `
        
        let params7 = [posted_elements.x, req.session.company_id, transaction_type];
        
        let query8 = `
        select
          bib.id,
          bib.item_id,
            ah.account_name,
            ah.item_unite,
            ah.account_type_id as item_type_id,
          bib.amount as amount,
          bib.unite_price as unite_price,
          COALESCE(bib.row_note, '') as row_note,
          bib.is_discount_percentage,
          bib.dicount_value,
          bib.tax_header_id as tax_header_id,
            sth.taxe_package_name
        from
          befor_invoce_body bib
        LEFT JOIN accounts_header ah on ah.id = bib.item_id
        LEFT JOIN settings_tax_header sth on sth.id = bib.tax_header_id
        left join account_type at on at.id = ah.account_type_id
        where 
          bib.header_id = $1
          ;
        `
        let params8 = [posted_elements.x]
        
        
        let query9 = `
        select 
          bih.id,
              CONCAT(
                tt.doc_prefix, '-',
                SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
                LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
            ) AS account_name
        from
          befor_invoice_header bih
        LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
        where
          bih.transaction_type = 25
          and bih.company_id = $1
          and bih.is_deleted is NULL
          and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
           ` 
           qutation_id = isNaN(+posted_elements.qutationId) ? null : posted_elements.qutationId
      
           let params9 = [req.session.company_id, qutation_id]
        
           let query10 = `
           select 
             bih.id,
                 CONCAT(
                  tt.doc_prefix, '-',
                   SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
                   LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
               ) AS account_name
           from
             befor_invoice_header bih
            LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type 
           where
             bih.transaction_type = 26
             and bih.company_id = $1
             and bih.is_deleted is NULL
             and (bih.is_invoiced IS NULL or bih.id = $2);
              ` 
              
              order_id = isNaN(+posted_elements.x) ? null : posted_elements.x
              
              let params10 = [req.session.company_id, order_id]
        
        
        await db.tx(async (tx) => {
        
          const itemslocationsArray = await tx.any(query1, params1);
          // const salesmanArray = await tx.any(query2, params2);
          const taxHeaderArray = await tx.any(query3, params3);
          const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
          const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
          const itemsDataArray = await tx.any(query5, params5);
          const vendorsDataArray = await tx.any(query6, params6);
          const headerData = await tx.any(query7, params7);
          const bodyData = await tx.any(query8, params8);
          const purshasesQutationReferencesArray = await tx.any(query9, params9);
          const purshasesOrderReferencesArray = await tx.any(query10, params10);
        
          const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, headerData, bodyData, purshasesQutationReferencesArray, purshasesOrderReferencesArray};
          res.json(postedData);
        })
        
        
            await last_activity(req)
          } catch (error) {
            await last_activity(req)
            console.error("Error while get_data_for_purshasesOrderToInvoice", error);
            res.join;
            res
              .status(500)
              .json({ success: false, message_ar: error.message || deafultErrorMessage, });
          }
        });

        app.post("/get_data_for_sales_purshasesInvoice_update", async (req, res) => {
          try {
            //! Permission
            await permissions(req, "purshases_invoice_permission", "update");
            if (!permissions) {
              return;
            }
        
            
            const posted_elements = req.body;
            const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar:
                  "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
            //* Start--------------------------------------------------------------
            // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
        
            const transaction_type = 6
      
        
        
            let query1 = `
             -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
        select
          id as id,
          account_name as account_name
        from
          accounts_header 
        WHERE company_id = $1 
          AND account_type_id = 7
          AND is_inactive IS NULL
          ;
        `;
        let params1 = [req.session.company_id]
        
        // let query2 = `
        //   select
        //   id as id,
        //   account_name as account_name
        // from
        //   accounts_header 
        // WHERE company_id = $1 
        //   AND account_type_id = 4
        //   AND is_final_account IS true
        //   and is_salesman IS true
        //   AND is_inactive IS null
        //   ;
        // `
        // let params2 = [req.session.company_id]
        
        let query3 = `
            select 
          th.id,
          th.taxe_package_name as account_name
        from
           settings_tax_header th
        where
          th.company_id = $1
          and th.is_inactive is null
        order by
          th.taxe_package_name asc 
         
        `
        let params3 = [req.session.company_id]
        
        let query4 = `
        select
            tb.id,
            tb.tax_name,
            tb.tax_rate,
            tb.is_tax_reverse,
            tb.tax_account_id,
            ah.account_name,
            tb.settings_tax_header_id
        from
            settings_tax_body tb
        left join accounts_header ah on ah.id = tb.tax_account_id    
        where
            tb.settings_tax_header_id = ANY($1::int[])
            AND ah.is_inactive IS NULL
        `;
        
        
        let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
        `;
        
        let params5 = [req.session.company_id];
        
        
        let query6 = `
        select
          ah.id,
          ah.account_name
        from
          accounts_header ah
        where
          ah.company_id = $1
          AND ah.is_final_account is true
          AND is_inactive is null
          AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`
        
          let params6 = [req.session.company_id];
        
        
        let query7 = `
        select 
          th.id,
          th.reference,
          COALESCE(th.general_note, '') as general_note,
          th.datex,
          th.due_date,
          th.account_id,
          th.qutation_id,
          th.order_id,
          th.is_delivered,
          th.items_location_id,
          th.is_column1 as is_row_dicount_show,
          th.is_column2 as is_row_note_show,
          th.is_column3 as is_row_tax_show,
          CONCAT(
            tt1.doc_prefix, '-',
            SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS referenceconcat,
          CONCAT(
            tt2.doc_prefix, '-',
            SUBSTRING(bih_qutation.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih_qutation.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS referenceconcat_qutation,
          CONCAT(
            tt3.doc_prefix, '-',
            SUBSTRING(bih_order.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
            LPAD(CAST(bih_order.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS referenceconcat_order
        from
          transaction_header th
        left join befor_invoice_header bih_qutation on bih_qutation.id = th.qutation_id
        left join befor_invoice_header bih_order on bih_order.id = th.order_id
        LEFT JOIN transaction_type tt1 ON tt1.id = th.transaction_type
        LEFT JOIN transaction_type tt2 ON tt2.id = bih_qutation.transaction_type
        LEFT JOIN transaction_type tt3 ON tt3.id = bih_order.transaction_type
        where 
        th.id = $1
        and th.company_id = $2
        and th.transaction_type = $3
        AND th.is_deleted IS NULL
        `
        let params7 = [posted_elements.x, req.session.company_id, transaction_type];
        
        let query8 = `
        select
          tb.id,
          tb.item_id,
            ah.account_name,
            ah.item_unite,
            ah.account_type_id as item_type_id,
          ABS(tb.item_amount) AS amount,
          tb.item_price as unite_price,
          COALESCE(tb.row_note, '') as row_note,
          tb.is_discount_percentage,
          tb.dicount_value,
          tb.settings_tax_header_id as tax_header_id,
            sth.taxe_package_name
        from
          transaction_body tb
        LEFT JOIN accounts_header ah on ah.id = tb.item_id
        LEFT JOIN settings_tax_header sth on sth.id = tb.settings_tax_header_id
        left join account_type at on at.id = ah.account_type_id
        where 
          tb.transaction_header_id = $1
          AND tb.item_id is NOT NULL
          ;
        `
        let params8 = [posted_elements.x]
        
        
        let query9 = `
        select 
          bih.id,
              CONCAT(
                tt.doc_prefix, '-',
                SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
                LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
            ) AS account_name
        from
          befor_invoice_header bih
        LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
        where
          bih.transaction_type = 25
          and bih.company_id = $1
          and bih.is_deleted is NULL
          and (bih.is_qutation_status IS NOT FALSE or bih.id = $2);
           ` 
           qutation_id = isNaN(+posted_elements.qutation_id) ? null : posted_elements.qutation_id
      
           let params9 = [req.session.company_id, qutation_id]
        
           let query10 = `
           select 
             bih.id,
                 CONCAT(
                  tt.doc_prefix, '-',
                   SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
                   LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
               ) AS account_name
           from
             befor_invoice_header bih
            LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type 
           where
             bih.transaction_type = 26
             and bih.company_id = $1
             and bih.is_deleted is NULL
             and (bih.is_invoiced IS NULL or bih.id = $2);
              ` 
              
              order_id = isNaN(+posted_elements.order_id) ? null : posted_elements.order_id
              
              let params10 = [req.session.company_id, order_id]
        
        
        await db.tx(async (tx) => {
        
          const itemslocationsArray = await tx.any(query1, params1);
          // const salesmanArray = await tx.any(query2, params2);
          const taxHeaderArray = await tx.any(query3, params3);
          const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
          const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
          const itemsDataArray = await tx.any(query5, params5);
          const vendorsDataArray = await tx.any(query6, params6);
          const headerData = await tx.any(query7, params7);
          const bodyData = await tx.any(query8, params8);
          const purshasesQutationReferencesArray = await tx.any(query9, params9);
          const purshasesOrderReferencesArray = await tx.any(query10, params10);
        
          const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, headerData, bodyData, purshasesQutationReferencesArray, purshasesOrderReferencesArray};
          res.json(postedData);
        })
        
        
            await last_activity(req)
          } catch (error) {
            await last_activity(req)
            console.error("Error while get_data_for_sales_purshasesInvoice_update", error);
            res.join;
            res
              .status(500)
              .json({ success: false,message_ar: error.message || deafultErrorMessage,});
          }
        });
      
        app.post("/api/purshases_invoice_add", async (req, res) => {
          try {
        
            //! Permission
            await permissions(req, "purshases_invoice_add", "add");
            if (!permissions) {
              return res.status(403).json({
                success: false,
                message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
              });
            }
      
      
      
        
            const posted_elements = req.body;
            const transaction_type = 6
            let items_array = []
          
        
            //! sql injection check
            let hasBadSymbols = sql_anti_injection([
              ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
              posted_elements.vendorId,
              posted_elements.total,
              posted_elements.datex,
              posted_elements.dueDate,
              posted_elements.orderReferenceId,
              posted_elements.qutationReferenceId,
              posted_elements.itemLocationId,
              posted_elements.is_RowNote,
              posted_elements.is_RowDiscount,
              posted_elements.general_note,
              posted_elements.location_name,
              // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
            ]);
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar: sql_injection_message_ar,
                message_en: sql_injection_message_en,
              });
            }
        
        
            const InValidDateFormat = isInValidDateFormat([posted_elements.datex, posted_elements.dueDate]);
            if (InValidDateFormat) {
              return res.status(400).json({
                success: false,
                message_ar: InValidDateFormat_message_ar,
              });
            }
        
            //! settings
            const settings = await check_settings_validation({
              check_futureDate: true,
              check_closingDate: true,
              datex: posted_elements.datex,
              type: 'add',
              tableName: false, // if type = 'update' or 'delete' only
              transaction_id: false, // if type = 'update' or 'delete' only
            }, req);
        
            
            if (!settings.valid) {
              return res.json({
                success: false,
                message_ar: settings.message_ar,
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
        
            
      
            //* Start Transaction --------------------------------------------------
        
           const total = +posted_elements.total
      
           if (!total || isNaN(total)){
            await block_user(req,'Spia001')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
           }
      
        
        // //! Security hacking  accounts id
       
           // check qutationReferenceId
      
      
           let query04;
           let rows04;
           if (posted_elements.qutationReferenceId){
             query04 = `select id, is_qutation_status from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 25 and is_deleted IS NULL`
             rows04 = await db.oneOrNone(query04, [posted_elements.qutationReferenceId, req.session.company_id])
            if (!rows04 || !rows04.id){
              await block_user(req,'Spqi01')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }
            }
      
      
            let query05;
            let rows05;
            if (posted_elements.orderReferenceId){
              query05 = `select count(id) as salesOrderReferenceCount from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 26 and is_deleted IS NULL AND is_invoiced IS NULL`
              rows05 = await db.oneOrNone(query05, [posted_elements.orderReferenceId, req.session.company_id])
             if (rows05.salesOrderReferenceCount === 0){
               await block_user(req,'Spia02')
               return res.json({
                 success: false,
                 xx: true,
                 message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
               });
             }
             }
      
        // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
        let rows02 = await db.any(query02, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbAccounts = rows02.map(row => ({
          id: parseInt(row.id),
          account_type_id: row.account_type_id,
          // is_salesman: row.is_salesman
        }));
      
        //check salesman
      
        // const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
      
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          // if (!count_salesman) {
          //   await block_user(req,'Ssia03')
          //   return res.json({
          //     success: false,
          //     xx: true,
          //     message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          //   });
          // }

          const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!count_itemLocation) {
            await block_user(req,'Spia04')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
      
      
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const item_typeId = rowData.item_typeId;
          const item_id = rowData.item_id;
      
        
          //! make sure from every account_id
          const accountExists = dbAccounts.some(item => 
            +item.id === +item_id && +item.account_type_id === +item_typeId
          );
        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!accountExists) {
            await block_user(req,'Spqa5')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
      
          items_array.push(+rowData.item_id)
        }
        
        
            // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
            let rows03 = await db.any(query03, [req.session.company_id]);
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
            const dbTaxesHeaderArray = rows03.map(row => ({
              id: parseInt(row.id)
            }));
            
      
            // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
            for (const rowData of posted_elements.posted_array) {
              const row_taxHeaderId = rowData.row_taxHeaderId;
              
              if (row_taxHeaderId){
              //! make sure from every account_id
              const taxExists = dbTaxesHeaderArray.some(item =>
                +item.id === +row_taxHeaderId
              );
              
      
            
              // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
              if (!taxExists) {
                await block_user(req,'Spia6')
                return res.json({
                  success: false,
                  xx: true,
                  message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                });
              }
            }
            }
        

            const year = getYear(posted_elements.datex)
            const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header', 6, year, req);
            const newId_general_reference = await newId_fn("transaction_header", 'general_reference');
      
      
            
      
            // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            await db.tx(async (tx) => {
      
      
              if (rows04 && rows04.is_qutation_status === null) {
                await tx.none(
                  `UPDATE befor_invoice_header 
                   SET is_qutation_status = true 
                   WHERE id = $1 AND company_id = $2`,
                  [+posted_elements.qutationReferenceId, req.session.company_id]
                );
              }
              
      
              
              if(rows05){
                if(rows05.salesorderreferencecount && +rows05.salesorderreferencecount > 0){
                  await tx.none(
                    `UPDATE befor_invoice_header 
                     SET is_invoiced = true 
                     WHERE id = $1 AND company_id = $2`,
                    [+posted_elements.orderReferenceId, req.session.company_id]
                  );
                }
              }
      
      
              let query1 = `INSERT INTO transaction_header
                            (reference, company_id, transaction_type, total_value, general_note, datex, account_id, due_date, is_column1, is_column2, is_column3, items_location_id, order_id, qutation_id, general_reference, is_including_items)
                            VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12, $13, $14, $15, $16) RETURNING id;`;
        
              const insert = await tx.one(query1, [
                newReference_transaction_header,
                req.session.company_id,
                transaction_type,
                total.toFixed(2),
                posted_elements.general_note,
                posted_elements.datex,
                posted_elements.vendorId,
                posted_elements.dueDate,
                posted_elements.is_RowDiscount ? true : null,
                posted_elements.is_RowNote ? true : null,
                posted_elements.is_RowTax ? true : null,
                posted_elements.itemLocationId,
                posted_elements.orderReferenceId,
                posted_elements.qutationReferenceId,
                newId_general_reference,
                true
              ]);
              const newId_transaction_header = insert.id;

              let global_stock_id = await tx.oneOrNone(`select id from accounts_header ah where ah.company_id = 1 and ah.global_id = 12`, [req.session.company_id])
              let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
              let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')
      
              let other_posted_array = []
              let Val_beforTax = 0
              let taxValue = 0
              let TotalValue = 0
              let insert_array2 = []
              for (const element of posted_elements.posted_array) {
        
                //! make sure if account id != item  then location and amount = null
      
                if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
                  await block_user(req,'Spia7')
                  throw new Error(
                    'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
                  );
                }
      
                //! check amount
                
                // const current_location_amount_data = items_amount_location.find(item => +item.item_id === +element.item_id);
                // const db_amount = +(current_location_amount_data?.current_location_amount || 0);
                // const result_amount = db_amount - +element.row_amount;
                  
                // if (isNaN(result_amount) || result_amount <= 0) {       
                //   throw new Error(
                //     `Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙ‰ ÙÙ‰ Ù…ÙˆÙ‚Ø¹ ${posted_elements.location_name} Ù„Ù„ØµÙ†Ù ${element.item_name}`
                //   );
                // }
      
                
               const rowDiscountType = +element.row_discountTypeId || 0
               const rowDiscountValue= +element.row_discountValue || 0
               const rowAmount = +element.row_amount || 0
               const rowUnitePrice = +element.row_unitPrice || 0
      
                const Xrow_discount_value =
                rowDiscountType === 1
                    ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
                    : +rowDiscountValue;
                    Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
                    TotalValue += Val_beforTax
                    
      
                    let account_id
                    if (+element.item_typeId === 5){
                      account_id = +global_stock_id.id
                    }else{
                      const account_row = DeafultAccounts.find(item => +item.id === element.item_id);
                    
                      if (!account_row){
                        await block_user(req,'Spia4')
                        throw new Error(
                          'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
                        );
                      }
                      account_id = +account_row.item_expense_account 
                    }
                    
                insert_array2.push([
                  newId_transaction_header,
                  +Val_beforTax, // debit
                  null,  // credit
                  element.row_note,
                  +element.row_amount,
                  +element.row_unitPrice,
                  +account_id,
                  +element.row_discountTypeId === 1 ? true : null,
                  element.row_discountValue || null,
                  element.row_taxHeaderId || null,
                  null,
                  null,
                  +element.item_typeId === 5? element.item_id : null,
                  +element.item_typeId === 5? posted_elements.itemLocationId : null
                ]);
      
                //! check if has taxHeader
                if (element.row_taxHeaderId){
                  const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
                  if (taxesbodyArray){
                    for (const row of taxesbodyArray){
                      const taxRate = +row.tax_rate /100
                      const taxMultiplier = row.is_tax_reverse ? -1 : 1;
                      taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
                      TotalValue += taxValue
      
                      const newObject = {
                        taxBodyId: row.id,
                        taxHeaderId: row.settings_tax_header_id,
                        debit: taxValue > 0 ? taxValue : null,
                        credit: taxValue < 0 ? taxValue*-1 : null,
                        account_id: row.tax_account_id,
                        is_tax: true
                      }
                      other_posted_array.push(newObject)
                    }
                  }
                }
      
              }
      
                
      
              //! add vendor row to transaction
              const newObject = {
                taxBodyId: null,
                taxHeaderId: null,
                debit: TotalValue < 0 ? TotalValue*-1 : null,
                credit: TotalValue > 0 ? TotalValue : null,
                account_id: posted_elements.vendorId,
                is_tax: null
              }
              other_posted_array.push(newObject)
      
              //! insert the other part to transaction
              for (const object of other_posted_array){
            
                insert_array2.push([
                newId_transaction_header,
                +object.debit || null,
                +object.credit || null,
                null,
                null,
                null,
                +object.account_id,
                null,
                null,
                +object.taxHeaderId || null,
                +object.taxBodyId || null,
                object.is_tax,
                null,
                null
                ]);

              }
        
              if (insert_array2.length > 0){
                let columnsCount = insert_array2[0].length;
              let query2 = `INSERT INTO transaction_body
              (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id,  is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
              VALUES ${insert_array2.map((_, i) => 
                `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
              ).join(', ')}`;
              await tx.none(query2, insert_array2.flat());
            }
      
      
              //! history
              await update_items_cogs(items_array,posted_elements.datex, req, tx)
              await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
            });
        
            // await update_items_cogs(req,items_array,posted_elements.datex)
            const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
            await last_activity(req);
            // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
            return res.json({
              success: true,
              message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙØ§ØªÙˆØ±Ø© Ù…Ø´ØªØ±ÙŠØ§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
            });
          } catch (error) {
            await last_activity(req);
            console.error("Error purshases_invoice_add:", error);
        
            // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
            return res.json({
              success: false,
              message_ar: error.message || deafultErrorMessage,
            });
          }
        });

        app.post("/get_data_for_purshases_invoice_add", async (req, res) => {
          try {
            //! Permission
            await permissions(req, "sales_invoice_permission", "add");
            if (!permissions) {
              return;
            }
        
            //* Start--------------------------------------------------------------
            // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
        
            let query1 = `
             -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
        select
          id as id,
          account_name as account_name
        from
          accounts_header 
        WHERE company_id = $1 
          AND account_type_id = 7
          ;
        `;
        let params1 = [req.session.company_id]
        
        // let query2 = `
        //   select
        //   id as id,
        //   account_name as account_name
        // from
        //   accounts_header 
        // WHERE company_id = $1 
        //   AND account_type_id = 4
        //   AND is_final_account IS true
        //   and is_salesman IS true
        //   AND is_inactive IS null
        //   ;
        // `
        // let params2 = [req.session.company_id]
        
        let query3 = `
            select 
          th.id,
          th.taxe_package_name as account_name
        from
           settings_tax_header th
        where
          th.company_id = $1
          and th.is_inactive is null
        order by
          th.taxe_package_name asc 
         
        `
        let params3 = [req.session.company_id]
        
        let query4 = `
        select
            tb.id,
            tb.tax_name,
            tb.tax_rate,
            tb.is_tax_reverse,
            tb.tax_account_id,
            ah.account_name,
            tb.settings_tax_header_id
        from
            settings_tax_body tb
        left join accounts_header ah on ah.id = tb.tax_account_id    
        where
            tb.settings_tax_header_id = ANY($1::int[])
        `;
        
        
        let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
        `;
        
        let params5 = [req.session.company_id];
        
        
        let query6 = `
        select
          ah.id,
          ah.account_name
        from
          accounts_header ah
        where
          ah.company_id = $1
          AND ah.is_final_account is true
          AND is_inactive is null
          AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`
        
          let params6 = [req.session.company_id];
        
      
         let query7 = `
      select 
        bih.id,
            CONCAT(
              tt.doc_prefix, '-',
              SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
              LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
          ) AS account_name
      from
        befor_invoice_header bih
      LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type  
      where
        bih.transaction_type = 25
        and bih.company_id = $1
        and bih.is_deleted is NULL
        and bih.is_qutation_status IS NOT FALSE;
         ` 
         let params7 = [req.session.company_id]
      
         let query8 = `
         select 
           bih.id,
               CONCAT(
                tt.doc_prefix, '-',
                 SUBSTRING(bih.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
                 LPAD(CAST(bih.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
             ) AS account_name
         from
           befor_invoice_header bih
          LEFT JOIN transaction_type tt ON tt.id = bih.transaction_type 
         where
           bih.transaction_type = 26
           and bih.company_id = $1
           and bih.is_deleted is NULL
           and bih.is_invoiced is NULL;
            ` 
            let params8 = [req.session.company_id]
      
        await db.tx(async (tx) => {
        
          const itemslocationsArray = await tx.any(query1, params1);
          // const salesmanArray = await tx.any(query2, params2);
          const taxHeaderArray = await tx.any(query3, params3);
          const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
          const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
          const itemsDataArray = await tx.any(query5, params5);
          const vendorsDataArray = await tx.any(query6, params6);
          const purshasesQutationReferencesArray = await tx.any(query7, params7);
          const purshasesOederReferencesArray = await tx.any(query8, params8);
        
          const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, purshasesQutationReferencesArray, purshasesOederReferencesArray };
          res.json(postedData);
        })
        
        
            await last_activity(req)
          } catch (error) {
            await last_activity(req)
            console.error("Error while get_data_for_purshases_invoice_add", error);
            res.join;
            res
              .status(500)
              .json({ success: false, message_ar: error.message || deafultErrorMessage, });
          }
        });

        app.post("/api/purshases_invoice_update", async (req, res) => {
          try {
        
            //! Permission Ù…Ø¹Ù„Ù‚
            await permissions(req, "purshases_invoice_permission", "update");
            if (!permissions) {
              return res.status(403).json({
                success: false,
                message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
              });
            }
        
            const posted_elements = req.body;
            const transaction_type = 6
            let items_array = []
          
        
            //! sql injection check
            let hasBadSymbols = sql_anti_injection([
              ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
              posted_elements.x,
              posted_elements.vendorId,
              posted_elements.total,
              posted_elements.datex,
              posted_elements.dueDate,
              posted_elements.orderReferenceId,
              posted_elements.qutationReferenceId,
              posted_elements.itemLocationId,
              posted_elements.is_RowNote,
              posted_elements.is_RowDiscount,
              posted_elements.general_note,
              posted_elements.location_name,
              // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
            ]);
            if (hasBadSymbols) {
              return res.json({
                success: false,
                message_ar: sql_injection_message_ar,
                message_en: sql_injection_message_en,
              });
            }
        
        
            const InValidDateFormat = isInValidDateFormat([posted_elements.datex, posted_elements.dueDate]);
            if (InValidDateFormat) {
              return res.status(400).json({
                success: false,
                message_ar: InValidDateFormat_message_ar,
              });
            }
        
            //! settings
            const settings = await check_settings_validation({
              check_futureDate: true,
              check_closingDate: true,
              datex: posted_elements.datex,
              type: 'update',
              tableName: 'transaction_header', // if type = 'update' or 'delete' only
              transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
            }, req);
        
            
            if (!settings.valid) {
              return res.json({
                success: false,
                message_ar: settings.message_ar,
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
        
            
      
            //* Start Transaction --------------------------------------------------
        
           const total = +posted_elements.total
      
           if (!total || isNaN(total)){
            await block_user(req,'Spiu001')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
           }
      
        
        // //! Security hacking  accounts id
       
           // check qutationReferenceId
      
           let query_1 = `select reference from transaction_header where id = $1 AND company_id = $2 AND is_deleted IS NULL`
           const result_1 = await db.oneOrNone(query_1,[posted_elements.x, req.session.company_id])
           if (!result_1){
            await block_user(req,'Spqu02')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
           }
      
      
           let query04;
           let rows04;
           if (posted_elements.qutationReferenceId){      
             query04 = `select id, is_qutation_status from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 25 and is_deleted IS NULL`
             rows04 = await db.oneOrNone(query04, [posted_elements.qutationReferenceId, req.session.company_id])
            if (!rows04 || !rows04.id){
              await block_user(req,'Spqu03')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }
            }
      
      
      
      
            let query05;
            let rows05;
            if (posted_elements.orderReferenceId){
              query05 = `select count(id) as salesOrderReferenceCount from befor_invoice_header where id = $1 and company_id = $2 and transaction_type = 26 and is_deleted IS NULL AND is_invoiced IS NULL`
              rows05 = await db.oneOrNone(query05, [posted_elements.orderReferenceId, req.session.company_id])
             if (rows05.salesOrderReferenceCount === 0){
               await block_user(req,'Spiau04')
               return res.json({
                 success: false,
                 xx: true,
                 message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
               });
             }
             }
      
        // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
        let rows02 = await db.any(query02, [req.session.company_id]);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
        const dbAccounts = rows02.map(row => ({
          id: parseInt(row.id),
          account_type_id: row.account_type_id,
          // is_salesman: row.is_salesman
        }));
      
        //check salesman
      
        // const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
      
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          // if (!count_salesman) {
          //   await block_user(req,'Ssqu05')
          //   return res.json({
          //     success: false,
          //     xx: true,
          //     message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          //   });
          // }

          const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!count_itemLocation) {
            await block_user(req,'Spqu06')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
      
      
        // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
        for (const rowData of posted_elements.posted_array) {
          const item_typeId = rowData.item_typeId;
          const item_id = rowData.item_id;
      
        
          //! make sure from every account_id
          const accountExists = dbAccounts.some(item => 
            +item.id === +item_id && +item.account_type_id === +item_typeId
          );
        
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
          if (!accountExists) {
            await block_user(req,'Spqu07')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });
          }
      
          items_array.push(+rowData.item_id)
        }
        
        
            // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
            let rows03 = await db.any(query03, [req.session.company_id]);
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
            const dbTaxesHeaderArray = rows03.map(row => ({
              id: parseInt(row.id)
            }));
            
      
            // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
            for (const rowData of posted_elements.posted_array) {
              const row_taxHeaderId = rowData.row_taxHeaderId;
              
              if (row_taxHeaderId){
              //! make sure from every account_id
              const taxExists = dbTaxesHeaderArray.some(item =>
                +item.id === +row_taxHeaderId
              );
              
      
            
              // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
              if (!taxExists) {
                await block_user(req,'Spqu08')
                return res.json({
                  success: false,
                  xx: true,
                  message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
                });
              }
            }
            }
        
      

            
            const year = getYear(posted_elements.datex)
      
            // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            await db.tx(async (tx) => {
      
              let query01 = `SELECT qutation_id, order_id FROM transaction_header WHERE id = $1 AND company_id = $2 AND is_deleted IS NULL;`;
              let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
              
       
      
                    //! qutation_id check and update
                    const db_qutation_id = rows01.qutation_id || 0
                    const posted_qutation_id = posted_elements.qutationReferenceId || 0
                    if (+db_qutation_id !== +posted_qutation_id){
                      if (+db_qutation_id !== 0) {
                        const q1 = `
                          SELECT 
                            (SELECT COUNT(id) FROM befor_invoice_header WHERE qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_befor_invoice_header,
                            (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                        `;                  
                        let result1 = await tx.oneOrNone(q1, [+posted_elements.x, +db_qutation_id, req.session.company_id]);                  
                        if (+result1.count_befor_invoice_header === 0 && +result1.count_transaction_header === 0) {
                          const updateQuery1 = `UPDATE befor_invoice_header SET is_qutation_status = NULL WHERE id = $1 AND company_id = $2`;
                          await tx.none(updateQuery1, [+db_qutation_id, req.session.company_id]);
                        }
                      }
                      if (+posted_qutation_id !== 0) {
                        const updateQuery2 = `UPDATE befor_invoice_header SET is_qutation_status = true WHERE id = $1 AND company_id = $2`;
                        await tx.none(updateQuery2, [+posted_qutation_id, req.session.company_id]);
                      }
                    }
      
      
                    //! order_id check and update
                    const db_order_id = rows01.order_id || 0
                    const posted_order_id = posted_elements.orderReferenceId || 0
                    if (+db_order_id !== +posted_order_id){
                      if (+db_order_id !== 0) {
                        const q01 = `
                          SELECT 
                            (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND order_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                        `;                  
                        let result01 = await tx.oneOrNone(q01, [+posted_elements.x, +db_order_id, req.session.company_id]);                  
                        if (+result01.count_transaction_header === 0) {
                          const updateQuery01 = `UPDATE befor_invoice_header SET is_invoiced = NULL WHERE id = $1 AND company_id = $2`;
                          await tx.none(updateQuery01, [+db_order_id, req.session.company_id]);
                        }
                      }
                      if (+posted_order_id !== 0) {
                        const updateQuery02 = `UPDATE befor_invoice_header SET is_invoiced = true WHERE id = $1 AND company_id = $2`;
                        await tx.none(updateQuery02, [+posted_order_id, req.session.company_id]);
                      }
                    }              
      
      
              let query1 = `update transaction_header
                            set total_value = $1,
                              general_note = $2,
                              datex = $3,
                              account_id = $4,
                              due_date = $5,
                              is_column1 = $6,
                              is_column2 = $7,
                              is_column3 = $8,
                              items_location_id = $9,
                              order_id = $10,
                              qutation_id = $11
                            Where
                              id = $12
                              AND company_id = $13
                              AND transaction_type = $14
                              AND is_deleted IS NULL
                            ;`;
        
              await tx.none(query1, [
                total.toFixed(2),
                posted_elements.general_note,
                posted_elements.datex,
                posted_elements.vendorId,
                posted_elements.dueDate,
                posted_elements.is_RowDiscount ? true : null,
                posted_elements.is_RowNote ? true : null,
                posted_elements.is_RowTax ? true : null,
                posted_elements.itemLocationId,
                posted_elements.orderReferenceId,
                posted_elements.qutationReferenceId,
                posted_elements.x,
                req.session.company_id,
                transaction_type
              ]);
        
              const query_delete = `delete from transaction_body where transaction_header_id = $1`
              await tx.none(query_delete,[posted_elements.x])
      
              let global_stock_id = await tx.oneOrNone(`select id from accounts_header ah where ah.company_id = 1 and ah.global_id = 12`, [req.session.company_id])
              let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
              let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')
      
              let other_posted_array = []
              let Val_beforTax = 0
              let taxValue = 0
              let TotalValue = 0
              let insert_array2 = []
              for (const element of posted_elements.posted_array) {
        
                //! make sure if account id != item  then location and amount = null
      
                if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
                  await block_user(req,'Spia3')
                  throw new Error(
                    'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
                  );
                }
      
                //! check amount           
                // const current_location_amount_data = items_amount_location.find(item => +item.item_id === +element.item_id);
                // const db_amount = +(current_location_amount_data?.current_location_amount || 0);
                // const result_amount = db_amount - +element.row_amount;
                  
                // if (isNaN(result_amount) || result_amount <= 0) {       
                //   throw new Error(
                //     `Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙ‰ ÙÙ‰ Ù…ÙˆÙ‚Ø¹ ${posted_elements.location_name} Ù„Ù„ØµÙ†Ù ${element.item_name}`
                //   );
                // }
      
                
               const rowDiscountType = +element.row_discountTypeId || 0
               const rowDiscountValue= +element.row_discountValue || 0
               const rowAmount = +element.row_amount || 0
               const rowUnitePrice = +element.row_unitPrice || 0
      
                const Xrow_discount_value =
                rowDiscountType === 1
                    ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
                    : +rowDiscountValue;
                    Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
                    TotalValue += Val_beforTax
                    
      
                    let account_id
                    if (+element.item_typeId === 5){
                      account_id = +global_stock_id.id
                    }else{
                      const account_row = DeafultAccounts.find(item => +item.id === element.item_id);
                    
                      if (!account_row){
                        await block_user(req,'Spia4')
                        throw new Error(
                          'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
                        );
                      }
                      account_id = +account_row.item_expense_account 
                    }
                    
        
                insert_array2.push([
                  posted_elements.x,
                  +Val_beforTax,
                  null,
                  element.row_note,
                  +element.row_amount,
                  +element.row_unitPrice,
                  +account_id,
                  +element.row_discountTypeId === 1 ? true : null,
                  element.row_discountValue || null,
                  element.row_taxHeaderId || null,
                  null,
                  null,
                  +element.item_typeId === 5? element.item_id : null,
                  +element.item_typeId === 5? posted_elements.itemLocationId : null
                ]);
      
                //! check if has taxHeader
                if (element.row_taxHeaderId){
                  const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
                  if (taxesbodyArray){
                    for (const row of taxesbodyArray){
                      const taxRate = +row.tax_rate /100
                      const taxMultiplier = row.is_tax_reverse ? -1 : 1;
                      taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
                      TotalValue += taxValue
      
                      const newObject = {
                        taxBodyId: row.id,
                        taxHeaderId: row.settings_tax_header_id,
                        debit: taxValue > 0 ? taxValue : null,
                        credit: taxValue < 0 ? taxValue*-1 : null,
                        account_id: row.tax_account_id,
                        is_tax: true
                      }
                      other_posted_array.push(newObject)
                    }
                  }
                }
      
              }
      
                
      
              //! add customer row to transaction
              const newObject = {
                taxBodyId: null,
                taxHeaderId: null,
                debit: TotalValue < 0 ? TotalValue*-1 : null,
                credit: TotalValue > 0 ? TotalValue : null,
                account_id: posted_elements.vendorId,
                is_tax: null
              }
              other_posted_array.push(newObject)
      
              //! insert the other part to transaction
              for (const object of other_posted_array){
      
                insert_array2.push([
                posted_elements.x,
                +object.debit || null,
                +object.credit || null,
                null,
                null,
                null,
                +object.account_id,
                null,
                null,
                +object.taxHeaderId || null,
                +object.taxBodyId || null,
                object.is_tax,
                null,
                null
                ]);
      
              }
              if (insert_array2.length > 0){
                let columnsCount = insert_array2[0].length;
              let query2 = `INSERT INTO transaction_body
              (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id,  is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
              VALUES ${insert_array2.map((_, i) => 
                `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
              ).join(', ')}`;
            
            await tx.none(query2, insert_array2.flat());
            }
      
              //! history
              await update_items_cogs(items_array,posted_elements.datex, req, tx)
              await history(transaction_type,2,posted_elements.x,result_1.reference,req,tx);
            });
        
            // await update_items_cogs(req,items_array,posted_elements.datex)
            const new_referenceFormatting = formatFromFiveDigits(result_1.reference);
            await last_activity(req);
            // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
            return res.json({
              success: true,
              message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„  ÙØ§ØªÙˆØ±Ø© Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
            });
          } catch (error) {
            await last_activity(req);
            console.error("Error purshases_invoice_update:", error);
        
            // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
            return res.json({
              success: false,
              message_ar: error.message || deafultErrorMessage,
            });
          }
        });

        app.post("/api/purshases_invoice_delete", async (req, res) => {
          try {
        
            // //! Permission Ù…Ø¹Ù„Ù‚
            // await permissions(req, "transaction_permission", "add");
            // if (!permissions) {
            //   return res.status(403).json({
            //     success: false,
            //     message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
            //   });
            // }
      
            const posted_elements = req.body;
            const transaction_type = 6
          
        
              //! sql injection check
              const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
              if (hasBadSymbols) {
                return res.json({
                  success: false,
                  message_ar:
                    "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
                });
              }
        
        
            const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
            if (InValidDateFormat) {
              return res.status(400).json({
                success: false,
                message_ar: InValidDateFormat_message_ar,
              });
            }
        
            //! settings
            const settings = await check_settings_validation({
              check_futureDate: true,
              check_closingDate: true,
              datex: posted_elements.datex,
              type: 'delete',
              tableName: 'transaction_header', // if type = 'update' or 'delete' only
              transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
            }, req);
        
            
            if (!settings.valid) {
              return res.json({
                success: false,
                message_ar: settings.message_ar,
              });
            }
        
            turn_EmptyValues_TO_null(posted_elements);
        
            
      
            //* Start Transaction --------------------------------------------------
        
      
        
        // //! Security hacking  accounts id
       
       
            let query1 = `select reference, datex from transaction_header where id = $1 and company_id = $2 and is_deleted IS NULL `
            let result1 = await db.oneOrNone(query1,[posted_elements.x, req.session.company_id])
      
            if (!result1){
              await block_user(req,'Spid001')
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }
            
            const year = getYear(result1.datex)
      
      
            let query2 = `select item_id from transaction_body where transaction_header_id = $1 AND item_id IS NOT NULL`;
            let result2 = await db.any(query2, [posted_elements.x]);
            
            if (!result2 || result2.length === 0) {
              await block_user(req, 'Spid001');
              return res.json({
                success: false,
                xx: true,
                message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
              });
            }
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ø£Ø±Ù‚Ø§Ù…
            const items_array = result2.map(row => row.item_id);
            
          
            // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            await db.tx(async (tx) => {



              let query01 = `SELECT qutation_id, order_id FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = 6 AND is_deleted IS NULL;`;
              let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id]);
              
       
      
                    //! qutation_id check and update
                    const db_qutation_id = rows01.qutation_id || 0
                      if (+db_qutation_id !== 0) {
                        const q1 = `
                          SELECT 
                            (SELECT COUNT(id) FROM befor_invoice_header WHERE qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_befor_invoice_header,
                            (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND qutation_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                        `;                  
                        let result1 = await tx.oneOrNone(q1, [+posted_elements.x, +db_qutation_id, req.session.company_id]);                  
                        if (+result1.count_befor_invoice_header === 0 && +result1.count_transaction_header === 0) {
                          const updateQuery1 = `UPDATE befor_invoice_header SET is_qutation_status = NULL WHERE id = $1 AND company_id = $2`;
                          await tx.none(updateQuery1, [+db_qutation_id, req.session.company_id]);
                        }
                      }

      
      
                    //! order_id check and update
                    const db_order_id = rows01.order_id || 0
                      if (+db_order_id !== 0) {
                        const q01 = `
                          SELECT 
                            (SELECT COUNT(id) FROM transaction_header WHERE id != $1 AND order_id = $2 AND company_id = $3 AND is_deleted IS NULL) AS count_transaction_header
                        `;                  
                        let result01 = await tx.oneOrNone(q01, [+posted_elements.x, +db_order_id, req.session.company_id]);                  
                        if (+result01.count_transaction_header === 0) {
                          const updateQuery01 = `UPDATE befor_invoice_header SET is_invoiced = NULL WHERE id = $1 AND company_id = $2`;
                          await tx.none(updateQuery01, [+db_order_id, req.session.company_id]);
                        }
                      }


              let query1 = `update transaction_header
                            set is_deleted = true
                            Where
                              id = $1
                              AND company_id = $2
                              AND transaction_type = 6
                            ;`;

              const resultQ1 = await tx.result(query1, [
                posted_elements.x,
                req.session.company_id
              ]);
      
              if (resultQ1.rowCount === 0) {
                await block_user(req,'Spid1')
                throw new Error(
                  'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
                );
              }
        
              const query_delete = `delete from transaction_body where transaction_header_id = $1`
              await tx.none(query_delete,[posted_elements.x])
      
      
              //! history
              await update_items_cogs(items_array,result1.datex, req, tx)
              await history(transaction_type,3,posted_elements.x,result1.reference,req,tx);
            });
      
            // await update_items_cogs(req,items_array,result1.datex)
            const new_referenceFormatting = formatFromFiveDigits(result1.reference);
            await last_activity(req);
            // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
            return res.json({
              success: true,
              message_ar: `âœ… ØªÙ… Ø­Ø°Ù  ÙØ§ØªÙˆØ±Ø© Ù…Ø´ØªØ±ÙŠØ§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
            });
          } catch (error) {
            await last_activity(req);
            console.error("Error purshases_invoice_delete:", error);
        
            // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
            return res.json({
              success: false,
              message_ar: error.message || deafultErrorMessage,
            });
          }
        });
//#endregion purshases invoice

//#endregion

//#region services

app.post("/services_view_ar", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "services_permission", "view");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
   select
	ah.id,
	ah.account_name,
	ah.account_no,
	CASE 
    	WHEN
      		ah.is_inactive = true THEN 'ØºÙŠØ± Ù†Ø´Ø·'
    	ELSE
     		'Ù†Ø´Ø·'
  	END as is_inactive
from
	accounts_header ah
where 
	ah.company_id = $1
	and ah.is_final_account is true
	and ah.account_type_id = 8
    `;
    
    let data = await db.any(query1, [req.session.company_id]);

    res.json(data);
  } catch (error) {
    console.error("Error while get accounts Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false,message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/get_data_for_services_add", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "services_permission", "add");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     -- Ø§Ù„Ø§ÙŠØ±Ø§Ø¯Ø§Øª
select
	ah.id,
	ah.account_name,
	ah.global_id
from
	accounts_header ah
where 
	ah.company_id = $1
	and ah.is_final_account is true
	and ah.account_type_id = 1
	and ah.is_inactive is null
	and ah.main_account_id = 4
  ;
`;
let params1 = [req.session.company_id]

let query2 = `
-- Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª
SELECT
ah.id,
ah.account_name,
ah.global_id
FROM
accounts_header ah
WHERE 
ah.company_id = $1
AND ah.is_final_account IS TRUE
AND ah.account_type_id = 1
AND ah.is_inactive IS NULL
AND ah.main_account_id = 5
AND (ah.global_id NOT IN (17, 18) OR ah.global_id IS NULL);

;
`;
let params2 = [req.session.company_id]

let query3 = `
-- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§ÙŠØ±Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶Ù‰ - Ø§ÙŠØ±Ø§Ø¯Ø§Øª Ù…Ø¨ÙŠØ¹Ø§Øª - Ø®Ø¯Ù…Ø§Øª
  select id from accounts_header ah where ah.global_id = 24 and ah.company_id = $1
;
`;
let params3 = [req.session.company_id]

await db.tx(async (tx) => {

  const revenueAccountsArray = await tx.any(query1, params1);
  const expensesAccountsArray = await tx.any(query2, params2);
  const revenueDeafulAccount = await tx.oneOrNone(query3, params3);


  const postedData = { revenueAccountsArray, expensesAccountsArray, revenueDeafulAccount};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/get_data_for_services_update", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "services_permission", "add");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
  
      //! sql injection check
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


      turn_EmptyValues_TO_null(posted_elements);

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     -- Ø§Ù„Ø§ÙŠØ±Ø§Ø¯Ø§Øª
select
	ah.id,
	ah.account_name,
	ah.global_id
from
	accounts_header ah
where 
	ah.company_id = $1
	and ah.is_final_account is true
	and ah.account_type_id = 1
	and ah.is_inactive is null
	and ah.main_account_id = 4
  ;
`;
let params1 = [req.session.company_id]

let query2 = `
-- Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª
select
ah.id,
ah.account_name,
ah.global_id
from
accounts_header ah
where 
ah.company_id = $1
and ah.is_final_account is true
and ah.account_type_id = 1
and ah.is_inactive is null
and ah.main_account_id = 5
AND (ah.global_id NOT IN (17, 18) OR ah.global_id IS NULL);
;
`;
let params2 = [req.session.company_id]


let query3 = `
select 
	ah.id,
	ah.account_name,
	ah.account_no,
	ah.is_inactive,
	ah.item_unite,
	ah.item_revenue_account,
	ah.item_expense_account,
	ah.item_sales_price,
	ah.item_purshas_price
from
	accounts_header ah
where 
	ah.id = $1
	and ah.company_id = $2
	and ah.is_final_account is true
	and ah.account_type_id = 8
	and ah.is_inactive is null
  ;
`
let params3 = [posted_elements.x, req.session.company_id]




await db.tx(async (tx) => {

  const revenueAccountsArray = await tx.any(query1, params1);
  const expensesAccountsArray = await tx.any(query2, params2);
  const serviceDataArray = await tx.oneOrNone(query3, params3);


  const postedData = { revenueAccountsArray, expensesAccountsArray, serviceDataArray};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});

app.post("/services_add", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "services_permission", "add");
      if (!permissions) {
        return;
      }  

    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.employee_start_date_value, posted_elements.employee_leave_date_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.account_name ||
        !posted_elements.unite_name ||
        !posted_elements.revenueAccount ||
        isNaN(+posted_elements.revenueAccount) ||
        !posted_elements.expenseAccount ||
        isNaN(+posted_elements.expenseAccount) ||
        (posted_elements.sales_price && isNaN(+posted_elements.sales_price)) ||   
        (posted_elements.purshase_price && isNaN(+posted_elements.purshase_price))   
      ){
          return res.json({
        success: false,
        message_ar:
          'âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }          
    
    //* Start--------------------------------------------------------------


    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2) as count_account_name,
               (select count(id) FROM accounts_header WHERE id = $3 AND company_id = $1 AND is_final_account = true  AND account_type_id = 1 AND main_account_id = 4 AND is_inactive IS NULL) as count_revenue_account,
               (select count(id) FROM accounts_header WHERE id = $4 AND company_id = $1 AND is_final_account = true  AND account_type_id = 1 AND main_account_id = 5 AND is_inactive IS NULL) as count_expenses_account
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.account_name.trim(),
      posted_elements.revenueAccount,
      posted_elements.expenseAccount
    ]);

  
    if (result.count_account_name > 0){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø§Ø³Ù… Ø§Ù„Ø®Ø¯Ù…Ù‡ Ù…ÙˆØ¬ÙˆØ¯ Ù…Ù† Ù‚Ø¨Ù„',
      });
    }


    if (+result.count_revenue_account === 0 || +result.count_expenses_account === 0){
      await block_user(req,'Ssadd1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    
    
    let active_value;
    if(posted_elements.inactive_select_value == 0){
      active_value = null
    }else if (posted_elements.inactive_select_value == 1) {
      active_value = true
    }


    let query1 = `
  INSERT INTO accounts_header (account_name, account_no, item_unite, item_revenue_account, item_expense_account, item_sales_price, item_purshas_price, is_inactive, is_final_account, finance_statement, company_id, account_type_id)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) RETURNING id
`;

  let params1 =[
    posted_elements.account_name,
    posted_elements.accountNo,
    posted_elements.unite_name,
    posted_elements.revenueAccount,
    posted_elements.expenseAccount,
    posted_elements.sales_price,
    posted_elements.purshase_price,
    active_value,
    true,
    1,
    req.session.company_id,
    8
  ]

  await db.tx(async (tx) => {
    const insert =  await tx.one(query1, params1);
    const id = insert.id
    // await tx.none(query2, params2);
    await history(27, 1, id, 0, req, tx)

  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ ØµÙ†Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error services_add:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/services_update", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "services_permission", "update");
      if (!permissions) {
        return;
      }  

    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.employee_start_date_value, posted_elements.employee_leave_date_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.account_name ||
        !posted_elements.unite_name ||
        !posted_elements.revenueAccount ||
        isNaN(+posted_elements.revenueAccount) ||
        !posted_elements.expenseAccount ||
        isNaN(+posted_elements.expenseAccount) ||
        (posted_elements.sales_price && isNaN(+posted_elements.sales_price)) ||   
        (posted_elements.purshase_price && isNaN(+posted_elements.purshase_price))   
      ){
          return res.json({
        success: false,
        message_ar:
          'âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }          
    
    //* Start--------------------------------------------------------------


    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE id = $5 AND company_id = $1 AND account_type_id = 8 AND is_final_account = true AND is_inactive is null) as count_exist_account_name,
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2 AND id != $5) as count_account_name,
               (select count(id) FROM accounts_header WHERE id = $3 AND company_id = $1 AND is_final_account = true  AND account_type_id = 1 AND main_account_id = 4 AND is_inactive IS NULL) as count_revenue_account,
               (select count(id) FROM accounts_header WHERE id = $4 AND company_id = $1 AND is_final_account = true  AND account_type_id = 1 AND main_account_id = 5 AND is_inactive IS NULL) as count_expenses_account
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.account_name.trim(),
      posted_elements.revenueAccount,
      posted_elements.expenseAccount,
      posted_elements.x

    ]);

  
    if (result.count_account_name > 0){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø§Ø³Ù… Ø§Ù„Ø®Ø¯Ù…Ù‡ Ù…ÙˆØ¬ÙˆØ¯ Ù…Ù† Ù‚Ø¨Ù„',
      });
    }


    if (+result.count_exist_account_name ===0 || +result.count_revenue_account === 0 || +result.count_expenses_account === 0){
      await block_user(req,'Ssadd1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


    //3: insert data into db
    
    
    let active_value;
    if(posted_elements.inactive_select_value == 0){
      active_value = null
    }else if (posted_elements.inactive_select_value == 1) {
      active_value = true
    }



    let query1 = `
  update accounts_header set
     account_name = $1,
     account_no = $2,
     item_unite = $3,
     item_revenue_account = $4,
     item_expense_account = $5,
     item_sales_price = $6,
     item_purshas_price = $7,
     is_inactive = $8
    where
    id = $9 
    and company_id = $10 
    and account_type_id = 8
    and is_inactive is NULL
  ;  
`;

  let params1 =[
    posted_elements.account_name,
    posted_elements.accountNo,
    posted_elements.unite_name,
    posted_elements.revenueAccount,
    posted_elements.expenseAccount,
    posted_elements.sales_price,
    posted_elements.purshase_price,
    active_value,
    posted_elements.x,
    req.session.company_id
  ]



  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    // await tx.none(query2, params2);
    await history(27, 2, posted_elements.x, 0, req, tx)

  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ ØµÙ†Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error services_update:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/services_delete", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "services_permission", "delete");
      if (!permissions) {
        return;
      }  

    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.employee_start_date_value, posted_elements.employee_leave_date_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);
         
    
    //* Start--------------------------------------------------------------


    let query0 = `SELECT
               (select count(tb.id) from transaction_body tb left join transaction_header th on th.id = tb.transaction_header_id where th.company_id = $1 and tb.item_id = $2 and th.is_deleted is null and th.is_including_items is true) as_count_transactions,
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $2 AND account_type_id = 8 AND is_final_account = true AND is_inactive is null) as count_exist_account_name
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.x

    ]);

  

    if (+result.count_exist_account_name === 0){
      await block_user(req,'Ssadd1')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


    if(+result.as_count_transactions > 0){
      return res.json({
        success: false,
        message_ar: 'âŒ ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„ØµÙ†Ù Ø§Ù„Ø®Ø¯Ù…Ù‰ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°ÙÙ‡',
      });
    }

    let query1 = `
    delete from accounts_header where id = $1 and company_id = $2 and account_type_id = 8
  ;  
`;

  let params1 =[
    posted_elements.x,
    req.session.company_id
  ]
          


  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    // await tx.none(query2, params2);
    await history(27, 3, posted_elements.x, 0, req, tx)

  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù ØµÙ†Ù Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error services_delete:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion services

//#region sales_returns
app.post("/get_sales_returns_Data_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "sales_returns_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
select 
    th.id,
    th.reference,
        CONCAT(
        tt1.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    th.total_value,
    COALESCE(th.general_note, '') as general_note, 
    th.datex,
    th.account_id as customer_id,
    ah1.account_name as customer_name,
    th.salesman_id as salesman_id,
    ah2.account_name as salesman_name,
    '' AS is_invoiced,
    th.due_date,
    th.is_column1 as is_row_dicount_show,
    th.is_column2 as is_row_note_show,
    th.is_column3 as is_row_tax_show,
     th.invoice_id,
    CONCAT(
        tt2.doc_prefix, '-',
        SUBSTRING(th_invoice.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th_invoice.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS invoice_reference
from
    transaction_header th
left join accounts_header ah1 on ah1.id = th.account_id
left join accounts_header ah2 on ah2.id = th.salesman_id
left join transaction_header th_invoice on th_invoice.invoice_id = th.id 
LEFT JOIN transaction_type tt1 ON tt1.id = th.transaction_type
LEFT JOIN transaction_type tt2 ON tt2.id = th_invoice.transaction_type
where
    th.company_id = $1
    AND th.transaction_type = 4
    AND (th.datex BETWEEN $2 AND $3) -- Ø§Ù„ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù‚ÙŠÙ… Ø¨ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù†ØµÙŠØ© ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    AND th.is_deleted IS NULL
ORDER BY
    th.datex DESC,
    th.reference DESC
    ;
`;

    let data = await db.any(query1, [req.session.company_id,posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_sales_returns_Data_view:", error);
    res.status(500).send("Error:");
  }
});

  app.post("/get_data_for_sales_returns_add", async (req, res) => {
    try {
      // //! Permission
      await permissions(req, "sales_returns_add", "add");
      if (!permissions) {
        return;
      }
  
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  

   let query8 = `
   select 
     th.id,
         CONCAT(
          tt.doc_prefix, '-',
           SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
           LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
       ) AS account_name
   from
     transaction_header th
    LEFT JOIN transaction_type tt ON tt.id = th.transaction_type 
   where
     th.transaction_type = 3
     and th.company_id = $1
     and th.is_deleted is NULL;
      ` 
      let params8 = [req.session.company_id]

  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const salesInvoiceReferencesArray = await tx.any(query8, params8);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, salesInvoiceReferencesArray };
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get Employees Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false,message_ar: error.message || deafultErrorMessage,});
    }
  });

  app.post("/api/sales_returns_add", async (req, res) => {
    try {
  
      
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_returns_permission", "add");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }



  
      const posted_elements = req.body;
      const transaction_type = 4 // sales_returns
      let items_array = []
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.customerId,
        posted_elements.total,
        posted_elements.datex,
        posted_elements.invoiceReferenceId,
        posted_elements.itemLocationId,
        posted_elements.salesmanId,
        posted_elements.is_RowNote,
        posted_elements.is_RowDiscount,
        posted_elements.general_note,
        posted_elements.location_name,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'add',
        tableName: false, // if type = 'update' or 'delete' only
        transaction_id: false, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      

      //* Start Transaction --------------------------------------------------
  
     const total = +posted_elements.total

     if (!total || isNaN(total)){
      await block_user(req,'Ssra001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
     }


  // //! Security hacking  accounts id
 
     // check qutationReferenceId

      let query05;
      let rows05;
      if (posted_elements.invoiceReferenceId){
        query05 = `select count(id) as salesreturnsReferenceCount from transaction_header where id = $1 and company_id = $2 and transaction_type = 3 and is_deleted IS NULL`
        rows05 = await db.oneOrNone(query05, [posted_elements.invoiceReferenceId, req.session.company_id])
       if (rows05.salesreturnsReferenceCount === 0){
         await block_user(req,'Ssra02')
         return res.json({
           success: false,
           xx: true,
           message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
         });
       }
       }

  // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
  let rows02 = await db.any(query02, [req.session.company_id]);
  
  // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
  const dbAccounts = rows02.map(row => ({
    id: parseInt(row.id),
    account_type_id: row.account_type_id,
    is_salesman: row.is_salesman
  }));

  //check salesman

  const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
  const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_salesman) {
      await block_user(req,'Ssra03')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_itemLocation) {
      await block_user(req,'Ssra04')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


  // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
  for (const rowData of posted_elements.posted_array) {
    const item_typeId = rowData.item_typeId;
    const item_id = rowData.item_id;

  
    //! make sure from every account_id
    const accountExists = dbAccounts.some(item => 
      +item.id === +item_id && +item.account_type_id === +item_typeId
    );
  
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!accountExists) {
      await block_user(req,'Ssra05')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    items_array.push(+rowData.item_id)
  }
  
  
      // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
      let rows03 = await db.any(query03, [req.session.company_id]);
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
      const dbTaxesHeaderArray = rows03.map(row => ({
        id: parseInt(row.id)
      }));
      

      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
      for (const rowData of posted_elements.posted_array) {
        const row_taxHeaderId = rowData.row_taxHeaderId;
        
        if (row_taxHeaderId){
        //! make sure from every account_id
        const taxExists = dbTaxesHeaderArray.some(item =>
          +item.id === +row_taxHeaderId
        );
        

      
        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
        if (!taxExists) {
          await block_user(req,'Ssra6')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
      }
      }
  

   
      
      const year = getYear(posted_elements.datex)
      const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header',4, year, req);
      const newId_general_reference = await newId_fn("transaction_header", 'general_reference');

      
      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {

     

        let query1 = `INSERT INTO transaction_header
                      (reference, company_id, transaction_type, total_value, general_note, datex, account_id, salesman_id, is_column1, is_column2, is_column3, items_location_id, invoice_id, general_reference, is_including_items)
                      VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12, $13, $14, $15) RETURNING id;`;
  
        const insert =await tx.one(query1, [
          newReference_transaction_header,
          req.session.company_id,
          transaction_type,
          total.toFixed(2),
          posted_elements.general_note,
          posted_elements.datex,
          posted_elements.customerId,
          posted_elements.salesmanId,
          posted_elements.is_RowDiscount ? true : null,
          posted_elements.is_RowNote ? true : null,
          posted_elements.is_RowTax ? true : null,
          posted_elements.itemLocationId,
          posted_elements.invoiceReferenceId,
          newId_general_reference,
          true
        ]);
        const newId_transaction_header = insert.id;

        let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
        let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')

        let other_posted_array = []
        let Val_beforTax = 0
        let taxValue = 0
        let TotalValue = 0
        let insert_array2 = []
        for (const element of posted_elements.posted_array) {
  
          //! make sure if account id != item  then location and amount = null

          if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
            await block_user(req,'Ssra7')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }

         /* 
          //! check amount
          const current_location_amount_data = items_amount_location.find(item => +item.item_id === +element.item_id);
          const db_amount = +(current_location_amount_data?.current_location_amount || 0);
          const result_amount = db_amount - +element.row_amount;
            
          if (isNaN(result_amount) || result_amount <= 0) {       
            throw new Error(
              `Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙ‰ ÙÙ‰ Ù…ÙˆÙ‚Ø¹ ${posted_elements.location_name} Ù„Ù„ØµÙ†Ù ${element.item_name}`
            );
          }
         */ 
          
         const rowDiscountType = +element.row_discountTypeId || 0
         const rowDiscountValue= +element.row_discountValue || 0
         const rowAmount = +element.row_amount || 0
         const rowUnitePrice = +element.row_unitPrice || 0

          const Xrow_discount_value =
          rowDiscountType === 1
              ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
              : +rowDiscountValue;
              Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
              TotalValue += Val_beforTax
              
            //  let cogs = null 
            // if (+element.item_typeId === 5){
            //   x = items_avg.find(item => +item.item_id === element.item_id)
            //   if (x){
            //     cogs = (+element.row_amount * +x.avg)*-1
            //   }
            // }

            

          const account_row = DeafultAccounts.find(item => +item.id === element.item_id);
          
          if (!account_row){
            await block_user(req,'Ssra8')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }
          const account_id = +account_row.item_revenue_account
          
          insert_array2.push([
            newId_transaction_header,
            +Val_beforTax,
            null,
            element.row_note,
            +element.row_amount,
            +element.row_unitPrice,
            +account_id,
            +element.row_discountTypeId === 1 ? true : null,
            element.row_discountValue || null,
            element.row_taxHeaderId || null,
            null,
            null,
            +element.item_typeId === 5? element.item_id : null,
            +element.item_typeId === 5? posted_elements.itemLocationId : null
          ]);

          //! check if has taxHeader
          if (element.row_taxHeaderId){
            const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
            if (taxesbodyArray){
              for (const row of taxesbodyArray){
                const taxRate = +row.tax_rate /100
                const taxMultiplier = row.is_tax_reverse ? -1 : 1;
                taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
                TotalValue += taxValue

                const newObject = {
                  taxBodyId: row.id,
                  taxHeaderId: row.settings_tax_header_id,
                  debit: taxValue > 0 ? taxValue : null,
                  credit: taxValue < 0 ? taxValue*-1 : null,
                  account_id: row.tax_account_id,
                  is_tax: true
                }
                other_posted_array.push(newObject)
              }
            }
          }

        }

          

        //! add customer row to transaction
        const newObject = {
          taxBodyId: null,
          taxHeaderId: null,
          debit: TotalValue < 0 ? TotalValue*-1 : null,
          credit: TotalValue > 0 ? TotalValue : null,
          account_id: posted_elements.customerId,
          is_tax: null
        }
        other_posted_array.push(newObject)

        //! insert the other part to transaction
        for (const object of other_posted_array){

          insert_array2.push([
          newId_transaction_header,
          +object.debit || null,
          +object.credit || null,
          null,
          null,
          null,
          +object.account_id,
          null,
          null,
          +object.taxHeaderId || null,
          +object.taxBodyId || null,
          object.is_tax,
          null,
          null
          ]);

        }

        if (insert_array2.length > 0){
          let columnsCount = insert_array2[0].length;
        let query2 = `INSERT INTO transaction_body
        (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id, is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
        VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;

await tx.none(query2, insert_array2.flat());
}

        //! history
        await update_items_cogs(items_array,posted_elements.datex, req, tx)
        await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
      });
  
      // await update_items_cogs(req,items_array,posted_elements.datex)
      const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error adding sales returns:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });

  app.post("/api/sales_returns_update", async (req, res) => {
    try {
  
      // //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_returns_permission", "update");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }



  
      const posted_elements = req.body;
      const transaction_type = 4 // Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª 4
      let items_array = []
    
  
      //! sql injection check
      let hasBadSymbols = sql_anti_injection([
        ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
        posted_elements.x,
        posted_elements.customerId,
        posted_elements.total,
        posted_elements.datex,
        posted_elements.invoiceReferenceId,
        posted_elements.itemLocationId,
        posted_elements.salesmanId,
        posted_elements.is_RowNote,
        posted_elements.is_RowDiscount,
        posted_elements.general_note,
        posted_elements.location_name,
        // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      ]);
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar: sql_injection_message_ar,
          message_en: sql_injection_message_en,
        });
      }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'update',
        tableName: 'transaction_header', // if type = 'update' or 'delete' only
        transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      

      //* Start Transaction --------------------------------------------------
  
     const total = +posted_elements.total

     if (!total || isNaN(total)){
      await block_user(req,'Ssru001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
     }

  
  // //! Security hacking  accounts id
 
     // check qutationReferenceId

     let query_1 = `select reference from transaction_header where id = $1 AND company_id = $2 AND transaction_type = 4 AND is_deleted IS NULL`
     const result_1 = await db.oneOrNone(query_1,[posted_elements.x, req.session.company_id])
     if (!result_1){
      await block_user(req,'Ssqu02')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
     }


     //! check sales invoice reference if exist
      let query05;
      let rows05;
      if (posted_elements.orderReferenceId){
        query05 = `select count(id) as salesReturnsReferenceCount from transaction_header where id = $1 and company_id = $2 and transaction_type = 3 and is_deleted IS NULL`
        rows05 = await db.oneOrNone(query05, [posted_elements.invoiceReferenceId, req.session.company_id])
       if (rows05.salesReturnsReferenceCount === 0){
         await block_user(req,'Ssrau04')
         return res.json({
           success: false,
           xx: true,
           message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
         });
       }
       }

  // Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
  let rows02 = await db.any(query02, [req.session.company_id]);
  
  // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
  const dbAccounts = rows02.map(row => ({
    id: parseInt(row.id),
    account_type_id: row.account_type_id,
    is_salesman: row.is_salesman
  }));

  //check salesman

  const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
  const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_salesman) {
      await block_user(req,'Ssru05')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!count_itemLocation) {
      await block_user(req,'Ssru06')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


  // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
  for (const rowData of posted_elements.posted_array) {
    const item_typeId = rowData.item_typeId;
    const item_id = rowData.item_id;

  
    //! make sure from every account_id
    const accountExists = dbAccounts.some(item => 
      +item.id === +item_id && +item.account_type_id === +item_typeId
    );
  
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
    if (!accountExists) {
      await block_user(req,'Ssru07')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    items_array.push(+rowData.item_id)
  }
  
  
      // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
      let rows03 = await db.any(query03, [req.session.company_id]);
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
      const dbTaxesHeaderArray = rows03.map(row => ({
        id: parseInt(row.id)
      }));
      

      // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
      for (const rowData of posted_elements.posted_array) {
        const row_taxHeaderId = rowData.row_taxHeaderId;
        
        if (row_taxHeaderId){
        //! make sure from every account_id
        const taxExists = dbTaxesHeaderArray.some(item =>
          +item.id === +row_taxHeaderId
        );
        

      
        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
        if (!taxExists) {
          await block_user(req,'Ssqr08')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }
      }
      }
  

      const year = getYear(posted_elements.datex)

      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {

        let query1 = `update transaction_header
                      set total_value = $1,
                        general_note = $2,
                        datex = $3,
                        account_id = $4,
                        salesman_id = $5,
                        is_column1 = $6,
                        is_column2 = $7,
                        is_column3 = $8,
                        items_location_id = $9,
                        invoice_id = $10
                      Where
                        id = $11
                        AND company_id = $12
                      ;`;
  
        await tx.none(query1, [
          total.toFixed(2),
          posted_elements.general_note,
          posted_elements.datex,
          posted_elements.customerId,
          posted_elements.salesmanId,
          posted_elements.is_RowDiscount ? true : null,
          posted_elements.is_RowNote ? true : null,
          posted_elements.is_RowTax ? true : null,
          posted_elements.itemLocationId,
          posted_elements.invoiceReferenceId,
          posted_elements.x,
          req.session.company_id
        ]);
  
        const query_delete = `delete from transaction_body where transaction_header_id = $1`
        await tx.none(query_delete,[posted_elements.x])

        let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
        let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')

        let other_posted_array = []
        let Val_beforTax = 0
        let taxValue = 0
        let TotalValue = 0
        let insert_array2 = []
        for (const element of posted_elements.posted_array) {
  
          //! make sure if account id != item  then location and amount = null

          if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
            await block_user(req,'Ssra3')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }

          /*
          //! check amount
          const current_location_amount_data = items_amount_location.find(item => +item.item_id === +element.item_id);
          const db_amount = +(current_location_amount_data?.current_location_amount || 0);
          const result_amount = db_amount - +element.row_amount;
            
          if (isNaN(result_amount) || result_amount <= 0) {       
            throw new Error(
              `Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙ‰ ÙÙ‰ Ù…ÙˆÙ‚Ø¹ ${posted_elements.location_name} Ù„Ù„ØµÙ†Ù ${element.item_name}`
            );
          }
          */
          
         const rowDiscountType = +element.row_discountTypeId || 0
         const rowDiscountValue= +element.row_discountValue || 0
         const rowAmount = +element.row_amount || 0
         const rowUnitePrice = +element.row_unitPrice || 0

          const Xrow_discount_value =
          rowDiscountType === 1
              ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
              : +rowDiscountValue;
              Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
              TotalValue += Val_beforTax
              
              // let cogs = null 
              // if (+element.item_typeId === 5){
              //   x = items_avg.find(item => +item.item_id === element.item_id)
              //   if (x){
              //     cogs = (+element.row_amount * +x.avg)*-1
              //   }
              // }


          const account_row = DeafultAccounts.filter(item => +item.id === element.item_id);
          
          if (!account_row){
            await block_user(req,'Ssia4')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }
          const account_id = +account_row[0].item_revenue_account
          
          
  
          insert_array2.push([
            posted_elements.x,
            +Val_beforTax,
            null,
            element.row_note,
            +element.row_amount,
            +element.row_unitPrice,
            +account_id,
            +element.row_discountTypeId === 1 ? true : null,
            element.row_discountValue || null,
            element.row_taxHeaderId || null,
            null,
            null,
            +element.item_typeId === 5? element.item_id : null,
            +element.item_typeId === 5? posted_elements.itemLocationId : null
          ]);

          //! check if has taxHeader
          if (element.row_taxHeaderId){
            const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
            if (taxesbodyArray){
              for (const row of taxesbodyArray){
                const taxRate = +row.tax_rate /100
                const taxMultiplier = row.is_tax_reverse ? -1 : 1;
                taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
                TotalValue += taxValue

                const newObject = {
                  taxBodyId: row.id,
                  taxHeaderId: row.settings_tax_header_id,
                  debit: taxValue < 0 ? taxValue*-1 : null,
                  credit: taxValue > 0 ? taxValue : null,
                  account_id: row.tax_account_id,
                  is_tax: true
                }
                other_posted_array.push(newObject)
              }
            }
          }

        }

          

        //! add customer row to transaction
        const newObject = {
          taxBodyId: null,
          taxHeaderId: null,
          debit: TotalValue < 0 ? TotalValue*-1 : null,
          credit: TotalValue > 0 ? TotalValue : null,
          account_id: posted_elements.customerId,
          is_tax: null
        }
        other_posted_array.push(newObject)

        //! insert the other part to transaction
        for (const object of other_posted_array){

          insert_array2.push([
          posted_elements.x,
          +object.debit || null,
          +object.credit || null,
          null,
          null,
          null,
          +object.account_id,
          null,
          null,
          +object.taxHeaderId || null,
          +object.taxBodyId || null,
          object.is_tax,
          null,
          null
          ]);

        }
        if (insert_array2.length > 0){
          let columnsCount = insert_array2[0].length;
        let query2 = `INSERT INTO transaction_body
        (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id,  is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
        VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;

await tx.none(query2, insert_array2.flat());
}

        //! history
        await update_items_cogs(items_array,posted_elements.datex, req, tx)
        await history(transaction_type,2,posted_elements.x,result_1.reference,req,tx);
      });
  
      // await update_items_cogs(req,items_array,posted_elements.datex)
      const new_referenceFormatting = formatFromFiveDigits(result_1.reference);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„  Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error sales_returns_update:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });

  app.post("/api/sales_returns_delete", async (req, res) => {
    try {
  
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_returns_permission", "delete");
      if (!permissions) {
        return res.status(403).json({
          success: false,
          message_ar: "âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
        });
      }



  
      const posted_elements = req.body;
      const transaction_type = 4
    
  
        //! sql injection check
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
  
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
      if (InValidDateFormat) {
        return res.status(400).json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
  
      //! settings
      const settings = await check_settings_validation({
        check_futureDate: true,
        check_closingDate: true,
        datex: posted_elements.datex,
        type: 'delete',
        tableName: 'transaction_header', // if type = 'update' or 'delete' only
        transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
      }, req);
  
      
      if (!settings.valid) {
        return res.json({
          success: false,
          message_ar: settings.message_ar,
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
  
      

      //* Start Transaction --------------------------------------------------
  

  
  // //! Security hacking  accounts id
 
 
      let query1 = `select reference, datex from transaction_header where id = $1 and company_id = $2 AND transaction_type = $3 AND is_deleted IS NULL`
      let result1 = await db.oneOrNone(query1,[posted_elements.x, req.session.company_id, transaction_type])

      if (!result1){
        await block_user(req,'Ssrd001')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
      
      const year = getYear(result1.datex)


      let query2 = `select item_id from transaction_body where transaction_header_id = $1 AND item_id IS NOT NULL`;
      let result2 = await db.any(query2, [posted_elements.x]);
      
      if (!result2 || result2.length === 0) {
        await block_user(req, 'Ssrd001');
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ø£Ø±Ù‚Ø§Ù…
      const items_array = result2.map(row => row.item_id);
      
    
      // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await db.tx(async (tx) => {

        let query1 = `update transaction_header
                      set is_deleted = true
                      Where
                        id = $1
                        AND company_id = $2
                        AND transaction_type = $3
                      ;`;
  
                    
            
            

        const resultQ1 = await tx.result(query1, [
          posted_elements.x,
          req.session.company_id,
          transaction_type
        ]);

        if (resultQ1.rowCount === 0) {
          await block_user(req,'Ssrd1')
          throw new Error(
            'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
          );
        }
  
        const query_delete = `delete from transaction_body where transaction_header_id = $1`
        await tx.none(query_delete,[posted_elements.x])


        //! history
        await update_items_cogs(items_array,result1.datex, req, tx)
        await history(transaction_type,3,posted_elements.x,result1.reference,req,tx);
      });

      // await update_items_cogs(req,items_array,result1.datex)
      const new_referenceFormatting = formatFromFiveDigits(result1.reference);
      await last_activity(req);
      // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
      return res.json({
        success: true,
        message_ar: `âœ… ØªÙ… Ø­Ø°Ù  Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
      });
    } catch (error) {
      await last_activity(req);
      console.error("Error sales_returns_delete:", error);
  
      // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
      return res.json({
        success: false,
        message_ar: error.message || deafultErrorMessage,
      });
    }
  });

  app.post("/get_data_for_sales_returns_update", async (req, res) => {
    try {
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_returns_permission", "update");
      if (!permissions) {
        return;
      }
  
      
      const posted_elements = req.body;
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      const transaction_type = 4 // Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª

      
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    AND is_inactive IS NULL
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
      AND ah.is_inactive IS NULL
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  
  
  let query7 = `
  select 
    th.id,
    th.reference,
    COALESCE(th.general_note, '') as general_note,
    th.datex,
    th.due_date,
    th.account_id,
    th.salesman_id,
    th.invoice_id,
    th.is_delivered,
    th.items_location_id,
    th.is_column1 as is_row_dicount_show,
    th.is_column2 as is_row_note_show,
    th.is_column3 as is_row_tax_show,
    CONCAT(
      tt1.doc_prefix, '-',
      SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    CONCAT(
      tt2.doc_prefix, '-',
      SUBSTRING(th_invoice.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(th_invoice.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat_invoice
  from
    transaction_header th
	left join transaction_header th_invoice on th_invoice.id = th.invoice_id
  LEFT JOIN transaction_type tt1 ON tt1.id = th.transaction_type
  LEFT JOIN transaction_type tt2 ON tt2.id = th_invoice.transaction_type
  where 
  th.id = $1
  and th.company_id = $2
  and th.transaction_type = $3
  AND th.is_deleted IS NULL
  `
  let params7 = [posted_elements.x, req.session.company_id, transaction_type];
  
  let query8 = `
  select
    tb.id,
    tb.item_id,
      ah.account_name,
      ah.item_unite,
      ah.account_type_id as item_type_id,
    ABS(tb.item_amount) as amount,
    tb.item_price as unite_price,
    COALESCE(tb.row_note, '') as row_note,
    tb.is_discount_percentage,
    tb.dicount_value,
    tb.settings_tax_header_id as tax_header_id,
      sth.taxe_package_name
  from
    transaction_body tb
  LEFT JOIN accounts_header ah on ah.id = tb.item_id
  LEFT JOIN settings_tax_header sth on sth.id = tb.settings_tax_header_id
  left join account_type at on at.id = ah.account_type_id
  where 
    tb.transaction_header_id = $1
    AND tb.item_id is NOT NULL
    ;
  `
  let params8 = [posted_elements.x]
  
  
  let query9 = `
  select 
    th.id,
        CONCAT(
          tt.doc_prefix, '-',
          SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
          LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS account_name
  from
    transaction_header th
  LEFT JOIN transaction_type tt ON tt.id = th.transaction_type  
  where
    th.transaction_type = 3
    and th.company_id = $1
    and th.account_id = $2
    and th.is_deleted is NULL
     ` 

     let params9 = [req.session.company_id, posted_elements.customer_id]
  
  
  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const headerData = await tx.oneOrNone(query7, params7);
    const bodyData = await tx.any(query8, params8);
    const salesInvoiceReferencesArray = await tx.any(query9, params9);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, headerData, bodyData, salesInvoiceReferencesArray};
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get_data_for_sales_returns_update  Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false,message_ar: error.message || deafultErrorMessage, });
    }
  });

  app.post("/get_data_for_invoiceToreturns", async (req, res) => {
    try {
      //! Permission Ù…Ø¹Ù„Ù‚
      await permissions(req, "sales_returns_permission", "add");
      if (!permissions) {
        return;
      }
  
      
      const posted_elements = req.body;
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
  
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }
  
      turn_EmptyValues_TO_null(posted_elements);
      //* Start--------------------------------------------------------------
      // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
  
      const transaction_type = 4

  
  
      let query1 = `
       -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
  select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 7
    AND is_inactive IS NULL
    ;
  `;
  let params1 = [req.session.company_id]
  
  let query2 = `
    select
    id as id,
    account_name as account_name
  from
    accounts_header 
  WHERE company_id = $1 
    AND account_type_id = 4
    AND is_final_account IS true
    and is_salesman IS true
    AND is_inactive IS null
    ;
  `
  let params2 = [req.session.company_id]
  
  let query3 = `
      select 
    th.id,
    th.taxe_package_name as account_name
  from
     settings_tax_header th
  where
    th.company_id = $1
    and th.is_inactive is null
  order by
    th.taxe_package_name asc 
   
  `
  let params3 = [req.session.company_id]
  
  let query4 = `
  select
      tb.id,
      tb.tax_name,
      tb.tax_rate,
      tb.is_tax_reverse,
      tb.tax_account_id,
      ah.account_name,
      tb.settings_tax_header_id
  from
      settings_tax_body tb
  left join accounts_header ah on ah.id = tb.tax_account_id    
  where
      tb.settings_tax_header_id = ANY($1::int[])
      AND ah.is_inactive IS NULL
  `;
  
  
  let query5 = `
SELECT
  ah.id,
  ah.account_name,
  ah.account_type_id,
  COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
  ah.item_revenue_account,
  ah_revenue.account_name as revenue_account_name,
  ah.item_expense_account,
  ah_expense.account_name as expense_account_name,
  ah.item_sales_price,
  ah.item_purshas_price
FROM
  accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
  ah.company_id = $1
  AND ah.is_final_account = true
  AND ah.account_type_id IN (5, 8)
  AND ah.is_inactive IS NULL
  `;
  
  let params5 = [req.session.company_id];
  
  
  let query6 = `
  select
    ah.id,
    ah.account_name
  from
    accounts_header ah
  where
    ah.company_id = $1
    AND ah.is_final_account is true
    AND is_inactive is null
    AND (ah.account_type_id = 2 or ah.is_allow_to_buy_and_sell is true);`
  
    let params6 = [req.session.company_id];
  
  
  let query7 = `
  select 
    th.id,
    th.reference,
    COALESCE(th.general_note, '') as general_note,
    th.datex,
    th.account_id,
    th.salesman_id,
    th.items_location_id,
    th.is_column1 as is_row_dicount_show,
    th.is_column2 as is_row_note_show,
    th.is_column3 as is_row_tax_show,
    CONCAT(
      tt.doc_prefix, '-',
      SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat
  from
    transaction_header th
  LEFT JOIN transaction_type tt ON tt.id = th.transaction_type  
  where 
  th.id = $1
  and th.company_id = $2
  and th.transaction_type = 3 -- ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
  AND th.is_deleted IS NULL
  `
  let params7 = [posted_elements.x, req.session.company_id];
  
  let query8 = `
  select
    tb.id,
    tb.item_id,
      ah.account_name,
      ah.item_unite,
      ah.account_type_id as item_type_id,
    ABS(tb.item_amount) as amount,
    tb.item_price as unite_price,
    COALESCE(tb.row_note, '') as row_note,
    tb.is_discount_percentage,
    tb.dicount_value,
    tb.settings_tax_header_id as tax_header_id,
      sth.taxe_package_name
  from
    transaction_body tb
  LEFT JOIN accounts_header ah on ah.id = tb.item_id
  LEFT JOIN settings_tax_header sth on sth.id = tb.settings_tax_header_id
  left join account_type at on at.id = ah.account_type_id
  where 
    tb.transaction_header_id = $1
    and tb.item_id is not NULL
    ;
  `
  let params8 = [posted_elements.x]
  
  
  let query9 = `
  select 
    th.id,
        CONCAT(
          tt.doc_prefix, '-',
          SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
          LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS account_name
  from
    transaction_header th
  LEFT JOIN transaction_type tt ON tt.id = th.transaction_type  
  where
    th.transaction_type = 3
    and th.company_id = $1
    and th.account_id = $2
    and th.is_deleted is NULL
     ` 

     let params9 = [req.session.company_id, posted_elements.customer_id]
    
  
  await db.tx(async (tx) => {
  
    const itemslocationsArray = await tx.any(query1, params1);
    const salesmanArray = await tx.any(query2, params2);
    const taxHeaderArray = await tx.any(query3, params3);
    const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
    const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
    const itemsDataArray = await tx.any(query5, params5);
    const customersDataArray = await tx.any(query6, params6);
    const headerData = await tx.oneOrNone(query7, params7);
    const bodyData = await tx.any(query8, params8);
    const salesInvoiceReferencesArray = await tx.any(query9, params9);
  
    const postedData = { itemslocationsArray, salesmanArray, taxHeaderArray, taxBodyArray, itemsDataArray, customersDataArray, headerData, bodyData, salesInvoiceReferencesArray};
    res.json(postedData);
  })
  
  
      await last_activity(req)
    } catch (error) {
      await last_activity(req)
      console.error("Error while get_data_for_sales_invoice_update  Data", error);
      res.join;
      res
        .status(500)
        .json({ success: false,message_ar: error.message || deafultErrorMessage,});
    }
  });


//#endregion


//#region purshases_returns
app.post("/get_purshases_returns_Data_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "purshases_returns_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
select 
    th.id,
    th.reference,
    CONCAT(
        tt1.doc_prefix, '-',  
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    th.total_value,
    COALESCE(th.general_note, '') as general_note, 
    th.datex,
    th.account_id as vendor_id,
    ah1.account_name as vendor_name,
    '' AS is_invoiced,
    th.is_column1 as is_row_dicount_show,
    th.is_column2 as is_row_note_show,
    th.is_column3 as is_row_tax_show,
     th.invoice_id,
    CONCAT(
        tt2.doc_prefix, '-',
        SUBSTRING(th_invoice.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th_invoice.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS invoice_reference
from
    transaction_header th
left join accounts_header ah1 on ah1.id = th.account_id
left join accounts_header ah2 on ah2.id = th.salesman_id
left join transaction_header th_invoice on th_invoice.invoice_id = th.id
LEFT JOIN transaction_type tt1 ON tt1.id = th.transaction_type
LEFT JOIN transaction_type tt2 ON tt2.id = th_invoice.transaction_type
where
    th.company_id = $1
    AND th.transaction_type = 7
    AND (th.datex BETWEEN $2 AND $3) -- Ø§Ù„ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù‚ÙŠÙ… Ø¨ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù†ØµÙŠØ© ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    AND th.is_deleted IS NULL
ORDER BY
    th.datex DESC,
    th.reference DESC
    ;
`;

    let data = await db.any(query1, [req.session.company_id,posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_purshases_returns_Data_view:", error);
    res.status(500).send("Error:");
  }
});

app.post("/get_data_for_purshases_returns_add", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "purshases_returns_add", "add");
    if (!permissions) {
      return;
    }

    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
  id as id,
  account_name as account_name
from
  accounts_header 
WHERE company_id = $1 
  AND account_type_id = 7
  ;
`;
let params1 = [req.session.company_id]

/*
let query2 = `
  select
  id as id,
  account_name as account_name
from
  accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4
  AND is_final_account IS true
  and is_salesman IS true
  AND is_inactive IS null
  ;
`
let params2 = [req.session.company_id]
*/

let query3 = `
    select 
  th.id,
  th.taxe_package_name as account_name
from
   settings_tax_header th
where
  th.company_id = $1
  and th.is_inactive is null
order by
  th.taxe_package_name asc 
 
`
let params3 = [req.session.company_id]

let query4 = `
select
    tb.id,
    tb.tax_name,
    tb.tax_rate,
    tb.is_tax_reverse,
    tb.tax_account_id,
    ah.account_name,
    tb.settings_tax_header_id
from
    settings_tax_body tb
left join accounts_header ah on ah.id = tb.tax_account_id    
where
    tb.settings_tax_header_id = ANY($1::int[])
`;


let query5 = `
SELECT
ah.id,
ah.account_name,
ah.account_type_id,
COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
ah.item_revenue_account,
ah_revenue.account_name as revenue_account_name,
ah.item_expense_account,
ah_expense.account_name as expense_account_name,
ah.item_sales_price,
ah.item_purshas_price
FROM
accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
ah.company_id = $1
AND ah.is_final_account = true
AND ah.account_type_id IN (5, 8)
AND ah.is_inactive IS NULL
`;

let params5 = [req.session.company_id];


let query6 = `
select
  ah.id,
  ah.account_name
from
  accounts_header ah
where
  ah.company_id = $1
  AND ah.is_final_account is true
  AND is_inactive is null
  AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`

  let params6 = [req.session.company_id];


 let query8 = `
 select 
   th.id,
       CONCAT(
        tt.doc_prefix, '-',
         SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
         LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
     ) AS account_name
 from
   transaction_header th
  LEFT JOIN transaction_type tt ON tt.id = th.transaction_type 
 where
   th.transaction_type = 6 -- ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª
   and th.company_id = $1
   and th.is_deleted is NULL;
    ` 
    let params8 = [req.session.company_id]

await db.tx(async (tx) => {

  const itemslocationsArray = await tx.any(query1, params1);
  // const salesmanArray = await tx.any(query2, params2);
  const taxHeaderArray = await tx.any(query3, params3);
  const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
  const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
  const itemsDataArray = await tx.any(query5, params5);
  const vendorsDataArray = await tx.any(query6, params6);
  const purshasesInvoiceReferencesArray = await tx.any(query8, params8);

  const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, purshasesInvoiceReferencesArray };
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_data_for_purshases_returns_add", error);
    res.join;
    res
      .status(500)
      .json({ success: false,message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/api/purshases_returns_update", async (req, res) => {
  try {

    // //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "purshases_returns_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }




    const posted_elements = req.body;
    const transaction_type = 7 // Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª 4
    let items_array = []
    let locations_array = []
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.x,
      posted_elements.vendorId,
      posted_elements.total,
      posted_elements.datex,
      posted_elements.invoiceReferenceId,
      posted_elements.itemLocationId,
      posted_elements.is_RowNote,
      posted_elements.is_RowDiscount,
      posted_elements.general_note,
      posted_elements.location_name,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'update',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------

   const total = +posted_elements.total

   if (!total || isNaN(total)){
    await block_user(req,'Spru001')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
   }


// //! Security hacking  accounts id

   // check qutationReferenceId

   let query_1 = `select reference from transaction_header where id = $1 AND company_id = $2 AND transaction_type = 7 AND is_deleted IS NULL`
   const result_1 = await db.oneOrNone(query_1,[posted_elements.x, req.session.company_id])
   if (!result_1){
    await block_user(req,'Spqu02')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
   }


   //! check sales purshases reference if exist
    let query05;
    let rows05;
    if (posted_elements.orderReferenceId){
      query05 = `select count(id) as salesReturnsReferenceCount from transaction_header where id = $1 and company_id = $2 and transaction_type = 6 and is_deleted IS NULL`
      rows05 = await db.oneOrNone(query05, [posted_elements.invoiceReferenceId, req.session.company_id])
     if (rows05.salesReturnsReferenceCount === 0){
       await block_user(req,'Sprau04')
       return res.json({
         success: false,
         xx: true,
         message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
       });
     }
     }

// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
let rows02 = await db.any(query02, [req.session.company_id]);

// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
  // is_salesman: row.is_salesman
}));

//check salesman


/*
const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);
  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!count_salesman) {
    await block_user(req,'Ssru05')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }
*/

const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);
  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!count_itemLocation) {
    await block_user(req,'Spru06')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }


// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const item_typeId = rowData.item_typeId;
  const item_id = rowData.item_id;


  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +item_id && +item.account_type_id === +item_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Spru07')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }

  items_array.push(+rowData.item_id)
}

locations_array.push(+posted_elements.itemLocationId)

    // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
    let rows03 = await db.any(query03, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbTaxesHeaderArray = rows03.map(row => ({
      id: parseInt(row.id)
    }));
    

    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const row_taxHeaderId = rowData.row_taxHeaderId;
      
      if (row_taxHeaderId){
      //! make sure from every account_id
      const taxExists = dbTaxesHeaderArray.some(item =>
        +item.id === +row_taxHeaderId
      );
      
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!taxExists) {
        await block_user(req,'Spqr08')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    }


    
    const year = getYear(posted_elements.datex)

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {

      let query1 = `update transaction_header
                    set total_value = $1,
                      general_note = $2,
                      datex = $3,
                      account_id = $4,
                      is_column1 = $5,
                      is_column2 = $6,
                      is_column3 = $7,
                      items_location_id = $8,
                      invoice_id = $9
                    Where
                      id = $10
                      AND company_id = $11
                    ;`;

      await tx.none(query1, [
        total.toFixed(2),
        posted_elements.general_note,
        posted_elements.datex,
        posted_elements.vendorId,
        posted_elements.is_RowDiscount ? true : null,
        posted_elements.is_RowNote ? true : null,
        posted_elements.is_RowTax ? true : null,
        posted_elements.itemLocationId,
        posted_elements.invoiceReferenceId,
        posted_elements.x,
        req.session.company_id
      ]);

      const query_delete = `delete from transaction_body where transaction_header_id = $1`
      await tx.none(query_delete,[posted_elements.x])

      let global_stock_id = await tx.oneOrNone(`select id from accounts_header ah where ah.company_id = 1 and ah.global_id = 12`, [req.session.company_id])
      let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
      let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')

      let other_posted_array = []
      let Val_beforTax = 0
      let taxValue = 0
      let TotalValue = 0
      let insert_array2 = []
      for (const element of posted_elements.posted_array) {

        //! make sure if account id != item  then location and amount = null

        if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
          await block_user(req,'Ssra3')
          throw new Error(
            'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
          );
        }

      
        
       const rowDiscountType = +element.row_discountTypeId || 0
       const rowDiscountValue= +element.row_discountValue || 0
       const rowAmount = +element.row_amount || 0
       const rowUnitePrice = +element.row_unitPrice || 0

        const Xrow_discount_value =
        rowDiscountType === 1
            ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
            : +rowDiscountValue;
            Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
            TotalValue += Val_beforTax
            
           /*
            let cogs = null 
            if (+element.item_typeId === 5){
              x = items_avg.find(item => +item.item_id === element.item_id)
              if (x){
                cogs = (+element.row_amount * +x.avg)*-1
              }
            }
          */



        let account_id
        if (+element.item_typeId === 5){
          account_id = +global_stock_id.id
        }else{
          const account_row = DeafultAccounts.find(item => +item.id === element.item_id);
        
          if (!account_row){
            await block_user(req,'Spia4')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }
          account_id = +account_row.item_expense_account 
        }
        

        insert_array2.push([
          posted_elements.x,
          null,
          +Val_beforTax,
          element.row_note,
          +element.row_amount *-1,
          +element.row_unitPrice,
          +account_id,
          +element.row_discountTypeId === 1 ? true : null,
          element.row_discountValue || null,
          element.row_taxHeaderId || null,
          null,
          null,
          +element.item_typeId === 5? element.item_id : null,
          +element.item_typeId === 5? posted_elements.itemLocationId : null
        ]);

        //! check if has taxHeader
        if (element.row_taxHeaderId){
          const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
          if (taxesbodyArray){
            for (const row of taxesbodyArray){
              const taxRate = +row.tax_rate /100
              const taxMultiplier = row.is_tax_reverse ? -1 : 1;
              taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
              TotalValue += taxValue

              const newObject = {
                taxBodyId: row.id,
                taxHeaderId: row.settings_tax_header_id,
                debit: taxValue > 0 ? taxValue : null,
                credit: taxValue < 0 ? taxValue*-1 : null,
                account_id: row.tax_account_id,
                is_tax: true
              }
              other_posted_array.push(newObject)
            }
          }
        }

      }

        

      //! add vendor row to transaction
      const newObject = {
        taxBodyId: null,
        taxHeaderId: null,
        debit: TotalValue > 0 ? TotalValue : null,
        credit: TotalValue < 0 ? TotalValue*-1 : null,
        account_id: posted_elements.vendorId,
        is_tax: null
      }
      other_posted_array.push(newObject)

      //! insert the other part to transaction
      for (const object of other_posted_array){


        insert_array2.push([
        posted_elements.x,
        +object.debit || null,
        +object.credit || null,
        null,
        null,
        null,
        +object.account_id,
        null,
        null,
        +object.taxHeaderId || null,
        +object.taxBodyId || null,
        object.is_tax,
        null,
        null
        ]);

      }
      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      let query2 = `INSERT INTO transaction_body
      (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id,  is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
      VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;

await tx.none(query2, insert_array2.flat());
}

const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
if (!allow_amounts){
  throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
} else if (allow_amounts !== true) {
  throw new Error(allow_amounts);
}
      await update_items_cogs(items_array,posted_elements.datex, req, tx)
      await history(transaction_type,2,posted_elements.x,result_1.reference,req,tx);
    });

    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(result_1.reference);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„  Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error purshases_returns_update:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/purshases_returns_add", async (req, res) => {
  try {

    
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "purshases_returns_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }




    const posted_elements = req.body;
    const transaction_type = 7 // sales_returns
    let items_array = []
    let locations_array = []
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.item_typeId + obj.item_id + obj.row_note + obj.row_amount + obj.row_unitPrice + obj.row_discountTypeId + obj.row_discountValue + obj.row_taxHeaderId), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.vendorrId,
      posted_elements.total,
      posted_elements.datex,
      posted_elements.invoiceReferenceId,
      posted_elements.itemLocationId,
      // posted_elements.salesmanId,
      posted_elements.is_RowNote,
      posted_elements.is_RowDiscount,
      posted_elements.general_note,
      posted_elements.location_name,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'add',
      tableName: false, // if type = 'update' or 'delete' only
      transaction_id: false, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------

   const total = +posted_elements.total

   if (!total || isNaN(total)){
    await block_user(req,'Spra001')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
   }


// //! Security hacking  accounts id

   // check qutationReferenceId

    let query05;
    let rows05;
    if (posted_elements.invoiceReferenceId){
      query05 = `select count(id) as purshasesReturnsReferenceCount from transaction_header where id = $1 and company_id = $2 and transaction_type = 6 and is_deleted IS NULL`
      rows05 = await db.oneOrNone(query05, [posted_elements.invoiceReferenceId, req.session.company_id])
     if (rows05.purshasesReturnsReferenceCount === 0){
       await block_user(req,'Ssra02')
       return res.json({
         success: false,
         xx: true,
         message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
       });
     }
     }

// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query02 = `SELECT id, account_type_id, is_salesman FROM accounts_header WHERE company_id = $1 AND is_inactive is null`;
let rows02 = await db.any(query02, [req.session.company_id]);

// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
  // is_salesman: row.is_salesman
}));

//check salesman

/*
 const count_salesman = dbAccounts.some(row => +row.id === +posted_elements.salesmanId && +row.account_type_id === 4 && row.is_salesman === true);

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!count_salesman) {
    await block_user(req,'Spra03')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }
*/

const count_itemLocation = dbAccounts.some(row => +row.id === +posted_elements.itemLocationId && +row.account_type_id === 7);

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!count_itemLocation) {
    await block_user(req,'Spra04')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }


// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const item_typeId = rowData.item_typeId;
  const item_id = rowData.item_id;


  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +item_id && +item.account_type_id === +item_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Spra05')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }

  items_array.push(+rowData.item_id)
}

locations_array.push(+posted_elements.itemLocationId)

    // Ø¬Ù„Ø¨ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    let query03 = `SELECT id FROM settings_tax_header WHERE company_id = $1`;
    let rows03 = await db.any(query03, [req.session.company_id]);
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
    const dbTaxesHeaderArray = rows03.map(row => ({
      id: parseInt(row.id)
    }));
    

    // Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
    for (const rowData of posted_elements.posted_array) {
      const row_taxHeaderId = rowData.row_taxHeaderId;
      
      if (row_taxHeaderId){
      //! make sure from every account_id
      const taxExists = dbTaxesHeaderArray.some(item =>
        +item.id === +row_taxHeaderId
      );
      

    
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
      if (!taxExists) {
        await block_user(req,'Spra6')
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
    }
    }

    const year = getYear(posted_elements.datex)
    const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header',transaction_type, year, req);
    const newId_general_reference = await newId_fn("transaction_header", 'general_reference');

    
    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {

      let query1 = `INSERT INTO transaction_header
                    (reference, company_id, transaction_type, total_value, general_note, datex, account_id, is_column1, is_column2, is_column3, items_location_id, invoice_id, general_reference, is_including_items)
                    VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9 , $10 , $11 , $12, $13, $14) RETURNING id;`;

      const insert = await tx.one(query1, [
        newReference_transaction_header,
        req.session.company_id,
        transaction_type,
        total.toFixed(2),
        posted_elements.general_note,
        posted_elements.datex,
        posted_elements.vendorId,
        posted_elements.is_RowDiscount ? true : null,
        posted_elements.is_RowNote ? true : null,
        posted_elements.is_RowTax ? true : null,
        posted_elements.itemLocationId,
        posted_elements.invoiceReferenceId,
        newId_general_reference,
        true
      ]);
      const newId_transaction_header = insert.id;

      let global_stock_id = await tx.oneOrNone(`select id from accounts_header ah where ah.company_id = 1 and ah.global_id = 12`, [req.session.company_id])
      let DeafultAccounts = await tx.any('select id, item_revenue_account, item_expense_account from accounts_header where is_final_account = true and company_id = $1 and is_inactive IS NULL',[req.session.company_id])
      let taxBodyArray = await tx.any('select id, tax_rate, is_tax_reverse, tax_account_id, settings_tax_header_id from settings_tax_body')

      let other_posted_array = []
      let Val_beforTax = 0
      let taxValue = 0
      let TotalValue = 0
      let insert_array2 = []
      for (const element of posted_elements.posted_array) {

        //! make sure if account id != item  then location and amount = null

        if(isNaN(+element.row_amount) || isNaN(+element.row_unitPrice)){
          await block_user(req,'Spra7')
          throw new Error(
            'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
          );
        }

        
       const rowDiscountType = +element.row_discountTypeId || 0
       const rowDiscountValue= +element.row_discountValue || 0
       const rowAmount = +element.row_amount || 0
       const rowUnitePrice = +element.row_unitPrice || 0

        const Xrow_discount_value =
        rowDiscountType === 1
            ? +((rowDiscountValue / 100) * (rowAmount * rowUnitePrice))
            : +rowDiscountValue;
            Val_beforTax = +((rowAmount * rowUnitePrice) - Xrow_discount_value).toFixed(2);
            TotalValue += Val_beforTax
            
          //  let cogs = null 
          // if (+element.item_typeId === 5){
          //   x = items_avg.find(item => +item.item_id === element.item_id)
          //   if (x){
          //     cogs = (+element.row_amount * +x.avg)*-1
          //   }
          // }

          



        let account_id
        if (+element.item_typeId === 5){
          account_id = +global_stock_id.id
        }else{
          const account_row = DeafultAccounts.find(item => +item.id === element.item_id);
          if (!account_row){
            await block_user(req,'Spra8')
            throw new Error(
              'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
            );
          }

          account_id = +account_row.item_expense_account 
        }

        insert_array2.push([
          newId_transaction_header,
          null,
          +Val_beforTax,
          element.row_note,
          +element.row_amount * -1,
          +element.row_unitPrice,
          +account_id,
          +element.row_discountTypeId === 1 ? true : null,
          element.row_discountValue || null,
          element.row_taxHeaderId || null,
          null,
          null,
          +element.item_typeId === 5? element.item_id : null,
          +element.item_typeId === 5? posted_elements.itemLocationId : null
        ]);

        //! check if has taxHeader
        if (element.row_taxHeaderId){
          const taxesbodyArray = taxBodyArray.filter(item => +item.settings_tax_header_id === +element.row_taxHeaderId)
          if (taxesbodyArray){
            for (const row of taxesbodyArray){
              const taxRate = +row.tax_rate /100
              const taxMultiplier = row.is_tax_reverse ? -1 : 1;
              taxValue = +(Val_beforTax * taxRate * taxMultiplier).toFixed(2);
              TotalValue += taxValue

              const newObject = {
                taxBodyId: row.id,
                taxHeaderId: row.settings_tax_header_id,
                debit: taxValue < 0 ? taxValue*-1 : null,
                credit: taxValue > 0 ? taxValue : null,
                account_id: row.tax_account_id,
                is_tax: true
              }
              other_posted_array.push(newObject)
            }
          }
        }

      }

        

      //! add vendor row to transaction
      const newObject = {
        taxBodyId: null,
        taxHeaderId: null,
        debit: TotalValue > 0 ? TotalValue : null,
        credit: TotalValue < 0 ? TotalValue*-1 : null,
        account_id: posted_elements.vendorId,
        is_tax: null
      }
      other_posted_array.push(newObject)

      //! insert the other part to transaction
      for (const object of other_posted_array){


        insert_array2.push([
        newId_transaction_header,
        +object.debit || null,
        +object.credit || null,
        null,
        null,
        null,
        +object.account_id,
        null,
        null,
        +object.taxHeaderId || null,
        +object.taxBodyId || null,
        object.is_tax,
        null,
        null
        ]);

      }
      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      let query2 = `INSERT INTO transaction_body
      (transaction_header_id, debit, credit, row_note, item_amount, item_price, account_id, is_discount_percentage, dicount_value, settings_tax_header_id, settings_tax_body_id, is_tax, item_id, item_location_id_tb)
      VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;

await tx.none(query2, insert_array2.flat());
}
      
const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
if (!allow_amounts){
  throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
} else if (allow_amounts !== true) {
  throw new Error(allow_amounts);
}

      await update_items_cogs(items_array,posted_elements.datex, req, tx)
      await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
    });

    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error adding purshases returns:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/get_data_for_purshases_returns_update", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "purshases_returns_permission", "update");
    if (!permissions) {
      return;
    }

    
    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    const transaction_type = 7 // Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª

    

    let query1 = `
     -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
  id as id,
  account_name as account_name
from
  accounts_header 
WHERE company_id = $1 
  AND account_type_id = 7
  AND is_inactive IS NULL
  ;
`;
let params1 = [req.session.company_id]

/*
let query2 = `
  select
  id as id,
  account_name as account_name
from
  accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4
  AND is_final_account IS true
  and is_salesman IS true
  AND is_inactive IS null
  ;
`
let params2 = [req.session.company_id]
*/

let query3 = `
    select 
  th.id,
  th.taxe_package_name as account_name
from
   settings_tax_header th
where
  th.company_id = $1
  and th.is_inactive is null
order by
  th.taxe_package_name asc 
 
`
let params3 = [req.session.company_id]

let query4 = `
select
    tb.id,
    tb.tax_name,
    tb.tax_rate,
    tb.is_tax_reverse,
    tb.tax_account_id,
    ah.account_name,
    tb.settings_tax_header_id
from
    settings_tax_body tb
left join accounts_header ah on ah.id = tb.tax_account_id    
where
    tb.settings_tax_header_id = ANY($1::int[])
    AND ah.is_inactive IS NULL
`;


let query5 = `
SELECT
ah.id,
ah.account_name,
ah.account_type_id,
COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
ah.item_revenue_account,
ah_revenue.account_name as revenue_account_name,
ah.item_expense_account,
ah_expense.account_name as expense_account_name,
ah.item_sales_price,
ah.item_purshas_price
FROM
accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
ah.company_id = $1
AND ah.is_final_account = true
AND ah.account_type_id IN (5, 8)
AND ah.is_inactive IS NULL
`;

let params5 = [req.session.company_id];


let query6 = `
select
  ah.id,
  ah.account_name
from
  accounts_header ah
where
  ah.company_id = $1
  AND ah.is_final_account is true
  AND is_inactive is null
  AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`

  let params6 = [req.session.company_id];


let query7 = `
select 
  th.id,
  th.reference,
  COALESCE(th.general_note, '' ) as general_note,
  th.datex,
  th.due_date,
  th.account_id,
  th.invoice_id,
  th.is_delivered,
  th.items_location_id,
  th.is_column2 as is_row_note_show,
  th.is_column1 as is_row_dicount_show,
  th.is_column3 as is_row_tax_show,
  CONCAT(
    tt1.doc_prefix, '-',
    SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
  ) AS referenceconcat,
  CONCAT(
    tt2.doc_prefix, '-',
    SUBSTRING(th_invoice.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    LPAD(CAST(th_invoice.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
  ) AS referenceconcat_invoice
from
  transaction_header th
left join transaction_header th_invoice on th_invoice.id = th.invoice_id
LEFT JOIN transaction_type tt1 ON tt1.id = th.transaction_type
LEFT JOIN transaction_type tt2 ON tt2.id = th_invoice.transaction_type
where 
th.id = $1
and th.company_id = $2
and th.transaction_type = $3
AND th.is_deleted IS NULL
`
let params7 = [posted_elements.x, req.session.company_id, transaction_type];

let query8 = `
select
  tb.id,
  tb.item_id,
    ah.account_name,
    ah.item_unite,
    ah.account_type_id as item_type_id,
  ABS(tb.item_amount) as amount,
  tb.item_price as unite_price,
  COALESCE(tb.row_note, '') as row_note,
  tb.is_discount_percentage,
  tb.dicount_value,
  tb.settings_tax_header_id as tax_header_id,
    sth.taxe_package_name
from
  transaction_body tb
LEFT JOIN accounts_header ah on ah.id = tb.item_id
LEFT JOIN settings_tax_header sth on sth.id = tb.settings_tax_header_id
left join account_type at on at.id = ah.account_type_id
where 
  tb.transaction_header_id = $1
  AND tb.item_id is NOT NULL
  ;
`
let params8 = [posted_elements.x]


let query9 = `
select 
  th.id,
      CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS account_name
from
  transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type  
where
  th.transaction_type = 6 -- ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª
  and th.company_id = $1
  and th.account_id = $2
  and th.is_deleted is NULL
   ` 

   let params9 = [req.session.company_id, posted_elements.vendor_id]


await db.tx(async (tx) => {

  const itemslocationsArray = await tx.any(query1, params1);
  // const salesmanArray = await tx.any(query2, params2);
  const taxHeaderArray = await tx.any(query3, params3);
  const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
  const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
  const itemsDataArray = await tx.any(query5, params5);
  const vendorsDataArray = await tx.any(query6, params6);
  const headerData = await tx.oneOrNone(query7, params7);
  const bodyData = await tx.any(query8, params8);
  const purshasesInvoiceReferencesArray = await tx.any(query9, params9);

  const postedData = {itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, headerData, bodyData, purshasesInvoiceReferencesArray};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_data_for_purshases_returns_update", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/get_data_for_purshasesInvoiceToreturns", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "purshases_returns_permission", "add");
    if (!permissions) {
      return;
    }

    
    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    const transaction_type = 7


    let query1 = `
     -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
  id as id,
  account_name as account_name
from
  accounts_header 
WHERE company_id = $1 
  AND account_type_id = 7
  AND is_inactive IS NULL
  ;
`;
let params1 = [req.session.company_id]

/*
let query2 = `
  select
  id as id,
  account_name as account_name
from
  accounts_header 
WHERE company_id = $1 
  AND account_type_id = 4
  AND is_final_account IS true
  and is_salesman IS true
  AND is_inactive IS null
  ;
`
let params2 = [req.session.company_id]
*/

let query3 = `
    select 
  th.id,
  th.taxe_package_name as account_name
from
   settings_tax_header th
where
  th.company_id = $1
  and th.is_inactive is null
order by
  th.taxe_package_name asc 
 
`
let params3 = [req.session.company_id]

let query4 = `
select
    tb.id,
    tb.tax_name,
    tb.tax_rate,
    tb.is_tax_reverse,
    tb.tax_account_id,
    ah.account_name,
    tb.settings_tax_header_id
from
    settings_tax_body tb
left join accounts_header ah on ah.id = tb.tax_account_id    
where
    tb.settings_tax_header_id = ANY($1::int[])
    AND ah.is_inactive IS NULL
`;


let query5 = `
SELECT
ah.id,
ah.account_name,
ah.account_type_id,
COALESCE(ah.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') as item_unite,
ah.item_revenue_account,
ah_revenue.account_name as revenue_account_name,
ah.item_expense_account,
ah_expense.account_name as expense_account_name,
ah.item_sales_price,
ah.item_purshas_price
FROM
accounts_header ah
left join accounts_header ah_revenue on ah_revenue.id = ah.item_revenue_account
left join accounts_header ah_expense on ah_expense.id = ah.item_expense_account
WHERE
ah.company_id = $1
AND ah.is_final_account = true
AND ah.account_type_id IN (5, 8)
AND ah.is_inactive IS NULL
`;

let params5 = [req.session.company_id];


let query6 = `
select
  ah.id,
  ah.account_name
from
  accounts_header ah
where
  ah.company_id = $1
  AND ah.is_final_account is true
  AND is_inactive is null
  AND (ah.account_type_id = 3 or ah.is_allow_to_buy_and_sell is true);`

  let params6 = [req.session.company_id];


let query7 = `
select 
  th.id,
  th.reference,
  COALESCE(th.general_note, '') as general_note,
  th.datex,
  th.account_id,
  th.items_location_id,
  th.is_column1 as is_row_dicount_show,
  th.is_column2 as is_row_note_show,
  th.is_column3 as is_row_tax_show,
  CONCAT(
    tt.doc_prefix, '-',
    SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
  ) AS referenceconcat
from
  transaction_header th
  LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
where 
th.id = $1
and th.company_id = $2
and th.transaction_type = 6 -- ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª
AND th.is_deleted IS NULL
`
let params7 = [posted_elements.x, req.session.company_id];

let query8 = `
select
  tb.id,
  tb.item_id,
    ah.account_name,
    ah.item_unite,
    ah.account_type_id as item_type_id,
  ABS(tb.item_amount) as amount,
  tb.item_price as unite_price,
  COALESCE(tb.row_note, '') as row_note,
  tb.is_discount_percentage,
  tb.dicount_value,
  tb.settings_tax_header_id as tax_header_id,
    sth.taxe_package_name
from
  transaction_body tb
LEFT JOIN accounts_header ah on ah.id = tb.item_id
LEFT JOIN settings_tax_header sth on sth.id = tb.settings_tax_header_id
left join account_type at on at.id = ah.account_type_id
where 
  tb.transaction_header_id = $1
  and tb.item_id is not NULL
  ;
`
let params8 = [posted_elements.x]


let query9 = `
select 
  th.id,
      CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS account_name
from
  transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type  
where
  th.transaction_type = 6
  and th.company_id = $1
  and th.account_id = $2
  and th.is_deleted is NULL
   ` 

   let params9 = [req.session.company_id, posted_elements.vendor_id]
  

await db.tx(async (tx) => {

  const itemslocationsArray = await tx.any(query1, params1);
  // const salesmanArray = await tx.any(query2, params2);
  const taxHeaderArray = await tx.any(query3, params3);
  const settings_tax_header_id_Array = taxHeaderArray.map(row => row.id);  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ IDs Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø«Ø§Ù„Ø«
  const taxBodyArray = await tx.any(query4, [settings_tax_header_id_Array]);  // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹
  const itemsDataArray = await tx.any(query5, params5);
  const vendorsDataArray = await tx.any(query6, params6);
  const headerData = await tx.oneOrNone(query7, params7);
  const bodyData = await tx.any(query8, params8);
  const purshasesInvoiceReferencesArray = await tx.any(query9, params9);

  const postedData = { itemslocationsArray, taxHeaderArray, taxBodyArray, itemsDataArray, vendorsDataArray, headerData, bodyData, purshasesInvoiceReferencesArray};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_data_for_purshasesInvoiceToreturns", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});

app.post("/api/purshases_returns_delete", async (req, res) => {
  try {

    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "purshases_returns_permission", "delete");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 7
  

      //! sql injection check
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'delete',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------



// //! Security hacking  accounts id


    let query1 = `select reference, datex from transaction_header where id = $1 and company_id = $2 AND transaction_type = $3 AND is_deleted IS NULL`
    let result1 = await db.oneOrNone(query1,[posted_elements.x, req.session.company_id, transaction_type])

    if (!result1){
      await block_user(req,'Sprd001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    
    const year = getYear(result1.datex)


    let query2 = `select item_id from transaction_body where transaction_header_id = $1 AND item_id IS NOT NULL`;
    let result2 = await db.any(query2, [posted_elements.x]);
    
    if (!result2 || result2.length === 0) {
      await block_user(req, 'Sprd001');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ø£Ø±Ù‚Ø§Ù…
    const items_array = result2.map(row => row.item_id);
    
  
    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {

      let query1 = `update transaction_header
                    set is_deleted = true
                    Where
                      id = $1
                      AND company_id = $2
                      AND transaction_type = $3
                    ;`;

      const resultQ1 = await tx.result(query1, [
        posted_elements.x,
        req.session.company_id,
        transaction_type
      ]);

      if (resultQ1.rowCount === 0) {
        await block_user(req,'Sprd1')
        throw new Error(
          'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚'
        );
      }

      const query_delete = `delete from transaction_body where transaction_header_id = $1`
      await tx.none(query_delete,[posted_elements.x])


      //! history
      await update_items_cogs(items_array,result1.datex, req, tx)
      await history(transaction_type,3,posted_elements.x,result1.reference,req,tx);
    });

    await update_items_cogs(req,items_array,result1.datex)
    const new_referenceFormatting = formatFromFiveDigits(result1.reference);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ù…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error purshases_returns_delete:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//#endregion


//#region fixed_assests_management

app.post("/get_expenses_accounts", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "fixed_assests_permission", "add");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     --  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ØµÙˆØ±ÙØ§Øª Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	ah.id as id,
	ah.account_name as account_name
from
	accounts_header ah
WHERE ah.company_id = $1
  AND ah.account_type_id in(1,6)
  and ah.finance_statement = 2
  and ah.main_account_id = 5
  and ah.is_final_account is true
  and ah.global_id != 17
  and ah.is_inactive is null
  ;
`;
let params1 = [req.session.company_id]

let query2 = `
--  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ØµÙˆØ±ÙØ§Øª Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	ah.id as id
from
	accounts_header ah
WHERE ah.company_id = $1
      and ah.global_id = 18

;
`;
let params2 = [req.session.company_id]



await db.tx(async (tx) => {

  const expensesAccountsArray = await tx.any(query1, params1);
  const deafultDepreciationExpensesAccount = await tx.oneOrNone(query2, params2);

  
  const postedData = { expensesAccountsArray, deafultDepreciationExpensesAccount};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});


app.post("/fixed_assests_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "fixed_assests_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------

 


let quer1 = `
with 
balance_query AS (
    SELECT 
        ah.id,
        COALESCE(
            SUM(
        		CASE 
            		WHEN tb.is_accumulated_depreciation IS NULL THEN (COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0))
            		ELSE 0
        		END
            ), 0
        ) AS asset_cost,
        COALESCE(
            SUM(
        		CASE 
            		WHEN tb.is_accumulated_depreciation IS TRUE THEN (COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0))
            		ELSE 0
        		END
            ), 0
        ) AS depreciation_value        
    FROM 
        accounts_header ah
    LEFT JOIN transaction_body tb ON ah.id = tb.account_id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
    	AND ah.account_type_id = 6
        AND ah.is_final_account = true
        AND th.is_deleted IS NULL
        AND th.datex <= $2
    GROUP BY
        ah.id
),
main_query as(
SELECT
    ah.id,
    ah.account_no,
    ah.account_name,
    ah.item_expense_account,
    ah.str10_data_column1 AS purshases_date,
    ah.str10_data_column2 AS started_depreciation_date,
    ah.numeric_column1 AS rate_value,
    ah.numeric_column2 AS un_depericated_value,
    ah.str50_column1 AS fixed_ssests_group_name,
    ah.str_textarea_column1 AS asset_info,
	coalesce(bq.asset_cost, 0) AS asset_cost,
	COALESCE(bq.depreciation_value, 0) AS depreciation_value,
     'Ù†Ø´Ø·' as assest_status
FROM
    accounts_header ah
left join balance_query bq on bq.id = ah.id
WHERE
    ah.company_id = $1
    AND ah.account_type_id = 6
    and ah.is_final_account is true
), 
end_query as (
select
    mq.id,
    mq.account_no,
    mq.account_name,
    mq.item_expense_account,
    mq.purshases_date,
    mq.started_depreciation_date,
    mq.rate_value,
    mq.un_depericated_value,
    mq.fixed_ssests_group_name,
    mq.asset_info,
	mq.asset_cost,
	mq.depreciation_value,
	mq.asset_cost - mq.depreciation_value as book_value,
	mq.assest_status
    from
    	main_query mq
)
SELECT * 
FROM end_query
ORDER BY 
    CASE 
        WHEN book_value = 0 THEN 1  -- Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© ØªØ°Ù‡Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
        ELSE 0                   -- Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£Ø¹Ù„Ù‰
    END,
    book_value DESC;  -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§   
;
`;

// ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
let data = await db.any(quer1, [req.session.company_id, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_sales_invoice_Data_view:", error);
    res.status(500).send("Error:");
  }
});

app.post("/fixed_assests_add", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "fixed_assests_permission", "add");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.fixed_ssests_name_input_value || posted_elements.fixed_ssests_name_input_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø§ØµÙ„",
      });
    }          
    
    if (!posted_elements.rate_input_value || isNaN(posted_elements.rate_input_value)){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¶Ø±ÙŠØ¨Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­",
      });
    }     
    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );

    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2) as count_account_name,
               (select main_account_id FROM accounts_header WHERE company_id = $1 AND global_id = 9) as parent_main_account_id,
               (select id FROM accounts_header WHERE company_id = $1 AND global_id = 9) as parent_id,
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $3 AND account_type_id = 1 AND main_account_id = 5 AND global_id != 17) as count_expense_account
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.fixed_ssests_name_input_value,    
      posted_elements.dropdown_div_hidden_input_value, // depreciation_account
    ]);
    
     

    if (result.count_expense_account === 0) {
      await block_user(req, 'Sfaa001');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ø§ØµÙ„ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
      });
    }


    if (!result.parent_main_account_id || !result.parent_id) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†Ù‰ ÙˆØ§Ù„Ø§Ø¨Ù„Ø§Øº Ø¹Ù† ÙƒÙˆØ¯ Ø§Ù„Ø®Ø·Ø£ (Sfaa1)"
      });
    }

    //3: insert data into db
    
    


    await db.tx(async (tx) => {

    let query1 = `
  INSERT INTO accounts_header (account_name, account_no, is_final_account, finance_statement, company_id, account_type_id, main_account_id, item_expense_account, str10_data_column1, str10_data_column2, numeric_column1, numeric_column2, str50_column1, str_textarea_column1)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) RETURNING id;
`;

  let params1 =[
    posted_elements.fixed_ssests_name_input_value,
    posted_elements.fixed_ssests_input_value,
    true,
    1,
    req.session.company_id,
    6,
    +result.parent_main_account_id,
    posted_elements.dropdown_div_hidden_input_value,
    posted_elements.purshase_date_input_value,
    posted_elements.started_accumulated_depeciation_date_input_value,
    posted_elements.rate_input_value,
    posted_elements.un_depericated_value_input_value,
    posted_elements.fixed_ssests_group_name_input_value,
    posted_elements.asset_info_input_value
  ]

  const insert = await tx.one(query1, params1);

  const newId_header = insert.id;

  let query2 = `INSERT INTO accounts_body (parent_id, account_id)
                VALUES ($1, $2)`

  let params2 = [
    +result.parent_id,
    newId_header
  ]               


    await tx.none(query2, params2);
    await history(14, 1, newId_header, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§ØµÙ„ Ø§Ù„Ø«Ø§Ø¨Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error fixed_assests_add:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/add_imported_fixed_assests", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "fixed_assests_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
 
    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }

    if (posted_elements.posted_array.length > 301) {
      throw new Error(`âš ï¸ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‡Ùˆ 300 ØµÙ. ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù„Ù‰ Ø¯ÙØ¹Ø§Øª Ø£ØµØºØ±.`);
    }

    //! sql injection check - ÙØ­Øµ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø®Ù„ posted_array
    let hasBadSymbols = posted_elements.posted_array.some(row =>
      row.some(cell => sql_anti_injection([cell]))
    );
    
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }
    
    turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements){
      throw new Error(`âš ï¸ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥ØªØ¨Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­`);
    }
    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit
    
    const fixedAssestsParent = await db.oneOrNone(`select id, main_account_id from accounts_header where company_id = $1 AND global_id = 9`, [req.session.company_id])

    if (!fixedAssestsParent || !fixedAssestsParent.id || !fixedAssestsParent.main_account_id){
      throw new Error(`âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Saaifa01 `);
    }

    const parent_id = fixedAssestsParent.id

    const db_AllAccounts = await db.any(
      `select id, account_name, is_final_account, account_type_id, main_account_id from accounts_header where company_id = $1`,
      [req.session.company_id]
    );

    const db_expenses_accounts_array = db_AllAccounts.filter(
      (row) => row.is_final_account === true && +row.main_account_id === 5
    );
    
    const company_id = req.session.company_id;
    const account_type_id = 6;
    


    // Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªØ®Ø²ÙŠÙ† Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£ØµÙ†Ø§Ù Ø§Ù„Ù„ÙŠ Ø¨ØªØªØ­Ù‚Ù‚ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù„ÙˆØ¨
    const fixedAssestsNamesSet = new Set();
    
    let array1 = [];
    let validRows = []; // Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù„ÙŠ Ø¯Ø®Ù„Øª ÙØ¹Ù„ÙŠÙ‹Ø§
    let index = 1;
    
    for (const row of posted_elements.posted_array) {
      let account_no = row[0] || null;
      let account_name = row[1] || null;
      let purshases_date = row[2] || null;
      let started_accumulated_date = row[3] || null;
      let rate = row[4] || null;
      let value_canNot_deprecated = row[5] || null;
      let group_dec = row[6] || null;
      let other_info = row[7] || null;
      let expense_account = row[8] || null;
    

    
      if (account_no === 'Ù…Ø¹Ø±Ù Ø§Ù„Ø£ØµÙ„ Ø§Ù„Ø«Ø§Ø¨Øª ( Ø§Ø®ØªÙŠØ§Ø±Ù‰ )' || account_name === 'Ø§Ø³Ù… Ø§Ù„Ø£ØµÙ„ Ø§Ù„Ø«Ø§Ø¨Øª ( Ù…Ø·Ù„ÙˆØ¨ )' || purshases_date === 'ØªØ§Ø±ÙŠØ® Ø´Ø±Ø§Ø¡ Ø§Ù„Ø£ØµÙ„ ( Ù…Ø·Ù„ÙˆØ¨ )') {
        console.log(`skip header row`);
        //index++;
        continue;
      }

      if (!account_name) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø£ØµÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
      const InValidDateFormat1 = isInValidDateFormat([started_accumulated_date]);
      if (InValidDateFormat1) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø¥Ù‡Ù„Ø§Ùƒ Ø§Ù„Ø£ØµÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }


      const InValidDateFormat2 = isInValidDateFormat([purshases_date]);
      if (InValidDateFormat2) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… ØªØ§Ø±ÙŠØ® Ø´Ø±Ø§Ø¡ Ø§Ù„Ø£ØµÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }

      if (!rate || isNaN(parseFloat(rate))) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ù‡Ù„Ø§Ùƒ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }

      if (value_canNot_deprecated !== null && (value_canNot_deprecated === "" || isNaN(+value_canNot_deprecated))) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¥Ù‡Ù„Ø§Ùƒ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ù„Ù„Ø£ØµÙ„ ${account_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
    
  
      const isNameExists = db_AllAccounts.some((account) => account.account_name.trim() === account_name);
      if (isNameExists) {
        throw new Error(`âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³Ù… Ø§Ù„Ø£ØµÙ„ '${account_name}' Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
    
     const get_expense_account_id = db_expenses_accounts_array.find((acc) => acc.account_name.trim() === expense_account && !acc.is_deleted);

      if (!get_expense_account_id || !expense_account) {
        throw new Error(`âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø­Ø³Ø§Ø¨ Ù…ØµØ±ÙˆÙ Ø§Ù„Ø¥Ù‡Ù„Ø§Ùƒ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ù„Ù„Ø£ØµÙ„ ${account_name} ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… : ${index}`);
      }
      expense_account = get_expense_account_id.id


      if (fixedAssestsNamesSet.has(account_name)) {
        throw new Error(`âŒ Ø§Ù„Ø£ØµÙ„ '${account_name}' Ù…ÙƒØ±Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
      }
      fixedAssestsNamesSet.add(account_name);
    
    
      array1.push([
        account_name,
        account_no,
        true,
        1,
        company_id,
        account_type_id,
        fixedAssestsParent.main_account_id,
        expense_account,
        purshases_date,
        started_accumulated_date,
        rate,
        value_canNot_deprecated,
        group_dec,
        other_info
      ]);
    
      validRows.push(row); // ØªØ®Ø²ÙŠÙ† Ø§Ù„ØµÙ Ø§Ù„ØµØ§Ù„Ø­ ÙÙ‚Ø·
    
      index++;
    }
    
// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {

// Ø¥Ø¯Ø®Ø§Ù„ accounts_header
if (array1.length > 0){

let columnsCount = array1[0].length;
let query1 = `INSERT INTO accounts_header (account_name, account_no, is_final_account, finance_statement, company_id, account_type_id, main_account_id, item_expense_account, str10_data_column1, str10_data_column2, numeric_column1, numeric_column2, str50_column1, str_textarea_column1)
  VALUES ${array1.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}
  RETURNING id;`;

const insertedIds = await tx.many(query1, array1.flat());

// Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª accounts_body
let array2 = insertedIds.map((inserted) => [
  parent_id, // Ø«Ø§Ø¨Øª Ù„ÙƒÙ„ Ø§Ù„ØµÙÙˆÙ
  inserted.id
]);


let columnsCount2 = array2[0].length;
let query2 = `INSERT INTO accounts_body (parent_id, account_id)
              VALUES ${array2.map((_, i) => 
                `(${Array.from({ length: columnsCount2 }, (_, j) => `$${i * columnsCount2 + j + 1}`).join(', ')})`
              ).join(', ')}`


await tx.none(query2, array2.flat());

}

 // await history(transaction_type, 1, newId_transaction_header, newReference_transaction_header, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
   // const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ù‰ Ø¨Ù†Ø¬Ø§Ø­ `,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error add_imported_customers:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/get_fixed_assests_data_for_update_page", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "fixed_assests_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     --  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ØµÙˆØ±ÙØ§Øª Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	ah.id as id,
	ah.account_name as account_name
from
	accounts_header ah
WHERE ah.company_id = $1
  AND ah.account_type_id in(1,6)
  and ah.finance_statement = 2
  and ah.main_account_id = 5
  and ah.is_final_account is true
  and ah.global_id != 17
  and ah.is_inactive is null
  ;
`;
let params1 = [req.session.company_id]

let query2 = `
--  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ØµÙˆØ±ÙØ§Øª Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select
	ah.id as id
from
	accounts_header ah
WHERE ah.company_id = $1
      and ah.global_id = 18
;
`;
let params2 = [req.session.company_id]


let query3 = `
--  Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§ØµÙ„ Ø§Ù„Ø«Ø§Ø¨Øª
select
	ah.id,
	ah.account_no,
	ah.account_name,
	ah.item_expense_account,
	ah.str10_data_column1 as purshases_date,
	ah.str10_data_column2 AS started_depreciation_date,
	ah.numeric_column1 AS rate_value,
	ah.numeric_column2 AS un_depericated_value,
	ah.str50_column1 AS fixed_ssests_group_name,
	ah.str_textarea_column1 AS asset_info
from
	accounts_header ah
where 
	ah.company_id = $1
	and ah.id = $2
	and ah.account_type_id = 6
	and ah.is_final_account is true
;
`;
let params3 = [req.session.company_id, posted_elements.x]


await db.tx(async (tx) => {

  const expensesAccountsArray = await tx.any(query1, params1);
  const deafultDepreciationExpensesAccount = await tx.oneOrNone(query2, params2);
  const asset_data = await tx.oneOrNone(query3, params3);

  
  const postedData = { expensesAccountsArray, deafultDepreciationExpensesAccount, asset_data};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});

app.post("/fixed_assests_update", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "fixed_assests_permission", "update");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.fixed_ssests_name_input_value || posted_elements.fixed_ssests_name_input_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø§ØµÙ„",
      });
    }          
    
    if (!posted_elements.rate_input_value || isNaN(posted_elements.rate_input_value)){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¶Ø±ÙŠØ¨Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­",
      });
    }     
    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );

    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2) as count_account_name,
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $3 and account_type_id = 6) as count_id,
                (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $4 AND account_type_id = 1 AND main_account_id = 5 AND global_id != 17) as count_expense_account
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.fixed_ssests_name_input_value,
      posted_elements.x,
      posted_elements.dropdown_div_hidden_input_value,
    ]);



    if (result.count_expense_account === 0) {
      await block_user(req, 'Sfau001');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    if (result.count_id === 0) {
      await block_user(req,'Sfau002')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    
     
    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ø§ØµÙ„ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
      });
    }


    let query1 = `
  UPDATE accounts_header set account_name = $1,
                    account_no = $2,
                    item_expense_account = $3,
                    str10_data_column1 = $4,
                    str10_data_column2 = $5,
                    numeric_column1 = $6,
                    numeric_column2 = $7,
                    str50_column1 = $8,
                    str_textarea_column1 = $9
                where
                    id = $10
                    AND company_id = $11
                    AND account_type_id = 6
                    ;
  `;

  let params1 =[
    posted_elements.fixed_ssests_name_input_value,
    posted_elements.fixed_ssests_input_value,
    posted_elements.dropdown_div_hidden_input_value,
    posted_elements.purshase_date_input_value,
    posted_elements.started_accumulated_depeciation_date_input_value,
    posted_elements.rate_input_value,
    posted_elements.un_depericated_value_input_value,
    posted_elements.fixed_ssests_group_name_input_value,
    posted_elements.asset_info_input_value,
    posted_elements.x,
    req.session.company_id
  ]



  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    await history(14, 2, posted_elements.x, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§ØµÙ„ Ø§Ù„Ø«Ø§Ø¨Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error fixed_assests_update:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/fixed_assests_delete", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "fixed_assests_permission", "delete");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

       
    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );

    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $2 AND is_final_account IS TRUE and account_type_id = 6) as count_id,
               (select count(id) FROM transaction_body WHERE account_id = $2) as count_transaction_body
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.x
    ]);


    if (result.count_id === 0) {
      await block_user(req,'Sfad001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    if (result.count_transaction_body > 0) {
      return res.json({
        success: false,
        message_ar: 'âŒ ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø§ØµÙ„ Ø§Ù„Ø«Ø§Ø¨Øª ÙÙ‰ Ø§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„ÙŠÙˆÙ…ÙŠÙ‡ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°ÙÙ‡',
      });
    }


    let query1 = `
  delete from accounts_header where id = $1 AND company_id = $2 AND is_final_account is true AND account_type_id = 6;
  `;

  let params1 =[
    posted_elements.x,
    req.session.company_id
  ]



  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    await history(14, 3, posted_elements.x, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§ØµÙ„ Ø§Ù„Ø«Ø§Ø¨Øª Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error fixed_assests_delete:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/get_accumulated_depreciation_Data_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "accumulated_depreciation_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


let quer1 = `
select
	th.id,
	th.datex,
	CONCAT(
      tt.doc_prefix, '-',
  		SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    	LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
	) AS referenceconcat,
	COALESCE(th.general_note, '') as general_note,
	th.total_value
from 
	transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
where 
	th.company_id = $1
  AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
	AND th.transaction_type = 15
	AND th.is_deleted is null
order by
  th.datex DESC,
  th.reference DESC
`;

// ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
let data = await db.any(quer1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_accumulated_depreciation_Data_view:", error);
    res.status(500).send("Error:");
  }
});

app.post("/get_accumulated_depeciaton_accounts", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "accumulated_depeciaton_permission", "add");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     --  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙ‰ Ø¹Ù…Ù„ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ
select
	ah.id as id,
	ah.account_name as account_name
from
	accounts_header ah
WHERE ah.company_id = $1
  AND ah.account_type_id = 6
  and ah.finance_statement = 1
  and ah.is_final_account is true
  and ah.is_inactive is null
  ;
`;
let params1 = [req.session.company_id]




await db.tx(async (tx) => {

  const fixedAssestsAccounts = await tx.any(query1, params1);

  
  const postedData = {fixedAssestsAccounts};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get Employees Data", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/get_calculated_depreacation_values", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "accumulated_depreciation", "add");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;


    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    const InValidDateFormat = isInValidDateFormat([posted_elements.startDate, posted_elements.endDate]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }


    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");





    let query1 = `

    -- Ø§Ù„ÙƒÙˆØ¯ Ù‡Ù†Ø§ Ù‡ÙŠØ­Ø³Ø¨ Ø§Ù„ÙØªØ±Ù‡ Ø§Ù„Ù…Ø¯Ø®Ù„
-- Ø§Ø°Ø§ ÙƒØ§Ù†Øª ØªØªØ±ÙˆØ§Ø­ Ø¨ÙŠÙ† 28 ÙŠÙˆÙ… Ø§Ù„Ù‰ 31 ÙŠÙˆÙ… Ø³ÙŠØªÙ… Ø§Ø¹ØªØ¨Ø§Ø±Ù‡ ÙƒØ´Ù‡Ø± ÙƒØ§Ù…Ù„ ÙˆÙ†Ù‚Ø³Ù… Ø¹Ù„Ù‰ 12 Ø´Ù‡Ø± 
-- Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ÙØªØ±Ù‡ ØªØªØ±Ø§ÙˆØ­ Ø¨ÙŠÙ† 364 ÙŠÙˆÙ… Ø§Ù„Ù‰ 365  Ø³ÙŠØªÙ… Ø§Ø¹ØªØ¨Ø§Ø±Ù‡ Ø³Ù†Ù‡ ÙƒØ§Ù…Ù„Ù‡  365 ÙŠÙˆÙ… 
-- Ø§Ù…Ø§ Ø¨Ø®Ù„Ø§Ù Ø°Ù„Ùƒ Ø³ÙŠØªÙ… Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ø¹Ù„Ù‰ Ø§Ø³Ø§Ø³ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Ø¹Ø¯Ø¯ Ø§Ù„Ø§ÙŠØ§Ù…

WITH main_query AS (
    SELECT
        ah.id,
        ah.account_no,
        ah.account_name,
        ah.str10_data_column1 AS purchases_date,
        ah.str10_data_column2 AS started_depreciation_date,
        COALESCE(ah.numeric_column1 / 100, 0) AS rate_value,
        COALESCE(ah.numeric_column2, 0) AS un_depreciated_value,
        ah.str50_column1 AS fixed_assets_group_name,
        ah.str_textarea_column1 AS asset_info,
        SUM(CASE 
                WHEN tb.is_accumulated_depreciation IS NULL THEN (COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0))
                ELSE 0
            END) AS asset_cost,
        SUM(CASE 
                WHEN tb.is_accumulated_depreciation IS TRUE THEN (COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0))
                ELSE 0
            END) AS depreciation_value,
        GREATEST($3::DATE - $2::DATE, 0) AS days_value -- Ù…Ù†Ø¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø³Ø§Ù„Ø¨Ø©
    FROM
        accounts_header ah
    INNER JOIN transaction_body tb ON tb.account_id = ah.id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        AND ah.finance_statement = 1
        AND ah.account_type_id = 6
        AND (th.is_deleted IS NULL OR th.is_deleted = FALSE)
    GROUP BY
        ah.id
),
second_query AS (
    SELECT
        mq.id,
        mq.account_name,
        mq.days_value,
        mq.un_depreciated_value,
        mq.asset_cost,
        mq.depreciation_value,
        mq.rate_value,
        -- Ù…Ù†Ø·Ù‚ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ù‡Ù„Ø§Ùƒ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„ÙØªØ±Ø©
        CASE
            WHEN mq.days_value BETWEEN 364 AND 366 THEN (mq.asset_cost * mq.rate_value) -- Ø³Ù†Ø© ÙƒØ§Ù…Ù„Ø©
            WHEN mq.days_value BETWEEN 28 AND 31 THEN ((mq.asset_cost * mq.rate_value) / 12) -- Ø´Ù‡Ø± ÙƒØ§Ù…Ù„
            ELSE ((mq.asset_cost * mq.rate_value) / 365) * mq.days_value -- ÙØªØ±Ø© Ù…Ù†ÙØµÙ„Ø©
        END AS original_calculated_value,
        mq.asset_cost - mq.un_depreciated_value - mq.depreciation_value AS viable_value_to_depreciate
    FROM main_query mq
),
calc_query as ( SELECT
    sq.id,
    sq.account_name,
ROUND(
    CASE
        WHEN (viable_value_to_depreciate - sq.original_calculated_value - sq.depreciation_value - sq.un_depreciated_value) > 0 THEN sq.original_calculated_value
        WHEN (viable_value_to_depreciate - sq.original_calculated_value - sq.depreciation_value - sq.un_depreciated_value) < 0 THEN
            CASE
                WHEN (viable_value_to_depreciate - sq.depreciation_value - sq.un_depreciated_value) > 0 THEN 
                    (viable_value_to_depreciate - sq.depreciation_value - sq.un_depreciated_value)
            END
        ELSE 0
    END,
    2
) AS depreciated_value

FROM
    second_query sq
)
select
  calc.id,
  calc.account_name,
  calc.depreciated_value
from
    calc_query calc
where
  COALESCE(calc.depreciated_value, 0) > 0
  ;
`;
let params1 = [req.session.company_id, posted_elements.startDate, posted_elements.endDate]


let query2 = `
--  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙ‰ Ø¹Ù…Ù„ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ
select
ah.id as id,
ah.account_name as account_name
from
accounts_header ah
WHERE ah.company_id = $1
AND ah.account_type_id = 6
and ah.finance_statement = 1
and ah.is_final_account is true
and ah.is_inactive is null
;
`;
let params2 = [req.session.company_id]



await db.tx(async (tx) => {

  const calculated_depreciation_data = await tx.any(query1, params1);
  const fixedAssestsAccounts = await tx.any(query2, params2);

  const postedData = {calculated_depreciation_data, fixedAssestsAccounts};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_calculated_depreacation_values", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});

app.post("/api/accumulated_depreciation_add", async (req, res) => {
  try {

    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "accumulated_depreciation_permission_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }




    const posted_elements = req.body;
    const transaction_type = 15 // Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ©
    let items_array = []
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_id + obj.depreciation_value), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.datex,
      posted_elements.startDate,
      posted_elements.endDate,
      posted_elements.note,
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex, posted_elements.startDate, posted_elements.endDate]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'add',
      tableName: false, // if type = 'update' or 'delete' only
      transaction_id: false, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------

    if (posted_elements.startDate > posted_elements.endDate){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ ÙØªØ±Ø© Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }


    const accounts_array = posted_elements.posted_array.map(row => parseInt(row.account_id)); // Ø³ØªØ¸Ù‡Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©: [15, 54, 51]
    

    const query001 = `
WITH main_query AS (
    SELECT
        ah.id,
        ah.account_no,
        ah.account_name,
        ah.item_expense_account,
        ah.str10_data_column1 AS purchases_date,
        ah.str10_data_column2 AS started_depreciation_date,
        COALESCE(ah.numeric_column1 / 100, 0) AS rate_value,
        COALESCE(ah.numeric_column2, 0) AS un_depreciated_value,
        ah.str50_column1 AS fixed_assets_group_name,
        ah.str_textarea_column1 AS asset_info,
        SUM(CASE 
                WHEN tb.is_accumulated_depreciation IS NULL THEN (COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0))
                ELSE 0
            END) AS asset_cost,
        SUM(CASE 
                WHEN tb.is_accumulated_depreciation IS TRUE THEN (COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0))
                ELSE 0
            END) AS depreciation_value
    FROM
        accounts_header ah
    left JOIN transaction_body tb ON tb.account_id = ah.id
    left JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        AND ah.finance_statement = 1
        AND ah.account_type_id = 6
        AND (th.is_deleted IS NULL OR th.is_deleted = FALSE)
        AND ah.id IN (${accounts_array.join(',')})
    GROUP BY
        ah.id
)
    SELECT
        mq.id,
        mq.item_expense_account,
        mq.started_depreciation_date,
        mq.asset_cost - mq.un_depreciated_value - mq.depreciation_value AS viable_value_to_depreciate
    FROM main_query mq
      ;
      `
      const params001 = [req.session.company_id]
      const result = await db.any(query001, params001) || [];

  
      if (result.length === 0) {
        return res.json({
          success: false,
          message_ar: 'Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù†Ø´Ø§Ø¡ Ø§ØµÙˆÙ„ Ø«Ø§Ø¨ØªØ© Ø§ÙˆÙ„Ø§ : Sadd002',
        });
      }


      const year = getYear(posted_elements.datex)
      const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header',transaction_type, year, req);
      const newId_general_reference = await newId_fn("transaction_header", 'general_reference');


      await db.tx(async (tx) => {

      // ÙØ­Øµ Ø§Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„ÙØ±ÙˆÙ†Øª Ø§Ù†Ø¯ Ø§ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ù„Ø§Ø­Ø¯ Ø§Ù„Ø§ØµÙˆÙ„ ÙÙ‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

      let total = 0
      let insert_array2 = []
      const frontEndDatex = posted_elements.startDate
      let index = 1


      let query1 = `INSERT INTO transaction_header
      (reference, company_id, transaction_type, total_value, general_note, datex, general_reference, str10_date_column1, str10_date_column2)
      VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9) RETURNING id;`;

let params1 = [
newReference_transaction_header,
req.session.company_id,
transaction_type,
total.toFixed(2),
posted_elements.note,
posted_elements.datex,
newId_general_reference,
posted_elements.startDate,
posted_elements.endDate,
]                    
const insert = await tx.one(query1, params1);

const newId_transaction_header = insert.id;

      for ( const row of posted_elements.posted_array){
        const dbRow = result.find(item => +item.id === row.account_id);
        
        if (!dbRow){
          await block_user(req,'Sada03')
          throw new Error("ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø§Ù„Ù‰  : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†Ù‰ : Sacda01");
        }

        if (!dbRow.item_expense_account){
          throw new Error(`âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø­Ø³Ø§Ø¨ Ù…ØµØ±ÙˆÙ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ù…Ø®ØµØµ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
        }
        
        if (!dbRow.started_depreciation_date){
          throw new Error(`âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø­Ø³Ø§Ø¨ ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
        }

        

        if (frontEndDatex < dbRow.started_depreciation_date){
          throw new Error(`âŒ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø£ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© ÙØªØ±Ø© Ø§Ù„Ø¥Ù‡Ù„Ø§Ùƒ Ù„Ù„Ø£ØµÙ„ ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`);
        }
     

        if ((+dbRow.viable_value_to_depreciate || 0) - (+row.depreciation_value || 0) < 0) {
          throw new Error(`âŒ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø© Ù„Ù„Ø¥Ù‡Ù„Ø§Ùƒ ØªØªØ¬Ø§ÙˆØ² Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø¥Ù‡Ù„Ø§Ùƒ ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}.`);
        }
        
        // Ø³Ø·Ø± Ø§Ù„Ù…ØµÙˆØ±Ù
        insert_array2.push([
          newId_transaction_header, // transaction_header_id
          +row.depreciation_value || 0, // debit
          null, //credit          
          +dbRow.item_expense_account, // Ø­Ø³Ø§Ø¨ Ù…ØµØ±ÙˆÙ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ù…Ø®ØµØµ
          null // is_accumulated_depreciation
        ]);


        // Ø³Ø·Ø± Ø§Ù„Ù…Ø¬Ù…Ø¹
        insert_array2.push([
          newId_transaction_header, // transaction_header_id
          null, //debit
          +row.depreciation_value || 0, // credit
          +row.account_id, // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§ØµÙ„
          true // is_accumulated_depreciation
        ]);


        total += +row.depreciation_value || 0
        index++;
      }

      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      let query2 = `INSERT INTO transaction_body
      (transaction_header_id, debit, credit, account_id, is_accumulated_depreciation)
      VALUES ${insert_array2.map((_, i) => 
        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
      ).join(', ')}`;
      await tx.none(query2, insert_array2.flat());
    }

        // ØªØ­Ø¯ÙŠØ« transaction_header Ø¨Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù„Ù€ total
        let queryUpdate = `UPDATE transaction_header SET total_value = $1 WHERE id = $2;`;
        await tx.none(queryUpdate, [total.toFixed(2), newId_transaction_header]);
    
      //! history
      await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
    });

    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù‡Ù„Ø§Ùƒ Ø§ØµÙˆÙ„ Ø«Ø§Ø¨ØªØ© Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error accumulated_depreciation_add:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/accumulated_depreciation_update", async (req, res) => {
  try {

    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "accumulated_depreciation_permission_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }




    const posted_elements = req.body;
    const transaction_type = 15 // Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ©
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_id + obj.depreciation_value), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.x,
      posted_elements.datex,
      posted_elements.startDate,
      posted_elements.endDate,
      posted_elements.note,
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex, posted_elements.startDate, posted_elements.endDate]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'update',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------

    if (posted_elements.startDate > posted_elements.endDate){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ ÙØªØ±Ø© Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }

    const q1 = `select id, reference from transaction_header where id = $1 and company_id = $2 and transaction_type = $3 and is_deleted IS NULL;`
    const r1 = await db.oneOrNone(q1, [posted_elements.x, req.session.company_id, transaction_type])

    if (!r1){
      await block_user(req,'Sadu04')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    const accounts_array = posted_elements.posted_array.map(row => parseInt(row.account_id)); // Ø³ØªØ¸Ù‡Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©: [15, 54, 51]
    

    const query001 = `
WITH main_query AS (
    SELECT
        ah.id,
        ah.account_no,
        ah.account_name,
        ah.item_expense_account,
        ah.str10_data_column1 AS purchases_date,
        ah.str10_data_column2 AS started_depreciation_date,
        COALESCE(ah.numeric_column1 / 100, 0) AS rate_value,
        COALESCE(ah.numeric_column2, 0) AS un_depreciated_value,
        ah.str50_column1 AS fixed_assets_group_name,
        ah.str_textarea_column1 AS asset_info,
        SUM(CASE 
                WHEN tb.is_accumulated_depreciation IS NULL THEN (COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0))
                ELSE 0
            END) AS asset_cost,
        SUM(CASE 
                WHEN tb.is_accumulated_depreciation IS TRUE THEN (COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0))
                ELSE 0
            END) AS depreciation_value
    FROM
        accounts_header ah
    left JOIN transaction_body tb ON tb.account_id = ah.id
    left JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        and th.id != $2 -- @@@@@@@ Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø§Ù„Ù‚ÙŠØ¯ Ù†ÙØ³Ù‡
        AND ah.finance_statement = 1
        AND ah.account_type_id = 6
        AND (th.is_deleted IS NULL OR th.is_deleted = FALSE)
        AND ah.id IN (${accounts_array.join(',')})
    GROUP BY
        ah.id
)
    SELECT
        mq.id,
        mq.item_expense_account,
        mq.started_depreciation_date,
        mq.asset_cost - mq.un_depreciated_value - mq.depreciation_value AS viable_value_to_depreciate
    FROM main_query mq
      ;
      `
      const params001 = [req.session.company_id, posted_elements.x]
      const result = await db.any(query001, params001) || [];

  
      if (result.length === 0) {
        return res.json({
          success: false,
          message_ar: 'Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù†Ø´Ø§Ø¡ Ø§ØµÙˆÙ„ Ø«Ø§Ø¨ØªØ© Ø§ÙˆÙ„Ø§ : Sadd002',
        });
      }
  
      // ÙØ­Øµ Ø§Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„ÙØ±ÙˆÙ†Øª Ø§Ù†Ø¯ Ø§ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ù„Ø§Ø­Ø¯ Ø§Ù„Ø§ØµÙˆÙ„ ÙÙ‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const year = getYear(posted_elements.datex)
      

      let total = 0
      let insert_array2 = []
      const frontEndDatex = posted_elements.startDate
      let index = 1
      await db.tx(async (tx) => {

        let query0 = `DELETE FROM transaction_body where transaction_header_id = $1`
        let parms0 = [posted_elements.x]
        await tx.none(query0, parms0); // delete body


      for ( const row of posted_elements.posted_array){
        const dbRow = result.find(item => +item.id === row.account_id);
        
        if (!dbRow){
          await block_user(req,'Sada03')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });
        }

        if (!dbRow.item_expense_account){
          return res.json({
            success: false,
            message_ar: ` Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø­Ø³Ø§Ø¨ Ù…ØµØ±ÙˆÙ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ù…Ø®ØµØµ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`,
          });
        }
        
        if (!dbRow.started_depreciation_date){
          return res.json({
            success: false,
            message_ar: ` Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø­Ø³Ø§Ø¨ ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`,
          });
        }

        

        if (frontEndDatex < dbRow.started_depreciation_date){
          return res.json({
            success: false,
            message_ar: `Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø£ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© ÙØªØ±Ø© Ø§Ù„Ø¥Ù‡Ù„Ø§Ùƒ Ù„Ù„Ø£ØµÙ„ ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}`,
          });
        }
     

        if ((+dbRow.viable_value_to_depreciate || 0) - (+row.depreciation_value || 0) < 0) {
          return res.json({
            success: false,
            message_ar: `Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø© Ù„Ù„Ø¥Ù‡Ù„Ø§Ùƒ ØªØªØ¬Ø§ÙˆØ² Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø¥Ù‡Ù„Ø§Ùƒ ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù…: ${index}.`,
          });
        }
        
        // Ø³Ø·Ø± Ø§Ù„Ù…ØµÙˆØ±Ù
        insert_array2.push([
          posted_elements.x, // transaction_header_id
          +row.depreciation_value || 0, // debit
          null, //credit          
          +dbRow.item_expense_account, // Ø­Ø³Ø§Ø¨ Ù…ØµØ±ÙˆÙ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ø§Ù„Ù…Ø®ØµØµ
          null // is_accumulated_depreciation
        ]);


        // Ø³Ø·Ø± Ø§Ù„Ù…Ø¬Ù…Ø¹
        insert_array2.push([
          posted_elements.x, // transaction_header_id
          null, //debit
          +row.depreciation_value || 0, // credit
          +row.account_id, // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§ØµÙ„
          true // is_accumulated_depreciation
        ]);


        total += +row.depreciation_value || 0
        index++;
      }

      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      let query2 = `INSERT INTO transaction_body
      (transaction_header_id, debit, credit, account_id, is_accumulated_depreciation)
      VALUES ${insert_array2.map((_, i) => 
        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
      ).join(', ')}`;
      await tx.none(query2, insert_array2.flat());
    }



    let query1 = `UPDATE transaction_header set
    total_value = $1, general_note = $2, datex = $3, str10_date_column1 = $4, str10_date_column2 = $5
    WHERE id = $6 and company_id = $7 and transaction_type = 15 and is_deleted is null
    ;`;

let params1 = [
total.toFixed(2),
posted_elements.note,
posted_elements.datex,
posted_elements.startDate,
posted_elements.endDate,
posted_elements.x,
req.session.company_id        
]                    


await tx.none(query1, params1); // update header
      //! history
      await history(transaction_type,2,posted_elements.x,r1.reference,req,tx);
    });

    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(r1.reference);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù‡Ù„Ø§Ùƒ Ø§ØµÙˆÙ„ Ø«Ø§Ø¨ØªØ© Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error accumulated_depreciation_update:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/get_calculated_depreacation_data_for_update", async (req, res) => {
  try {
    // //! Permission
    await permissions(req, "accumulated_depreciation", "add");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;


    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
        
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    // const InValidDateFormat = isInValidDateFormat([posted_elements.startDate, posted_elements.endDate]);
    // if (InValidDateFormat) {
    //   return res.status(400).json({
    //     success: false,
    //     message_ar: InValidDateFormat_message_ar,
    //   });
    // }


    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    

    let query1 = `
 -- header data query
select
	th.id,
	th.datex,
	CONCAT(
      tt.doc_prefix, '-',
  		SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
    	LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
	) AS referenceconcat,
	COALESCE(th.general_note, '') as general_note,
	th.total_value,
	th.str10_date_column1 as started_date,
	th.str10_date_column2 as end_date
from 
	transaction_header th
  LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
where 
	th.company_id = $1
	and th.id = $2
	and th.transaction_type = 15
	and th.is_deleted is null
  ;
`;

let params1 = [req.session.company_id, posted_elements.x]



let query2 = `
--  Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙ‰ Ø¹Ù…Ù„ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ
select
ah.id as id,
ah.account_name as account_name
from
accounts_header ah
WHERE ah.company_id = $1
AND ah.account_type_id = 6
and ah.finance_statement = 1
and ah.is_final_account is true
and ah.is_inactive is null
;
`;
let params2 = [req.session.company_id]


let query3 = `
--  body data query
select
	tb.id,
	ah.account_name,
	tb.credit as depreciated_value
from 
	transaction_body tb
inner join transaction_header th on th.id = tb.transaction_header_id
inner join accounts_header ah on ah.id = tb.account_id
where 
	th.company_id = $1
	and th.id = $2
	and th.transaction_type = 15
	and th.is_deleted is null
	and tb.credit is not null
	and tb.is_accumulated_depreciation is true
;
`;
let params3 = [req.session.company_id, posted_elements.x]

await db.tx(async (tx) => {

  const haderDataArray = await tx.oneOrNone(query1, params1);
  const fixedAssestsAccounts = await tx.any(query2, params2);
  const bodyDataArray = await tx.any(query3, params3);

  const postedData = {haderDataArray, fixedAssestsAccounts, bodyDataArray};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_calculated_depreacation_values", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/api/accumulated_depreciation_delete", async (req, res) => {

  try {

    //! Permission
    await permissions(req, "accumulated_depreciation_permission", "delete");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }
    const posted_elements = req.body;

    const transaction_type = 15
  
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: false, // if // if type = 'update' or 'add' only
      type: 'delete',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }
    

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    let reference;
    await db.tx(async (tx) => {
            //! Security hacking check id for company_name and transactio type
            let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
            let rows01 = await tx.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
        
            if (!rows01 || !rows01.id) {
              throw new Error("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹");
            }
            reference = rows01.reference
          
                  //? Clear transaction_body
      let query0 = `Delete FROM transaction_body WHERE transaction_header_id = $1`
      await tx.none(query0,[posted_elements.x])

      //? update transaction_header
      let query1 = `update transaction_header set 
                      is_deleted = true
                    WHERE
                      id = $1;`;

      await tx.none(query1, [
        posted_elements.x
      ]);

      //! history
      await history(transaction_type,3,posted_elements.x,reference,req,tx);
    })


    const new_referenceFormatting = formatFromFiveDigits(reference);
    const year = getYear(posted_elements.datex)

    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù‡Ù„Ø§ÙƒØ§Øª Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error accumulated_depreciation_delete:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion

//#region capital_accounts
app.post("/capital_accounts_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "accounts_permission", "view");
    if (!permissions) {
      return;
    }
      
    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.end_date])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


  turn_EmptyValues_TO_null(posted_elements);
//* Start--------------------------------------------------------------



let quer1 = `
WITH 
balance_query AS (
    SELECT 
        ah.id,
        COALESCE(
            SUM(
				COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
            ), 0
        ) AS balance
    FROM 
        accounts_header ah
    LEFT JOIN transaction_body tb ON ah.id = tb.account_id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
        AND ah.account_type_id = 10
        AND ah.is_final_account = true
        AND th.is_deleted IS null
        AND th.datex <= $2
    GROUP BY
        ah.id
),
 main_query as (    
select
	ah.id,
	ah.account_name,
	ah.account_no,
	COALESCE(bq.balance, 0) as balance
from
	accounts_header ah
LEFT JOIN balance_query bq ON ah.id = bq.id
where
	ah.company_id = $1
	and ah.is_final_account is true
	and ah.account_type_id = 10 --  Ø­Ø³Ø§Ø¨Ø§Øª Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„
)
  SELECT *
FROM 
    main_query mq
ORDER BY 
    CASE 
        WHEN mq.balance = 0 THEN 1  -- Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© ØªØ°Ù‡Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
        ELSE 0                      -- Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£Ø¹Ù„Ù‰
    END, 
    mq.balance DESC  -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
    ;
`;

// ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
let data = await db.any(quer1, [req.session.company_id, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error capital_accounts_view:", error);
    res.status(500).send("Error:");
  }
});


app.post("/capital_accounts_add", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "accounts_permission", "add");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.cash_accounts_name_input_value || posted_elements.cash_accounts_name_input_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨",
      });
    }          
    
   
    //* Start--------------------------------------------------------------
    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2) as count_account_name,
               (select main_account_id FROM accounts_header WHERE company_id = $1 AND global_id = 15) as parent_main_account_id,
               (select id FROM accounts_header WHERE company_id = $1 AND global_id = 15) as parent_id
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.cash_accounts_name_input_value
        ]);
    
        console.log(result);
        

    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
      });
    }


    if (!result.parent_main_account_id || !result.parent_id) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†Ù‰ ÙˆØ§Ù„Ø§Ø¨Ù„Ø§Øº Ø¹Ù† ÙƒÙˆØ¯ Ø§Ù„Ø®Ø·Ø£ (Scaa01)"
      });
    }

    //3: insert data into db
    
    

    await db.tx(async (tx) => {


    let query1 = `
  INSERT INTO accounts_header (account_name, account_no, is_final_account, finance_statement, company_id, account_type_id, main_account_id)
  VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id;
`;

  let params1 =[
    posted_elements.cash_accounts_name_input_value,
    posted_elements.cash_accounts_input_value,
    true,
    1,
    req.session.company_id,
    10,
    +result.parent_main_account_id
  ]

  const insert = await tx.one(query1, params1);

  const newId_header = insert.id;


  let query2 = `INSERT INTO accounts_body (parent_id, account_id)
                VALUES ($1, $2)`

  let params2 = [
    +result.parent_id,
    newId_header
  ]               


    await tx.none(query2, params2);
    await history(10, 1, newId_header, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø§Ø¨ Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error capital_accounts_add:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/capital_accounts_update", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "accounts_permission", "update");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.cash_accounts_name_input_value || posted_elements.cash_accounts_name_input_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨",
      });
    }          
    
   
    //* Start--------------------------------------------------------------

    let query0 = `SELECT
                
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2 AND id != $3) as count_account_name,
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $3) as count_id
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.cash_accounts_name_input_value,
      posted_elements.x
        ]);
    
    

    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
      });
    }


    if (!result.count_id === 0) {
      await block_user(req,'Scau001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    //3: insert data into db
    
    

    let query1 = `
  update accounts_header set account_name = $1, account_no = $2
    where id = $3 AND company_id = $4
`;

  let params1 =[
    posted_elements.cash_accounts_name_input_value,
    posted_elements.cash_accounts_input_value,
    posted_elements.x,
    req.session.company_id
  ]
          


  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    await history(10, 2, posted_elements.x, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø§Ø¨ Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error capital_accounts_update:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/capital_accounts_delete", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "accounts_permission", "delete");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

       
    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );

    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $2 AND is_final_account IS TRUE and account_type_id = 9) as count_id,
               (select count(id) FROM transaction_body WHERE account_id = $2) as count_transaction_body
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.x
    ]);


    if (result.count_id === 0) {
      await block_user(req,'Sca001')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    if (result.count_transaction_body > 0) {
      return res.json({
        success: false,
        message_ar: 'âŒ ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°ÙÙ‡',
      });
    }


    let query1 = `
  delete from accounts_header where id = $1 AND company_id = $2 AND is_final_account is true AND account_type_id = 10;
  `;

  let params1 =[
    posted_elements.x,
    req.session.company_id
  ]



  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    await history(10, 3, posted_elements.x, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø§Ø¨ Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error capital_accounts_delete:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion 

//#region cash_managemenet
app.post("/cash_accounts_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "cash_accounts_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------



let quer1 = `
WITH 
balance_query AS (
    SELECT 
        ah.id,
        COALESCE(
            SUM(
				COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
            ), 0
        ) AS balance
    FROM 
        accounts_header ah
    LEFT JOIN transaction_body tb ON ah.id = tb.account_id
    INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE
        ah.company_id = $1
		and ah.account_type_id = 9
        AND ah.is_final_account = true
        AND th.is_deleted IS NULL
        AND th.datex <= $2
    GROUP BY
        ah.id
),
base_query as (
select
	ah.id,
	ah.account_name,
	ah.account_no,
	ah.str50_column1 as group_name,
	coalesce(bq.balance ,0) as balance
from
	accounts_header ah
left join balance_query bq on bq.id = ah.id
where
	ah.company_id = $1
	and ah.is_final_account is true
	and ah.account_type_id = 9
)
SELECT * 
FROM base_query
ORDER BY 
    CASE 
        WHEN balance = 0 THEN 1  -- Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© ØªØ°Ù‡Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
        ELSE 0                   -- Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªØ¨Ù‚Ù‰ Ø¨Ø§Ù„Ø£Ø¹Ù„Ù‰
    END,
    balance DESC;  -- ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø±ØµØ¯Ø© ØºÙŠØ± Ø§Ù„ØµÙØ±ÙŠØ© ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
`;

// ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
let data = await db.any(quer1, [req.session.company_id, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error cash_accounts_view:", error);
    res.status(500).send("Error:");
  }
});

app.post("/cash_accounts_add", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "cash_accounts_permission", "add");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.cash_accounts_name_input_value || posted_elements.cash_accounts_name_input_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨",
      });
    }          
    
   
    //* Start--------------------------------------------------------------

    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2) as count_account_name,
               (select main_account_id FROM accounts_header WHERE company_id = $1 AND global_id = 11) as parent_main_account_id,
               (select id FROM accounts_header WHERE company_id = $1 AND global_id = 11) as parent_id
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.cash_accounts_name_input_value
        ]);
    
    

    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
      });
    }


    if (!result.parent_main_account_id || !result.parent_id) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ : Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†Ù‰ ÙˆØ§Ù„Ø§Ø¨Ù„Ø§Øº Ø¹Ù† ÙƒÙˆØ¯ Ø§Ù„Ø®Ø·Ø£ (Scaa01)"
      });
    }

    //3: insert data into db
    
    

    await db.tx(async (tx) => {


    let query1 = `
  INSERT INTO accounts_header (account_name, account_no, is_final_account, finance_statement, company_id, account_type_id, main_account_id, str50_column1, str_textarea_column1)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id;
`;

  let params1 =[
    posted_elements.cash_accounts_name_input_value,
    posted_elements.cash_accounts_input_value,
    true,
    1,
    req.session.company_id,
    9,
    +result.parent_main_account_id,
    posted_elements.cash_accounts_group_name_input_value,
    posted_elements.cash_info_input_value
  ]

  const insert = await tx.one(query1, params1);

  const newId_header = insert.id;


  let query2 = `INSERT INTO accounts_body (parent_id, account_id)
                VALUES ($1, $2)`

  let params2 = [
    +result.parent_id,
    newId_header
  ]               


    await tx.none(query2, params2);
    await history(9, 1, newId_header, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø¯Ù‰ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error cash_accounts_add:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/get_cash_accounts_data_for_update_page", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_accounts_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------
    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
     --  ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø¯Ù‰
select
	ah.id,
	ah.account_name,
	COALESCE(ah.account_no, '') as account_no,
	COALESCE(ah.str50_column1, '') as group_name,
	COALESCE(ah.str_textarea_column1, '') as account_inf
from
	accounts_header ah
where
	ah.id = $1
	and ah.company_id = $2
	and ah.account_type_id = 9
  ;
`;
let params1 = [posted_elements.x, req.session.company_id]




await db.tx(async (tx) => {

  const accountData = await tx.oneOrNone(query1, params1);

  const postedData = {accountData};
  res.json(postedData);
})


    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while get_cash_accounts_data_for_update_page", error);
    res.join;
    res
      .status(500)
      .json({ success: false,message_ar: error.message || deafultErrorMessage, });
  }
});

app.post("/cash_accounts_update", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "cash_accounts_permission", "update");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

    if (!posted_elements.cash_accounts_name_input_value || posted_elements.cash_accounts_name_input_value == ''){
      return res.json({
        success: false,
        message_ar:
          "âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨",
      });
    }          
    
   
    //* Start--------------------------------------------------------------

    let query0 = `SELECT
                
               (select count(id) FROM accounts_header WHERE company_id = $1 AND account_name = $2 AND id != $3) as count_account_name,
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $3) as count_id
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.cash_accounts_name_input_value,
      posted_elements.x
        ]);
    
    

    if (result.count_account_name > 0) {
      // Ø§Ø°Ø§ Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬
      return res.json({
        success: false,
        message_ar: "Ø§Ø³Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„"
      });
    }


    if (!result.count_id === 0) {
      await block_user(req,'Scau01')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    //3: insert data into db
    
    

    let query1 = `
  update accounts_header set account_name = $1, account_no = $2, str50_column1 = $3, str_textarea_column1 = $4
    where id = $5 AND company_id = $6
`;

  let params1 =[
    posted_elements.cash_accounts_name_input_value,
    posted_elements.cash_accounts_input_value,
    posted_elements.cash_accounts_group_name_input_value,
    posted_elements.cash_info_input_value,
    posted_elements.x,
    req.session.company_id
  ]
          


  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    await history(9, 2, posted_elements.x, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø¯Ù‰ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error cash_accounts_update:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/cash_accounts_delete", async (req, res) => {
  try {
        // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¹Ø¨Ø± WebSocket
        // io.emit('blockUser', { userId: req.session.userId });
        
    const posted_elements = req.body;
    

    //! Permission
      await permissions(req, "cash_accounts_permission", "delete");
      if (!permissions) {
        return;
      }  

    
    //! sql injection check

          // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
          const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

          if (hasBadSymbols) {
            return res.json({
              success: false,
              message_ar:
                "âŒInvalid input detected due to prohibited characters. Please review your input and try again.",
            });
          }

          
          // const InValidDateFormat = isInValidDateFormat([posted_elements.purshase_date_input_value, posted_elements.started_accumulated_depeciation_date_input_value])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }

        turn_EmptyValues_TO_null(posted_elements);

       
    //* Start--------------------------------------------------------------

    //2: validation data befor inserting to db
    // const rows = await db.any(
    //   "SELECT TRIM(employee_name) FROM employees WHERE TRIM(employee_name) = $1",
    //   [posted_elements.employee_name_input]
    // );

    let query0 = `SELECT
               (select count(id) FROM accounts_header WHERE company_id = $1 AND id = $2 AND is_final_account IS TRUE and account_type_id = 9) as count_id,
               (select count(id) FROM transaction_body WHERE account_id = $2) as count_transaction_body
              `;
    let result = await db.oneOrNone(query0, [
      req.session.company_id,
      posted_elements.x
    ]);


    if (result.count_id === 0) {
      await block_user(req,'Scad01')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    if (result.count_transaction_body > 0) {
      return res.json({
        success: false,
        message_ar: 'âŒ ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø¯Ù‰ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°ÙÙ‡',
      });
    }


    let query1 = `
  delete from accounts_header where id = $1 AND company_id = $2 AND is_final_account is true AND account_type_id = 9;
  `;

  let params1 =[
    posted_elements.x,
    req.session.company_id
  ]



  await db.tx(async (tx) => {
    await tx.none(query1, params1);
    await history(9, 3, posted_elements.x, 0, req, tx)
  })

  await last_activity(req)
    //4: send a response to frontend about success transaction
    res.json({
      success: true,
      message_ar: "âœ… ØªÙ… Ø­Ø°Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø¯Ù‰ Ø¨Ù†Ø¬Ø§Ø­",
    });
  } catch (error) {
    await last_activity(req)
    console.error("Error cash_accounts_delete:", error);
    // send a response to frontend about fail transaction
    res.status(500).json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/cash_rc_view", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "transaction_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
 SELECT
    th.id,
    ah.account_name,
    CONCAT(
        tt.doc_prefix, '-',          -- Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø±ÙÙŠÙ† (doc_prefix) Ù…Ù† Ø¬Ø¯ÙˆÙ„ transaction_type
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    th.datex,
    COALESCE(th.general_note, '') AS general_note,
    COALESCE(th.total_value, 0) AS total_value
FROM
    transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
left join accounts_header ah on ah.id = th.account_id
WHERE
    th.company_id = $1 AND
    th.transaction_type = 28
    AND (th.is_deleted IS NULL OR th.is_deleted != true)
   	AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
ORDER BY
    th.datex DESC,
    th.reference DESC;

`;
    let data = await db.any(query1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error cash_transaction_view:", error);
    res.status(500).send("Error:");
  }
});


app.post("/cash_pv_view", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "transaction_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
 SELECT
    th.id,
    ah.account_name,
    CONCAT(
        tt.doc_prefix, '-',          -- Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø±ÙÙŠÙ† (doc_prefix) Ù…Ù† Ø¬Ø¯ÙˆÙ„ transaction_type
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    th.datex,
    COALESCE(th.general_note, '') AS general_note,
    COALESCE(th.total_value, 0) AS total_value
FROM
    transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
left join accounts_header ah on ah.id = th.account_id
WHERE
    th.company_id = $1 AND
    th.transaction_type = 29
    AND (th.is_deleted IS NULL OR th.is_deleted != true)
   	AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
ORDER BY
    th.datex DESC,
    th.reference DESC;

`;
    let data = await db.any(query1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error cash_pv_view:", error);
    res.status(500).send("Error:");
  }
});

app.post("/api/cash_transaction_accounts_types", async (req, res) => {
  try {
    let query1 = `select id, account_type_name
from account_type
where id IN (1, 2, 3, 4 , 10)
order by order_asc ASC;`;  // in (1,2 ) ya3ny = 1 or 2 

    // Ø§Ø³ØªØ¹Ù„Ø§Ù… SQL Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¬Ø±Ø©
    let data = await db.any(query1);
    res.json(data);
  } catch (error) {
    console.error("/api/transaction_accounts_types:", error);
    res.status(500).send("Server Error");
  }
});


app.post("/getCash_rc_AccountsData1", async (req, res) => {
  try {
    // //! Permission
    // await permissions(req, "effects_permission", "view");
    // if (!permissions) {
    //   return;
    // }

    //* Start--------------------------------------------------------------


      let query1 = `
SELECT
  A.id,
  A.account_name,
  A.account_type_id
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  and a.is_inactive is null
  and a.account_type_id in (1, 2, 3, 4, 10) -- nafs id el   /api/cash_transaction_accounts_types
  AND (a.global_id NOT IN (8, 17, 18, 19) OR a.global_id IS NULL)
;
`;
let params1 = [req.session.company_id]

    let query2 = `
    SELECT
      A.id,
      A.account_name
    FROM
      accounts_header A
    WHERE
      A.company_id = $1
      AND is_final_account = true
      and a.is_inactive is null
      and a.account_type_id = 9
    ;
    `;
    let params2 = [req.session.company_id] 

    await db.tx(async (tx) => {

      const accounts_data = await tx.any(query1, params1);
      const cash_accounts = await tx.any(query2, params2);
    
      const postedData = { accounts_data, cash_accounts};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash_transaction_AccountsData1", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/getCash_pv_AccountsData1", async (req, res) => {
  try {
    // //! Permission
    // await permissions(req, "effects_permission", "view");
    // if (!permissions) {
    //   return;
    // }

    //* Start--------------------------------------------------------------


      let query1 = `
SELECT
  A.id,
  A.account_name,
  A.account_type_id
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  and a.is_inactive is null
  and a.account_type_id in (1, 2, 3, 4, 10) -- nafs id el   /api/cash_transaction_accounts_types
  AND (a.global_id NOT IN (8, 17, 18, 19) OR a.global_id IS NULL)
;
`;
let params1 = [req.session.company_id]

    let query2 = `
    SELECT
      A.id,
      A.account_name
    FROM
      accounts_header A
    WHERE
      A.company_id = $1
      AND is_final_account = true
      and a.is_inactive is null
      and a.account_type_id = 9
    ;
    `;
    let params2 = [req.session.company_id] 

    await db.tx(async (tx) => {

      const accounts_data = await tx.any(query1, params1);
      const cash_accounts = await tx.any(query2, params2);
    
      const postedData = { accounts_data, cash_accounts};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash_transaction_AccountsData1", error);
    res.join;
    res
      .status(500)
      .json({ success: false,message_ar: error.message || deafultErrorMessage, });
  }
});


app.post("/api/cash_rc_add", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "cash_transaction_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 28
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.value), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.datex,
      posted_elements.total,
      posted_elements.general_note,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'add',
      tableName: false, // if type = 'update' or 'delete' only
      transaction_id: false, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit

        // //! Security hacking  accounts id
// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND is_final_account IS TRUE`;
let rows02 = await db.any(query02, [req.session.company_id]);




// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
}));

//! Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø³Ø§Ø³Ù‰
const mainAccountExists = dbAccounts.some(item => 
  +item.id === +posted_elements.main_account && +item.account_type_id === 9
);

if (!mainAccountExists){
  await block_user(req,'Sta1')
  return res.json({
    success: false,
    xx: true,
    message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
  });
}


let rowIndex = 1;
// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const account_typeId = rowData.account_typeId;
  const account_id = rowData.account_id;
  const value = +rowData.value;

  if (!value || isNaN(value) || value <= 0){
    return res.json({
      success: false,
      message_ar: `âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
    });
  }

  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +account_id && +item.account_type_id === +account_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Sta1')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }

  
  rowIndex++;
}



const year = getYear(posted_elements.datex);
const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header', transaction_type, year, req)
const newId_general_reference = await newId_fn("transaction_header", 'general_reference');

// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {
  let query1 = `INSERT INTO transaction_header
                (reference, datex, company_id, transaction_type, total_value, general_note, general_reference, account_id)
                VALUES($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id;`;

  const insert = await tx.one(query1, [
    newReference_transaction_header,
    posted_elements.datex,
    req.session.company_id,
    transaction_type,
    posted_elements.total,
    posted_elements.general_note,
    newId_general_reference,
    posted_elements.main_account
  ]);

  const newId_transaction_header = insert.id;


  let insert_array2 = [];
  let items_array = [];



 //todo main_account
 insert_array2.push([
  newId_transaction_header,
  posted_elements.main_account,
  posted_elements.total,
  null,
  null,
]);

  for (const element of posted_elements.posted_array) {
  
    insert_array2.push([
      newId_transaction_header,
      element.account_id,
      null,
      element.value, //! da msh debit da el value ely hayt7t fe ele credit
      element.note_row
    ]);
  }

  if (insert_array2.length > 0){
    let columnsCount = insert_array2[0].length;  

    let query2 = `INSERT INTO transaction_body
    (transaction_header_id, account_id, debit, credit, row_note)
    VALUES ${insert_array2.map((_, i) => 
      `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
    ).join(', ')}`;
    await tx.none(query2, insert_array2.flat());
  
  }


  await history(transaction_type, 1, newId_transaction_header, newReference_transaction_header, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø³Ù†Ø¯ Ù‚Ø¨Ø¶ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_transaction_add:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/api/cash_pv_add", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "cash_transaction_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 29
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.vale), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.datex,
      posted_elements.total,
      posted_elements.general_note,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'add',
      tableName: false, // if type = 'update' or 'delete' only
      transaction_id: false, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit

        // //! Security hacking  accounts id
// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND is_final_account IS TRUE`;
let rows02 = await db.any(query02, [req.session.company_id]);




// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
}));

//! Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø³Ø§Ø³Ù‰
const mainAccountExists = dbAccounts.some(item => 
  +item.id === +posted_elements.main_account && +item.account_type_id === 9
);

if (!mainAccountExists){
  await block_user(req,'Sta1')
  return res.json({
    success: false,
    xx: true,
    message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
  });
}


let rowIndex = 1;
// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const account_typeId = rowData.account_typeId;
  const account_id = rowData.account_id;
  const value = +rowData.value;

  if (!value || isNaN(value) || value <= 0){
    return res.json({
      success: false,
      message_ar: `âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
    });
  }

  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +account_id && +item.account_type_id === +account_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Scpd01')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }

  
  rowIndex++;
}



const year = getYear(posted_elements.datex);
const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header', transaction_type, year, req)
const newId_general_reference = await newId_fn("transaction_header", 'general_reference');

// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {
  let query1 = `INSERT INTO transaction_header
                (reference, datex, company_id, transaction_type, total_value, general_note, general_reference, account_id)
                VALUES($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id;`;

  const insert = await tx.one(query1, [
    newReference_transaction_header,
    posted_elements.datex,
    req.session.company_id,
    transaction_type,
    posted_elements.total,
    posted_elements.general_note,
    newId_general_reference,
    posted_elements.main_account
  ]);

  const newId_transaction_header = insert.id;

  let insert_array2 = [];

  for (const element of posted_elements.posted_array) {
  
    insert_array2.push([
      newId_transaction_header,
      element.account_id,
      element.value, // debit
      null,
      element.note_row
    ]);
  }
   //todo main_account
   insert_array2.push([
    newId_transaction_header,
    posted_elements.main_account,
    null,
    posted_elements.total, // credit
    null,
  ]);


  if (insert_array2.length > 0) {
    let columnsCount = insert_array2[0].length;
  
    let query2 = `INSERT INTO transaction_body
    (transaction_header_id, account_id, debit, credit, row_note)
    VALUES ${insert_array2.map((_, i) => 
      `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
    ).join(', ')}`;
  
    await tx.none(query2, insert_array2.flat());
  }
  

  await history(transaction_type, 1, newId_transaction_header, newReference_transaction_header, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø³Ù†Ø¯ Ø¯ÙØº Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_pv_add:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/getCash_rc_AccountsData2", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_transaction_permission", "view");
    if (!permissions) {
      return;
    }

    
    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


      let query1 = `
SELECT
  A.id,
  A.account_name,
  A.account_type_id
  --COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
  --NULL AS is_accumulated_depreciation
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  and a.is_inactive is null
  and a.account_type_id in (1, 2, 3, 4, 10) -- nafs id el   /api/cash_transaction_accounts_types
  AND (a.global_id NOT IN (8, 17, 18, 19) OR a.global_id IS NULL)
;
`;
let params1 = [req.session.company_id]

    let query2 = `
    SELECT
      A.id,
      A.account_name
    FROM
      accounts_header A
    WHERE
      A.company_id = $1
      AND is_final_account = true
      and a.is_inactive is null
      and a.account_type_id = 9
    ;
    `;
    let params2 = [req.session.company_id] 


    let query3 = `
    SELECT
      th.id,
      th.datex,
      CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS referenceconcat,
      th.account_id,
      ah.account_name,
      COALESCE(th.general_note, '') as general_note
    FROM
      transaction_header th
    inner join accounts_header ah on ah.id = th.account_id
    LEFT JOIN transaction_type tt ON tt.id = th.transaction_type 
    WHERE
      th.company_id = $1
      AND th.id = $2
      AND th.transaction_type = 28
      and th.is_deleted IS NULL
    ;
    `;
    let params3 = [req.session.company_id, posted_elements.x] 

    
    let query4 = `
    SELECT
      ah.account_type_id,
      tb.account_id,
      ah.account_name,
      tb.credit as value,
      COALESCE(tb.row_note, '') as row_note
    FROM
      transaction_body tb
    inner join accounts_header ah on ah.id = tb.account_id
    inner join transaction_header th on th.id = tb.transaction_header_id
    WHERE
      th.company_id = $1
      AND th.id = $2
      AND th.transaction_type = 28
      and th.is_deleted IS NULL
      AND tb.credit IS NOT NULL
    ;
    `;
    let params4 = [req.session.company_id, posted_elements.x] 



    await db.tx(async (tx) => {

      const accounts_data = await tx.any(query1, params1);
      const cash_accounts = await tx.any(query2, params2);
      const headerData = await tx.oneOrNone(query3, params3);
      const bodyData = await tx.any(query4, params4);

    
      const postedData = { accounts_data, cash_accounts, headerData, bodyData};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash_transaction_AccountsData1", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/getCash_pv_AccountsData2", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_transaction_permission", "view");
    if (!permissions) {
      return;
    }

    
    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


      let query1 = `
SELECT
  A.id,
  A.account_name,
  A.account_type_id
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  and a.is_inactive is null
  and a.account_type_id in (1, 2, 3, 4, 10) -- nafs id el   /api/cash_transaction_accounts_types
  AND (a.global_id NOT IN (8, 17, 18, 19) OR a.global_id IS NULL)
;
`;
let params1 = [req.session.company_id]

    let query2 = `
    SELECT
      A.id,
      A.account_name
    FROM
      accounts_header A
    WHERE
      A.company_id = $1
      AND is_final_account = true
      and a.is_inactive is null
      and a.account_type_id = 9
    ;
    `;
    let params2 = [req.session.company_id] 


    let query3 = `
    SELECT
      th.id,
      th.datex,
      CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
      ) AS referenceconcat,
      th.account_id,
      ah.account_name,
      COALESCE(th.general_note, '') as general_note
    FROM
      transaction_header th
    inner join accounts_header ah on ah.id = th.account_id
    LEFT JOIN transaction_type tt ON tt.id = th.transaction_type 
    WHERE
      th.company_id = $1
      AND th.id = $2
      AND th.transaction_type = 29 -- ## Ø³Ù†Ø¯ Ø§Ù„ØµØ±Ù
      and th.is_deleted IS NULL
    ;
    `;
    let params3 = [req.session.company_id, posted_elements.x] 

    
    let query4 = `
    SELECT
      ah.account_type_id,
      tb.account_id,
      ah.account_name,
      tb.debit as value,
      COALESCE(tb.row_note, '') as row_note
    FROM
      transaction_body tb
    inner join accounts_header ah on ah.id = tb.account_id
    inner join transaction_header th on th.id = tb.transaction_header_id
    WHERE
      th.company_id = $1
      AND th.id = $2
      AND th.transaction_type = 29 -- ## Ø³Ù†Ø¯ Ø§Ù„ØµØ±Ù
      and th.is_deleted IS NULL
      AND tb.debit IS NOT NULL
    ;
    `;
    let params4 = [req.session.company_id, posted_elements.x] 



    await db.tx(async (tx) => {

      const accounts_data = await tx.any(query1, params1);
      const cash_accounts = await tx.any(query2, params2);
      const headerData = await tx.oneOrNone(query3, params3);
      const bodyData = await tx.any(query4, params4);

    
      const postedData = { accounts_data, cash_accounts, headerData, bodyData};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash_pv_AccountsData2", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/api/cash_rc_update", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "cash_transaction_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 28
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.value), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.x,
      posted_elements.datex,
      posted_elements.total,
      posted_elements.general_note,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'update',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit

        // //! Security hacking  accounts id
// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);



if (!rows01 || !rows01.id) {
  await block_user(req,'Scta01')
  return res.json({
    success: false,
    xx: true,
    message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
  });
}
const reference = rows01.reference



let query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND is_final_account IS TRUE`;
let rows02 = await db.any(query02, [req.session.company_id]);




// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
}));

//! Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø³Ø§Ø³Ù‰
const mainAccountExists = dbAccounts.some(item => 
  +item.id === +posted_elements.main_account && +item.account_type_id === 9
);

if (!mainAccountExists){
  await block_user(req,'Scta02')
  return res.json({
    success: false,
    xx: true,
    message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
  });
}


let rowIndex = 1;
// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const account_typeId = rowData.account_typeId;
  const account_id = rowData.account_id;
  const value = +rowData.value;

  if (!value || isNaN(value) || value <= 0){
    return res.json({
      success: false,
      message_ar: `âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
    });
  }

  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +account_id && +item.account_type_id === +account_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Scta03')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }

  
  rowIndex++;
}



const year = getYear(posted_elements.datex);

// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {
  let query1 = `update transaction_header set
                datex = $1, total_value = $2, general_note = $3, account_id = $4
                where id = $5 and company_id = $6 and transaction_type = $7;`;

  await tx.none(query1, [
    posted_elements.datex,
    posted_elements.total,
    posted_elements.general_note,
    posted_elements.main_account,
    posted_elements.x,
    req.session.company_id,
    transaction_type
  ]);



  let query001 = `delete from transaction_body where transaction_header_id = $1`
  await tx.none(query001,[posted_elements.x])

  let insert_array2 = [];

 //todo main_account
 insert_array2.push([
  posted_elements.x,
  posted_elements.main_account,
  posted_elements.total,
  null,
  null,
]);

  for (const element of posted_elements.posted_array) {
  
    insert_array2.push([
      posted_elements.x,
      element.account_id,
      null,
      element.value, //! da msh debit da el value ely hayt7t fe ele credit
      element.note_row
    ]);
  }

  if (insert_array2.length > 0){
    let columnsCount = insert_array2[0].length;  

    let query2 = `INSERT INTO transaction_body
    (transaction_header_id, account_id, debit, credit, row_note)
    VALUES ${insert_array2.map((_, i) => 
      `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
    ).join(', ')}`;
    await tx.none(query2, insert_array2.flat());
  }

  await history(transaction_type, 1, posted_elements.x, reference, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(reference);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø³Ù†Ø¯ Ù‚Ø¨Ø¶ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_transaction_update:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/cash_pv_update", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "cash_transaction_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 29
  

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.value), // ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ dataArray Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© ÙˆØ¯Ù…Ø¬Ù‡Ø§ Ù…Ø¹Ø§Ù‹
      posted_elements.x,
      posted_elements.datex,
      posted_elements.total,
      posted_elements.general_note,
      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'update',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    //! check diffrence between debit and credit

        // //! Security hacking  accounts id
// Ø¬Ù„Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
let rows01 = await db.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);



if (!rows01 || !rows01.id) {
  await block_user(req,'Scpu01')
  return res.json({
    success: false,
    xx: true,
    message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
  });
}
const reference = rows01.reference



let query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND is_final_account IS TRUE`;
let rows02 = await db.any(query02, [req.session.company_id]);




// ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ù„Ù„ØªØ³Ù‡ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ­Øµ
const dbAccounts = rows02.map(row => ({
  id: parseInt(row.id),
  account_type_id: row.account_type_id
}));

//! Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø³Ø§Ø³Ù‰
const mainAccountExists = dbAccounts.some(item => 
  +item.id === +posted_elements.main_account && +item.account_type_id === 9
);

if (!mainAccountExists){
  await block_user(req,'Scpu02')
  return res.json({
    success: false,
    xx: true,
    message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
  });
}


let rowIndex = 1;
// Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ ÙƒØ§Ø¦Ù† ÙÙŠ posted_elements.posted_array
for (const rowData of posted_elements.posted_array) {
  const account_typeId = rowData.account_typeId;
  const account_id = rowData.account_id;
  const value = +rowData.value;

  if (!value || isNaN(value) || value <= 0){
    return res.json({
      success: false,
      message_ar: `âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
    });
  }

  //! make sure from every account_id
  const accountExists = dbAccounts.some(item => 
    +item.id === +account_id && +item.account_type_id === +account_typeId
  );

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ Ø§ÙˆÙ‚Ù Ø§Ù„ÙƒÙˆØ¯ ÙˆØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø©
  if (!accountExists) {
    await block_user(req,'Scta03')
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }

  
  rowIndex++;
}



const year = getYear(posted_elements.datex);

// ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
await db.tx(async (tx) => {
  let query1 = `update transaction_header set
                datex = $1, total_value = $2, general_note = $3, account_id = $4
                where id = $5 and company_id = $6 and transaction_type = $7;`;

  await tx.none(query1, [
    posted_elements.datex,
    posted_elements.total,
    posted_elements.general_note,
    posted_elements.main_account,
    posted_elements.x,
    req.session.company_id,
    transaction_type
  ]);



  let query001 = `delete from transaction_body where transaction_header_id = $1`
  await tx.none(query001,[posted_elements.x])

  let insert_array2 = [];

  for (const element of posted_elements.posted_array) {
  
    insert_array2.push([
      posted_elements.x,
      element.account_id,
      element.value, // debit
      null,
      element.note_row
    ]);

  }

   //todo main_account
 insert_array2.push([
  posted_elements.x,
  posted_elements.main_account,
  null,
  posted_elements.total, // credit
  null,
]);

if (insert_array2.length > 0) {
  let columnsCount = insert_array2[0].length;

  let query2 = `INSERT INTO transaction_body
  (transaction_header_id, account_id, debit, credit, row_note)
  VALUES ${insert_array2.map((_, i) => 
    `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
  ).join(', ')}`;

  await tx.none(query2, insert_array2.flat());
}



  await history(transaction_type, 1, posted_elements.x, reference, req, tx);
});


    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(reference);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø³Ù†Ø¯ Ø¯ÙØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_pv_update:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/api/cash_rc_delete", async (req, res) => {

  try {

    //! Permission
    await permissions(req, "cash_transaction_permission", "delete");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }
    const posted_elements = req.body;

    const transaction_type = 28
  
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: false, // if // if type = 'update' or 'add' only
      type: 'delete',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }
    

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    let reference;
    await db.tx(async (tx) => {
            //! Security hacking check id for company_name and transactio type
            let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
            let rows01 = await tx.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
        
            if (!rows01 || !rows01.id) {
              throw new Error("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ù†Ø¯ Ù‚Ø¨Ø¶ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹");
            }
            reference = rows01.reference

          
                  //? Clear transaction_body
      let query0 = `Delete FROM transaction_body WHERE transaction_header_id = $1`
      await tx.none(query0,[posted_elements.x])

      //? update transaction_header
      let query1 = `update transaction_header set 
                      is_deleted = true
                    WHERE
                      id = $1;`;

      await tx.none(query1, [
        posted_elements.x
      ]);
  
      //! history
      await history(transaction_type,3,posted_elements.x,reference,req,tx);
    })


    const new_referenceFormatting = formatFromFiveDigits(reference);
    const year = getYear(posted_elements.datex)

    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø³Ù†Ø¯ Ù‚Ø¨Ø¶ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_rc_delete:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/cash_pv_delete", async (req, res) => {

  try {

    //! Permission
    await permissions(req, "cash_transaction_permission", "delete");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }
    const posted_elements = req.body;

    const transaction_type = 29
  
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      const InValidDateFormat = isInValidDateFormat([posted_elements.datex])
      if (InValidDateFormat){
        return res.json({
          success: false,
          message_ar: InValidDateFormat_message_ar,
        });
      }
    


    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: false, // if // if type = 'update' or 'add' only
      type: 'delete',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }
    

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    let reference;
    await db.tx(async (tx) => {
            //! Security hacking check id for company_name and transactio type
            let query01 = `SELECT id, reference FROM transaction_header WHERE id = $1 AND company_id = $2 AND transaction_type = $3  AND (is_deleted IS NULL OR is_deleted != true);`;
            let rows01 = await tx.oneOrNone(query01, [posted_elements.x, req.session.company_id, transaction_type]);
        
            if (!rows01 || !rows01.id) {
              throw new Error("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ù†Ø¯ Ø¯ÙØ¹ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø±Ø¬Ø¹");
            }
            reference = rows01.reference

          
                  //? Clear transaction_body
      let query0 = `Delete FROM transaction_body WHERE transaction_header_id = $1`
      await tx.none(query0,[posted_elements.x])

      //? update transaction_header
      let query1 = `update transaction_header set 
                      is_deleted = true
                    WHERE
                      id = $1;`;

      await tx.none(query1, [
        posted_elements.x
      ]);
  
      //! history
      await history(transaction_type,3,posted_elements.x,reference,req,tx);
    })


    const new_referenceFormatting = formatFromFiveDigits(reference);
    const year = getYear(posted_elements.datex)

    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø³Ù†Ø¯ Ø¯ÙØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_pv_delete:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/get_cash_transfer_Data_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "cash_transfer_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


let quer1 = `
select
th.id,
th.datex,
th.total_value,
    CONCAT(
      tt.doc_prefix, '-',
      SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
      LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
  ) AS referenceconcat,
  COALESCE(th.general_note, '') as general_note, 
  ah1.account_name as location_from,
  ah2.account_name as location_to
from
transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type  
inner join accounts_header ah1 on ah1.id = th.items_location_id
inner join accounts_header ah2 on ah2.id = th.items_location_id2
where
  th.company_id = $1
  AND (th.datex BETWEEN $2 AND $3) -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨ÙŠÙ† ØªØ§Ø±ÙŠØ®ÙŠÙ†
  AND th.transaction_type = 11
  AND th.is_deleted is null
order by
  th.datex DESC,
  th.reference DESC	
`;

// ØªÙ†ÙÙŠØ° Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª
let data = await db.any(quer1, [req.session.company_id, posted_elements.start_date, posted_elements.end_date]);

    res.json(data);
  } catch (error) {
    console.error("Error get_cash_transfer_Data_view:", error);
    res.status(500).send("Error:");
  }
});


app.post("/getCash", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_transaction_permission", "view");
    if (!permissions) {
      return;
    }

    
    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    let query1 = `
    SELECT
      A.id,
      A.account_name
    FROM
      accounts_header A
    WHERE
      A.company_id = $1
      AND is_final_account = true
      and a.is_inactive is null
      and a.account_type_id = 9
    ;
    `;
    let params1 = [req.session.company_id] 



    await db.tx(async (tx) => {
      const cash_accounts = await tx.any(query1, params1);
 
      const postedData = {cash_accounts};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});


app.post("/get_cash_transfer_data_for_update", async (req, res) => {
  try {
    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_transaction_permission", "view");
    if (!permissions) {
      return;
    }

    
    const posted_elements = req.body;
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    let query1 = `
    SELECT
      A.id,
      A.account_name
    FROM
      accounts_header A
    WHERE
      A.company_id = $1
      AND is_final_account = true
      and a.is_inactive is null
      and a.account_type_id = 9
    ;
    `;
    let params1 = [req.session.company_id] 


    let query2 = `
    select
	th.id,
	th.datex,
	CONCAT(
    	tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    th.total_value,
    COALESCE(th.general_note, '') as general_note,
    th.items_location_id as account_from_id,
    th.items_location_id2 as account_to_id
from
	transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type 
where
	th.id = $1
	and th.company_id = $2
	and th.transaction_type = 11
	and th.is_deleted is null

    `
    let params2 = [posted_elements.x, req.session.company_id]

    await db.tx(async (tx) => {
      const cash_accounts = await tx.any(query1, params1);
      const headerData = await tx.oneOrNone(query2, params2);
 
      const postedData = {cash_accounts, headerData};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});


app.post("/api/cash_transfer_add", async (req, res) => {
  try {

    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_transfer_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }




    const posted_elements = req.body;
    const transaction_type = 11 //   ØªØ­ÙˆÙŠÙ„Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©
    
  

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }



    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'add',
      tableName: false, // if type = 'update' or 'delete' only
      transaction_id: false, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------
    

    if (!posted_elements.value || isNaN(+posted_elements.value) || +posted_elements.value <= 0){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø­ÙˆÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }



    if (!posted_elements.account_from || !posted_elements.account_to){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }

    let quer1 = `
    select
      (select count(id) as count_id from accounts_header where id = $1 and company_id = $3 and account_type_id = 9 and is_final_account IS TRUE and is_inactive IS NULL) as count_id1,
      (select count(id) as count_id from accounts_header where id = $2 and company_id = $3 and account_type_id = 9 and is_final_account IS TRUE and is_inactive IS NULL) as count_id2
  `;
  
  let result1 = await db.oneOrNone(quer1, [posted_elements.account_from, posted_elements.account_to, req.session.company_id]);
  
  if (!result1 || result1.count_id1 === 0 || result1.count_id2 === 0) {
    await block_user(req, 'SCta01');
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }
  
  const year = getYear(posted_elements.datex)
  const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header',transaction_type, year, req);
  const newId_general_reference = await newId_fn("transaction_header", 'general_reference');


  await db.tx(async (tx) => {
      // ÙØ­Øµ Ø§Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„ÙØ±ÙˆÙ†Øª Ø§Ù†Ø¯ Ø§ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ù„Ø§Ø­Ø¯ Ø§Ù„Ø§ØµÙˆÙ„ ÙÙ‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

            let query1 = `INSERT INTO transaction_header
                    (reference, company_id, transaction_type, total_value, general_note, datex, general_reference, items_location_id, items_location_id2)
                    VALUES($1, $2, $3, $4, $5, $6, $7 , $8 , $9) RETURNING id;`;
      
      let params1 = [
        newReference_transaction_header,
        req.session.company_id,
        transaction_type,
        posted_elements.value,
        posted_elements.note,
        posted_elements.datex,
        newId_general_reference,
        +posted_elements.account_from,
        +posted_elements.account_to,
      ]                    
      const insert = await tx.one(query1, params1);
      const newId_transaction_header = insert.id;


      let insert_array2 = []

      insert_array2.push([
        newId_transaction_header, // transaction_header_id
        posted_elements.account_from, // account_id
        posted_elements.value, // debit 
        null //credit
      ]);

      insert_array2.push([
        newId_transaction_header, // transaction_header_id
        posted_elements.account_to, // account_id
        null, // debit 
        posted_elements.value //credit
      ]);

      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;

      let query2 = `INSERT INTO transaction_body
      (transaction_header_id, account_id, debit, credit)
      VALUES ${insert_array2.map((_, i) => 
        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
      ).join(', ')}`;
      await tx.none(query2, insert_array2.flat());
    }
    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  
      // Ø§Ø³ØªØ®Ø¯Ù… tx.batch Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† tx.none

      //! history
      await history(transaction_type,1,newId_transaction_header,newReference_transaction_header,req,tx);
    });

    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©  Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_transfer_add:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/cash_transfer_update", async (req, res) => {
  try {

    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_transfer_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }




    const posted_elements = req.body;
    const transaction_type = 11 //   ØªØ­ÙˆÙŠÙ„Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©
    
  

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }



    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'update',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------
    

    if (!posted_elements.value || isNaN(+posted_elements.value) || +posted_elements.value <= 0){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø­ÙˆÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }



    if (!posted_elements.account_from || !posted_elements.account_to){
      return res.json({
        success: false,
        message_ar: 'âŒ Ø¨Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­',
      });
    }


    let quer001 = `select id, reference from transaction_header where id = $1 AND company_id = $2 AND transaction_type = $3 AND is_deleted IS NULL`;
    let result001 = await db.oneOrNone(quer001, [posted_elements.x, req.session.company_id, transaction_type])

    if (!result001 || !result001.id) {
      await block_user(req, 'SCtu001');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    const reference = result001.reference
    


    let quer1 = `
    select
      (select count(id) as count_id from accounts_header where id = $1 and company_id = $3 and account_type_id = 9 and is_final_account IS TRUE and is_inactive IS NULL) as count_id1,
      (select count(id) as count_id from accounts_header where id = $2 and company_id = $3 and account_type_id = 9 and is_final_account IS TRUE and is_inactive IS NULL) as count_id2
  `;
  
  let result1 = await db.oneOrNone(quer1, [posted_elements.account_from, posted_elements.account_to, req.session.company_id]);
  
  if (!result1 || result1.count_id1 === 0 || result1.count_id2 === 0) {
    await block_user(req, 'SCtu01');
    return res.json({
      success: false,
      xx: true,
      message_ar: 'ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
    });
  }
    
      // ÙØ­Øµ Ø§Ø°Ø§ ÙƒØ§Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ ÙÙ‰ Ø§Ù„ÙØ±ÙˆÙ†Øª Ø§Ù†Ø¯ Ø§ØµØºØ± Ù…Ù† ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠÙ‡ Ø§Ù„Ø§Ù‡Ù„Ø§Ùƒ Ù„Ø§Ø­Ø¯ Ø§Ù„Ø§ØµÙˆÙ„ ÙÙ‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const year = getYear(posted_elements.datex)

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {

      let query1 = `UPDATE transaction_header
      set total_value = $1, general_note = $2, datex = $3, items_location_id = $4, items_location_id2 = $5
      WHERE id = $6 AND company_id = $7 and transaction_type = $8 and is_deleted IS NULL;`;

let params1 = [
posted_elements.value,
posted_elements.note,
posted_elements.datex,
+posted_elements.account_from,
+posted_elements.account_to,
posted_elements.x,
req.session.company_id,
transaction_type
]                    

await tx.none(query1, params1); // update

let query0 = `DELETE FROM transaction_body WHERE transaction_header_id = $1`
let params0 = [posted_elements.x]


await tx.none(query0, params0); // delete

      let insert_array2 = []

      insert_array2.push([
        posted_elements.x, // transaction_header_id
        posted_elements.account_from, // account_id
        posted_elements.value, // debit 
        null //credit
      ]);

      insert_array2.push([
        posted_elements.x, // transaction_header_id
        posted_elements.account_to, // account_id
        null, // debit 
        posted_elements.value //credit
      ]);

      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      let query2 = `INSERT INTO transaction_body
      (transaction_header_id, account_id, debit, credit)
      VALUES ${insert_array2.map((_, i) => 
        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
      ).join(', ')}`;
      await tx.none(query2, insert_array2.flat());
    }


      //! history
      await history(transaction_type,2,posted_elements.x,reference,req,tx);
    });

    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(reference);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©  Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_transfer_update:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/cash_transfer_delete", async (req, res) => {
  try {

    //! Permission Ù…Ø¹Ù„Ù‚
    await permissions(req, "cash_transfer_permission", "delete");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }




    const posted_elements = req.body;
    const transaction_type = 11 //   ØªØ­ÙˆÙŠÙ„Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©
    
  

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }


    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'delete',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    

    //* Start Transaction --------------------------------------------------


    let quer001 = `select id, reference, datex from transaction_header where id = $1 AND company_id = $2 AND transaction_type = $3 AND is_deleted IS NULL`;
    let result001 = await db.oneOrNone(quer001, [posted_elements.x, req.session.company_id, transaction_type])

    if (!result001 || !result001.id) {
      await block_user(req, 'SCtd001');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    const reference = result001.reference
    const datex = result001.datex
    const year = getYear(datex)

  

      let query0 = `DELETE FROM transaction_body WHERE transaction_header_id = $1`
      let params0 = [posted_elements.x]


      let query1 = `UPDATE transaction_header
                    set is_deleted = true
                    WHERE id = $1 AND company_id = $2 and transaction_type = $3 and is_deleted IS NULL;`;
      
      let params1 = [
        posted_elements.x,
        req.session.company_id,
        transaction_type
      ]                    

    // ØªÙ†ÙÙŠØ° Ù…Ø¹Ø§Ù…Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    await db.tx(async (tx) => {

      await tx.none(query1, params1); // update
      await tx.none(query0, params0); // delete

      //! history
      await history(transaction_type,3,posted_elements.x,reference,req,tx);
    });

    // await update_items_cogs(req,items_array,posted_elements.datex)
    const new_referenceFormatting = formatFromFiveDigits(reference);
    await last_activity(req);
    // Ø¥Ø°Ø§ ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­
    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ù‚Ø¯ÙŠØ©  Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });
  } catch (error) {
    await last_activity(req);
    console.error("Error cash_transfer_delete:", error);

    // Ø¥Ø°Ø§ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©ØŒ Ø³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

//#endregion

//#region production

app.post("/production_forms_view_ar", async (req, res) => {
  try {
    //! Permission
    await permissions(req, "production_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          // const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          // if (InValidDateFormat){
          //   return res.json({
          //     success: false,
          //     message_ar: InValidDateFormat_message_ar,
          //   });
          // }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

    let query1 = `
SELECT
    pfh.id,
    COALESCE(pfh.account_no, '') as account_no, 
    pfh.form_name,
    ah.account_name as item_name,
    pfh.production_item_id,
    pfh.location_from,
    ah2.account_name as location_name
FROM
    production_forms_header pfh
left join accounts_header ah on ah.id = pfh.production_item_id
left join accounts_header ah2 on ah2.id = pfh.location_from
LEFT JOIN transaction_type tt ON tt.id = pfh.production_item_id
WHERE
    pfh.company_id = $1
ORDER BY
    pfh.id DESC
`;
    let data = await db.any(query1, [req.session.company_id]);

    res.json(data);
  } catch (error) {
    console.error("Error production_forms_view_ar:", error);
    res.status(500).send("Error:");
  }
});

app.post("/production_forms_AccountsData1", async (req, res) => {
  try {


    //! Permission
    await permissions(req, "production_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      // const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
      // if (InValidDateFormat){
      //   return res.json({
      //     success: false,
      //     message_ar: InValidDateFormat_message_ar,
      //   });
      // }
    


  turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


      let query1 = `
SELECT
  A.id,
  A.account_name,
  A.account_type_id,
  A.item_unite
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  and a.is_inactive is null
  and a.account_type_id in (1, 5)
  AND (a.global_id NOT IN (8, 17, 18, 19) OR a.global_id IS NULL)
;
`;
let params1 = [req.session.company_id]

    let query2 = `
       --  Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select 
	ah.id,
	ah.account_name
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.account_type_id = 7
  and ah.is_inactive is null
    ;
    `;
    let params2 = [req.session.company_id] ;


    let query3 = `select id, account_type_name
    from account_type
    where id IN (1, 5)
    order by id DESC ;`;  // in (1,2 ) ya3ny = 1 or 2 

    let query4 = `select
	pfh.id,
	COALESCE(pfh.account_no, '') as account_no,
	pfh.form_name,
  COALESCE(pfh.value, 0) as value,
	pfh.production_item_id,
	pfh.location_from
from
	production_forms_header pfh 
where
	pfh.id = $1
	and pfh.company_id = $2;`

    let params4 = [posted_elements.x, req.session.company_id]


let query5 = `select
	pfb.id,
	pfb.production_forms_header_id,
	ah.account_type_id,
	ah.account_name,
  COALESCE(ah.item_unite, 'Ø§Ù„Ù…Ø¨Ù„Øº') as item_unite,
	pfb.account_id,
	pfb.value
from
	production_forms_body pfb
inner join production_forms_header pfh on pfh.id = pfb.production_forms_header_id
inner join accounts_header ah on ah.id = pfb.account_id
where
	pfh.id = $1
	and pfh.company_id = $2
  ;
	`
  let params5 = [posted_elements.x, req.session.company_id]  

    await db.tx(async (tx) => {

      const accounts_data_array = await tx.any(query1, params1);
      const location_accounts_array = await tx.any(query2, params2);
      const account_type_array = await tx.any(query3);
      const headerData_array = posted_elements.x ?  await tx.oneOrNone(query4, params4) : false;
      const bodyData_array = posted_elements.x ?  await tx.any(query5, params5) : [];
    
      const postedData = {accounts_data_array, location_accounts_array, account_type_array, headerData_array, bodyData_array};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash_transaction_AccountsData1", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage,});
  }
});

app.post("/api/production_forms_add", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "production_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 30;

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([ 
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.vale), 
      posted_elements.account_no,
      posted_elements.form_name,
      posted_elements.amount,
      posted_elements.item_account,
      posted_elements.location_account,
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------
    const query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND account_type_id in (1,5,7) AND is_final_account IS TRUE`;
    let rows02 = await db.any(query02, [req.session.company_id]);

    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id
    }));

    const item_account = dbAccounts.some(item => +item.id === +posted_elements.item_account && +item.account_type_id === 5);
    const location_account = dbAccounts.some(item => +item.id === +posted_elements.location_account && +item.account_type_id === 7);

    if (!item_account || !location_account) {
      await block_user(req, 'Spfa01');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    let rowIndex = 1;
    for (const rowData of posted_elements.posted_array) {
      const account_typeId = rowData.account_typeId;
      const account_id = rowData.account_id;
      const amount = +rowData.amount;

      if (!amount || isNaN(amount) || amount <= 0){
        return res.json({
          success: false,
          message_ar: `Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
        });
      }

      const accountExists = dbAccounts.some(item => +item.id === +account_id && +item.account_type_id === +account_typeId);
      if (!accountExists) {
        await block_user(req, 'Spfa02');
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      rowIndex++;
    }

    // Start Transaction
    await db.tx(async (tx) => {
      // Insert into production_forms_header and get the new id
      const query1 = `INSERT INTO production_forms_header
                      (account_no, form_name, production_item_id, location_from, company_id, value)
                      VALUES($1, $2, $3, $4, $5, $6) RETURNING id;`;
      const insert = await tx.one(query1, [
        posted_elements.account_no,
        posted_elements.form_name.trim(),
        +posted_elements.item_account,
        +posted_elements.location_account,
        req.session.company_id,
        posted_elements.amount
      ]);

      const newId_transaction_header = insert.id; // The new header id

      let insert_array2 = [];
      for (const element of posted_elements.posted_array) {
        insert_array2.push([
          newId_transaction_header, // Use the new header id here
          element.account_id,
          +element.amount
        ]);
      }
      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      const query2 = `INSERT INTO production_forms_body
                      (production_forms_header_id, account_id, value)
                      VALUES ${insert_array2.map((_, i) => 
                        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
                      ).join(', ')}`;
                      await tx.none(query2, insert_array2.flat());
                    }


      // Add history log
      await history(transaction_type, 1, newId_transaction_header, 0, req, tx);
    });

    await last_activity(req);

    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØµÙ†ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­`,
    });

  } catch (error) {
    await last_activity(req);
    console.error("Error production_forms_add:", error);

    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/production_forms_update", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "production_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 30;

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([ 
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.vale), 
      posted_elements.x,
      posted_elements.account_no,
      posted_elements.form_name,
      posted_elements.amount,
      posted_elements.item_account,
      posted_elements.location_account,
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------
    const query001 = `select id from production_forms_header where id = $1 and company_id = $2`
    let result001 = await db.oneOrNone(query001, [posted_elements.x, req.session.company_id])

    

    if (!result001){
      await block_user(req, 'Spfu01');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    

    const query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND account_type_id in (1,5,7) AND is_final_account IS TRUE`;
    let rows02 = await db.any(query02, [req.session.company_id]);

    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id
    }));

    const item_account = dbAccounts.some(item => +item.id === +posted_elements.item_account && +item.account_type_id === 5);
    const location_account = dbAccounts.some(item => +item.id === +posted_elements.location_account && +item.account_type_id === 7);

    if (!item_account || !location_account) {
      await block_user(req, 'Spfu02');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    let rowIndex = 1;
    for (const rowData of posted_elements.posted_array) {
      const account_typeId = rowData.account_typeId;
      const account_id = rowData.account_id;
      const amount = +rowData.amount;

      if (!amount || isNaN(amount) || amount <= 0){
        return res.json({
          success: false,
          message_ar: `Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
        });
      }

      const accountExists = dbAccounts.some(item => +item.id === +account_id && +item.account_type_id === +account_typeId);
      if (!accountExists) {
        await block_user(req, 'Spfu03');
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }

      rowIndex++;
    }

    // Start Transaction
    await db.tx(async (tx) => {
      // Insert into production_forms_header and get the new id
      let query0 = `DELETE FROM production_forms_body where production_forms_header_id = $1`
      await tx.none(query0, [posted_elements.x])

      const query1 = `update production_forms_header
                      set account_no = $1, form_name = $2, production_item_id = $3, location_from = $4, value = $5
                      where id = $6 and company_id = $7;`;
      await tx.none(query1, [
        posted_elements.account_no,
        posted_elements.form_name.trim(),
        +posted_elements.item_account,
        +posted_elements.location_account,
        posted_elements.amount,
        posted_elements.x,
        req.session.company_id,
      ]);

      let insert_array2 = [];
      for (const element of posted_elements.posted_array) {
        insert_array2.push([
          posted_elements.x, // Use the new header id here
          element.account_id,
          +element.amount
        ]);
      }
      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      const query2 = `INSERT INTO production_forms_body
                      (production_forms_header_id, account_id, value)
                      VALUES ${insert_array2.map((_, i) => 
                        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
                      ).join(', ')}`;

                      await tx.none(query2, insert_array2.flat());
                    }

      // Add history log
      await history(transaction_type, 2, posted_elements.x, 0, req, tx);
    });

    await last_activity(req);

    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØµÙ†ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­`,
    });

  } catch (error) {
    await last_activity(req);
    console.error("Error production_forms_update:", error);

    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/production_forms_delete", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "production_permission", "delete");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 30;

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }

    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------
    const query001 = `select id from production_forms_header where id = $1 and company_id = $2`
    let result001 = await db.oneOrNone(query001, [posted_elements.x, req.session.company_id])

    

    if (!result001){
      await block_user(req, 'Spfu01');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    


    // Start Transaction
    await db.tx(async (tx) => {
      // Insert into production_forms_header and get the new id
      let query0 = `DELETE FROM production_forms_header where id = $1 and company_id = $2`
      await tx.none(query0, [posted_elements.x, req.session.company_id])

      // Add history log
      await history(transaction_type, 3, posted_elements.x, 0, req, tx);
    });

    await last_activity(req);

    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØµÙ†ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­`,
    });

  } catch (error) {
    await last_activity(req);
    console.error("Error production_forms_delete:", error);

    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/production_order_view", async (req, res) => {
  try {
    
    //! Permission  
    await permissions(req, "production_permission", "view");
    if (!permissions) {
      return;
    }
      

    const posted_elements = req.body;
    const transaction_type = 31
        // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
      
          const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
          if (InValidDateFormat){
            return res.json({
              success: false,
              message_ar: InValidDateFormat_message_ar,
            });
          }
        


      turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    let query1 = `
SELECT
    th.id,
    th.datex,
    CONCAT(
        tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
    th.total_value as amount,
    COALESCE(th.general_note, '') AS general_note,
    th.account_id,
    ah.account_name,
    COALESCE(tb.cogs, 0) AS value -- Ø¬Ù„Ø¨ cogs Ø¥Ø°Ø§ ÙƒØ§Ù†Øª is_production_item NULL
FROM
    transaction_header th
LEFT JOIN accounts_header ah ON ah.id = th.account_id	
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
LEFT JOIN transaction_body tb 
    ON tb.transaction_header_id = th.id 
    AND tb.is_production_item IS TRUE  -- Ø´Ø±Ø· is_production_item ÙŠÙƒÙˆÙ† NULL
WHERE
    th.company_id = $1
    AND th.transaction_type = 31
    AND th.is_deleted IS NULL
    AND th.datex BETWEEN $2 AND $3
	ORDER by
    th.datex desc,
	  th.id desc    
    ;
`;


    let data = await db.any(query1, [req.session.company_id,posted_elements.start_date, posted_elements.end_date]);
          
    res.json(data);
  } catch (error) {
    console.error("Error production_order_view:", error);
    res.status(500).send("Error:");
  }
});

app.post("/production_orders_AccountsData1", async (req, res) => {
  try {


    //! Permission
    await permissions(req, "production_permission", "view");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      // const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
      // if (InValidDateFormat){
      //   return res.json({
      //     success: false,
      //     message_ar: InValidDateFormat_message_ar,
      //   });
      // }
    


  turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------

      let query1 = `
SELECT
  A.id,
  A.account_name,
  A.account_type_id,
  A.item_unite
FROM
  accounts_header A
WHERE
  A.company_id = $1
  AND is_final_account = true
  and a.is_inactive is null
  and a.account_type_id in (1, 5)
  AND (a.global_id NOT IN (8, 17, 18, 19) OR a.global_id IS NULL)
;
`;
let params1 = [req.session.company_id]

    let query2 = `
       --  Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
select 
	ah.id,
	ah.account_name
from
	accounts_header ah
where
	ah.company_id = $1
	and ah.account_type_id = 7
  and ah.is_inactive is null
    ;
    `;
    let params2 = [req.session.company_id] ;


    let query3 = `select id, account_type_name
    from account_type
    where id IN (1, 5)
    order by id DESC ;`;  // in (1,2 ) ya3ny = 1 or 2 

    let query4 = `select
	pfh.id,
	pfh.form_name as account_name
from
	production_forms_header pfh
where 
	pfh.company_id = $1;`

    let params4 = [req.session.company_id]


    let query5 = `select
	th.id,
	th.datex,
	CONCAT(
    	tt.doc_prefix, '-',
        SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        LPAD(CAST(th.reference AS TEXT), 5, '0') -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    ) AS referenceconcat,
	coalesce(th.general_note , '') as general_note,
  COALESCE(th.total_value , 0) as value,
	th.account_id as production_item_id,
  ah.account_name account_name,
  ah.item_unite,
	th.items_location_id as location_from,
  ah2.account_name as location_name
from
	transaction_header th
LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
left join accounts_header ah on ah.id = th.account_id
left join accounts_header ah2 on ah2.id = th.items_location_id
where
	th.id = $1
	and th.company_id = $2
  and th.transaction_type = 31
  ;`

    let params5 = [posted_elements.x, req.session.company_id]


let query6 = `select
	tb.id,
	case
		when ah.account_type_id = 1 then 1
		else 5
	end as account_type_id,
	case
		when ah.account_type_id = 1 then tb.credit
		else ABS(tb.item_amount)
	end as value,
	case
		when ah.account_type_id = 1 then 'Ø§Ù„Ù…Ø¨Ù„Øº'
		else ah2.item_unite
	end as item_unite,
	case
		when ah.account_type_id = 1 then tb.account_id
		else tb.item_id 
	end as account_id,
	case
		when ah.account_type_id = 1 then ah.account_name
		else ah2.account_name
	end as account_name,	
	case
		when ah.account_type_id = 1 then (coalesce(tb.credit,0) - coalesce(tb.debit,0))
		else coalesce(tb.cogs,0)
	end as production_value
from
	transaction_body tb
inner join transaction_header th on th.id = tb.transaction_header_id
left join accounts_header ah on ah.id = tb.account_id 
left join accounts_header ah2 on ah2.id = tb.item_id
where
	th.id = $1
	and th.transaction_type = 31
	and th.company_id = $2
	and th.is_deleted is null
  and tb.is_production_item is null
  ;
	`
  let params6 = [posted_elements.x, req.session.company_id]  

    await db.tx(async (tx) => {

      const accounts_data_array = await tx.any(query1, params1);
      const location_accounts_array = await tx.any(query2, params2);
      const account_type_array = await tx.any(query3);
      const forms_array = await tx.any(query4, params4) || [];
      const headerData_array = posted_elements.x ?  await tx.oneOrNone(query5, params5) : false;
      const bodyData_array = posted_elements.x ?  await tx.any(query6, params6) : [];
    
      const postedData = {accounts_data_array, location_accounts_array, account_type_array, forms_array, headerData_array, bodyData_array};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash_transaction_AccountsData1", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: error.message || deafultErrorMessage, });
  }
});

app.post("/calculate_production_order_data", async (req, res) => {
  try {


    //! Permission
    await permissions(req, "production_permission", "add");
    if (!permissions) {
      return;
    }

    const posted_elements = req.body;

    // Ø³Ø±Ø¯ ÙƒÙ„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ø±Ù‡ ÙˆØ§Ø­Ø¯Ù‡ 
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }
  
      // const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date])
      // if (InValidDateFormat){
      //   return res.json({
      //     success: false,
      //     message_ar: InValidDateFormat_message_ar,
      //   });
      // }
    


  turn_EmptyValues_TO_null(posted_elements);
    //* Start--------------------------------------------------------------


    //!check
    let query0 = `select id from production_forms_header where id = $1 and company_id = $2`
    let result = await db.oneOrNone(query0, [posted_elements.x, req.session.company_id])
    if (!result){
      await block_user(req, 'SCpod01');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }


      let query1 = `
with
header_data as(
select
	pfh.id,
	pfh.form_name,
	pfh.production_item_id,
	pfh.value
from
	production_forms_header pfh
where
	pfh.id = $1
	and pfh.company_id = $2
),
body_data as(
select 
	pfb.id,
	pfb.production_forms_header_id,
	pfb.account_id,
	ah.account_type_id,
	ah.account_name,
	coalesce(ah.item_unite, 'Ø§Ù„Ù…Ø¨Ù„Øº') as item_unite,
	pfb.value
from
	production_forms_body pfb
left join production_forms_header pfh on pfh.id = pfb.production_forms_header_id
left join accounts_header ah on ah.id = pfb.account_id
where 
	pfh.id = $1
	and pfh.company_id = $2
)
select
	bd.id,
	bd.account_id,
	bd.account_type_id,
	bd.account_name,
	bd.item_unite,
	ROUND((COALESCE($3, 0) * COALESCE(bd.value, 0)) / NULLIF(COALESCE(hd.value, 0), 0), 2) as value
from
	body_data bd
left join header_data hd on hd.id = bd.production_forms_header_id
;
`;
let params1 = [posted_elements.x, req.session.company_id, parseFloat(posted_elements.xamount_input)];


    let query2 = `
select
	pfh.id,
	pfh.form_name,
	pfh.production_item_id,
	ah.account_name,
	ah.item_unite,
	pfh.location_from,
	ah2.account_name as location_name,
	$3 as value
from
	production_forms_header pfh
left join accounts_header ah on ah.id = pfh.production_item_id
left join accounts_header ah2 on ah2.id = pfh.location_from
where
	pfh.id = $1
	and pfh.company_id = $2
    ;
    `;
    let params2 = [posted_elements.x, req.session.company_id, posted_elements.xamount_input] ;

    await db.tx(async (tx) => {

      const bodyData_array = await tx.any(query1, params1);
      const calc_header = await tx.oneOrNone(query2, params2);
      
      const postedData = {bodyData_array, calc_header};
      res.json(postedData);
    })
    await last_activity(req)
  } catch (error) {
    await last_activity(req)
    console.error("Error while getCash_transaction_AccountsData1", error);
    res.join;
    res
      .status(500)
      .json({ success: false, message_ar: "âŒ Error getCash_transaction_AccountsData1" });
  }
});

app.post("/api/production_orders_add", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "production_permission", "add");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 31;
    let items_array = []
    let locations_array = []
    let total = 0

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([ 
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.vale), 
      posted_elements.datex,
      posted_elements.account_no,
      posted_elements.form_name,
      posted_elements.amount,
      posted_elements.item_account,
      posted_elements.location_account,
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'add',
      tableName: false, // if type = 'update' or 'delete' only
      transaction_id: false, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }
    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------

    const query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND account_type_id in (1,5,7) AND is_final_account IS TRUE`;
    let rows02 = await db.any(query02, [req.session.company_id]);

    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id
    }));

    const item_account = dbAccounts.some(item => +item.id === +posted_elements.item_account && +item.account_type_id === 5);
    const location_account = dbAccounts.some(item => +item.id === +posted_elements.location_account && +item.account_type_id === 7);

    if (!item_account || !location_account) {
      await block_user(req, 'Spoa01');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    let rowIndex = 1;
    for (const rowData of posted_elements.posted_array) {
      const account_typeId = rowData.account_typeId;
      const account_id = rowData.account_id;
      const amount = +rowData.amount;

      if (!amount || isNaN(amount) || amount <= 0){
        return res.json({
          success: false,
          message_ar: `Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
        });
      }

      const accountExists = dbAccounts.some(item => +item.id === +account_id && +item.account_type_id === +account_typeId);
      if (!accountExists) {
        await block_user(req, 'Spfo02');
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
        
      total += amount || 0
      if (+account_typeId === 5){
        items_array.push(+rowData.account_id)
      }
      rowIndex++;
    }

    locations_array.push(+posted_elements.location_account)
    
    const year = getYear(posted_elements.datex);
    const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header', transaction_type, year, req);
    const new_referenceFormatting = formatFromFiveDigits(newReference_transaction_header);
    const newId_general_reference = await newId_fn("transaction_header", 'general_reference');

    // Start Transaction
    await db.tx(async (tx) => {

      // Insert into production_forms_header and get the new id
      const query1 = `INSERT INTO transaction_header
                      (datex, reference, general_reference, transaction_type, general_note, account_id, items_location_id, company_id, total_value, is_including_items)
                      VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id;`;
      const insert = await tx.one(query1, [
        posted_elements.datex,
        newReference_transaction_header,
        newId_general_reference,
        transaction_type,
        posted_elements.form_name,
        +posted_elements.item_account,
        +posted_elements.location_account,
        req.session.company_id,
        posted_elements.amount,
        true
      ]);

      const newId_transaction_header = insert.id; // The new header id


      let insert_array2 = [];
      for (const element of posted_elements.posted_array) {
        insert_array2.push([
          newId_transaction_header, // Use the new header id here
          null,
          +element.account_typeId === 1? element.amount : null,
          +element.account_typeId === 5? element.amount * -1 : null,
          +element.account_typeId === 1? element.account_id : null,
          +element.account_typeId === 5? element.account_id : null,
          +element.account_typeId === 5? posted_elements.location_account : null,
          null // is_production_item
        ]);
      }
       
      
      insert_array2.push([
        newId_transaction_header,
        parseFloat(total.toFixed(2)), // Use the new header id here
        null,
        posted_elements.amount,
        null,
        posted_elements.item_account,
        posted_elements.location_account,
        true // is_production_item
      ]);

      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      const query2 = `INSERT INTO transaction_body
      (transaction_header_id, debit, credit, item_amount, account_id, item_id, item_location_id_tb, is_production_item)
      VALUES ${insert_array2.map((_, i) => 
        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
      ).join(', ')}`;
      await tx.none(query2, insert_array2.flat());
    }


      const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
      if (!allow_amounts){
        throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
      } else if (allow_amounts !== true) {
        throw new Error(allow_amounts);
      }
        
      await update_items_cogs(items_array,posted_elements.datex, req, tx)
      // Add history log
      await history(transaction_type, 1, newId_transaction_header, 0, req, tx);
    });

    await last_activity(req);

    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù…Ø± Ø§Ù„ØªØµÙ†ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });

  } catch (error) {
    await last_activity(req);
    console.error("Error production_orders_add:", error);

    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});

app.post("/api/production_orders_update", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "production_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 31;
    let items_array = []
    let locations_array = []
    let total = 0

    //! sql injection check
    let hasBadSymbols = sql_anti_injection([ 
      ...posted_elements.posted_array.map((obj) => obj.account_typeId + obj.account_id + obj.note_row + obj.vale), 
      posted_elements.datex,
      posted_elements.form_name,
      posted_elements.amount,
      posted_elements.item_account,
      posted_elements.location_account,
    ]);
    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar: sql_injection_message_ar,
        message_en: sql_injection_message_en,
      });
    }

    const InValidDateFormat = isInValidDateFormat([posted_elements.datex]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'update',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }
    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------
    let quer001 = `select id, reference from transaction_header where id = $1 and company_id = $2 and transaction_type = $3`
    let rows01 = await db.oneOrNone(quer001, [posted_elements.x, req.session.company_id, transaction_type])
    if (!rows01 || !rows01.id) {
      await block_user(req,'Spou01')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    const reference = rows01.reference


    const query02 = `SELECT id, account_type_id FROM accounts_header WHERE company_id = $1 AND account_type_id in (1,5,7) AND is_final_account IS TRUE`;
    let rows02 = await db.any(query02, [req.session.company_id]);

    const dbAccounts = rows02.map(row => ({
      id: parseInt(row.id),
      account_type_id: row.account_type_id
    }));

    const item_account = dbAccounts.some(item => +item.id === +posted_elements.item_account && +item.account_type_id === 5);
    const location_account = dbAccounts.some(item => +item.id === +posted_elements.location_account && +item.account_type_id === 7);

    if (!item_account || !location_account) {
      await block_user(req, 'Spou01');
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }

    let rowIndex = 1;
    for (const rowData of posted_elements.posted_array) {
      const account_typeId = rowData.account_typeId;
      const account_id = rowData.account_id;
      const amount = +rowData.amount;

      if (!amount || isNaN(amount) || amount <= 0){
        return res.json({
          success: false,
          message_ar: `Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙÙ‰ Ø§Ù„Ø³Ø·Ø± Ø±Ù‚Ù… ${rowIndex}`,
        });
      }

      const accountExists = dbAccounts.some(item => +item.id === +account_id && +item.account_type_id === +account_typeId);
      if (!accountExists) {
        await block_user(req, 'Spfo02');
        return res.json({
          success: false,
          xx: true,
          message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
        });
      }
      
      
      total += amount || 0
      if (+account_typeId === 5){
        items_array.push(+rowData.account_id)
      }
      rowIndex++;
    }

    locations_array.push(+posted_elements.location_account)
    const year = getYear(posted_elements.datex);
    // const newReference_transaction_header = await newReference_transaction_header_fn('transaction_header', transaction_type, year, req);
    const new_referenceFormatting = formatFromFiveDigits(reference);
    // const newId_general_reference = await newId_fn("transaction_header", 'general_reference');

    // Start Transaction
    await db.tx(async (tx) => {
  

      let query00 = `delete from transaction_body where transaction_header_id = $1`
      await tx.none(query00, [posted_elements.x])

      const query1 = `UPDATE transaction_header
                      set datex = $1, general_note = $2, account_id = $3, items_location_id = $4, total_value = $5
                      where id = $6`;
      await tx.none(query1, [
        posted_elements.datex,
        posted_elements.form_name,
        +posted_elements.item_account,
        +posted_elements.location_account,
        posted_elements.amount,
        posted_elements.x
      ]);

     


      let insert_array2 = [];
      for (const element of posted_elements.posted_array) {
        insert_array2.push([
          posted_elements.x, // Use the new header id here
          null,
          +element.account_typeId === 1? element.amount : null,
          +element.account_typeId === 5? element.amount * -1 : null,
          +element.account_typeId === 1? element.account_id : null,
          +element.account_typeId === 5? element.account_id : null,
          +element.account_typeId === 5? posted_elements.location_account : null,
          null // is_production_item
        ]);
      }
       
      
      insert_array2.push([
        posted_elements.x,
        parseFloat(total.toFixed(2)), // Use the new header id here
        null,
        posted_elements.amount,
        null,
        posted_elements.item_account,
        posted_elements.location_account,
        true // is_production_item
      ]);

      if (insert_array2.length > 0){
        let columnsCount = insert_array2[0].length;
      const query2 = `INSERT INTO transaction_body
      (transaction_header_id, debit, credit, item_amount, account_id, item_id, item_location_id_tb, is_production_item)
      VALUES ${insert_array2.map((_, i) => 
        `(${Array.from({ length: columnsCount }, (_, j) => `$${i * columnsCount + j + 1}`).join(', ')})`
      ).join(', ')}`;
      await tx.none(query2, insert_array2.flat());
}

const allow_amounts =  await check_itemAmounts_for_all_location(posted_elements.datex, items_array, locations_array, req, tx)
if (!allow_amounts){
  throw new Error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª : Sapod003');
} else if (allow_amounts !== true) {
  throw new Error(allow_amounts);
}
      await update_items_cogs(items_array,posted_elements.datex, req, tx)
      // Add history log

      await history(transaction_type, 2, posted_elements.x, 0, req, tx);
    });

    await last_activity(req);

    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù…Ø± Ø§Ù„ØªØµÙ†ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });

  } catch (error) {
    await last_activity(req);
    console.error("Error production_orders_update:", error);

    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});


app.post("/api/production_orders_delete", async (req, res) => {
  try {

    //! Permission
    await permissions(req, "production_permission", "update");
    if (!permissions) {
      return res.status(403).json({
        success: false,
        message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
      });
    }

    const posted_elements = req.body;
    const transaction_type = 31;
    let items_array = []

    //! sql injection check
    const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));

    if (hasBadSymbols) {
      return res.json({
        success: false,
        message_ar:
          "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
      });
    }


    //! settings
    const settings = await check_settings_validation({
      check_futureDate: true,
      check_closingDate: true,
      datex: posted_elements.datex,
      type: 'delete',
      tableName: 'transaction_header', // if type = 'update' or 'delete' only
      transaction_id: posted_elements.x, // if type = 'update' or 'delete' only
    }, req);

    
    if (!settings.valid) {
      return res.json({
        success: false,
        message_ar: settings.message_ar,
      });
    }
    turn_EmptyValues_TO_null(posted_elements);

    //* Start Transaction --------------------------------------------------
    let quer001 = `select id, reference, datex from transaction_header where id = $1 and company_id = $2 and transaction_type = $3`
    let rows01 = await db.oneOrNone(quer001, [posted_elements.x, req.session.company_id, transaction_type])
    if (!rows01 || !rows01.id) {
      await block_user(req,'Spod01')
      return res.json({
        success: false,
        xx: true,
        message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
      });
    }
    const reference = rows01.reference
    const datex = rows01.datex


    const query02 = `
    SELECT
      tb.item_id
    FROM
      transaction_body tb
    left join transaction_header th on th.id = tb.transaction_header_id  
  WHERE 
        th.id = $1
        and th.company_id = $2
        and tb.item_id is not null
        and tb.is_production_item is null
        ;`;
        items_array = (await db.any(query02, [posted_elements.x, req.session.company_id]) || [])
        .map(row => Number(row.item_id)); // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø¥Ù„Ù‰ Ø£Ø±Ù‚Ø§Ù…


    const year = getYear(datex);
    const new_referenceFormatting = formatFromFiveDigits(reference);

    // Start Transaction
    await db.tx(async (tx) => {
  
      let query00 = `delete from transaction_body where transaction_header_id = $1`
      await tx.none(query00, [posted_elements.x])

      const query1 = `UPDATE transaction_header
                      set is_deleted = true
                      where 
                        id = $1
                        and company_id = $2
                        and transaction_type = $3
                      `;
      await tx.none(query1, [
        posted_elements.x,
        req.session.company_id,
        transaction_type
      ]);


      
      await update_items_cogs(items_array,datex, req, tx)
      // Add history log

      await history(transaction_type, 3, posted_elements.x, 0, req, tx);
    });

    await last_activity(req);

    return res.json({
      success: true,
      message_ar: `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù…Ø± Ø§Ù„ØªØµÙ†ÙŠØ¹ Ø¨Ù…Ø±Ø¬Ø¹ : ${new_referenceFormatting}-${year}`,
    });

  } catch (error) {
    await last_activity(req);
    console.error("Error production_orders_update:", error);

    return res.json({
      success: false,
      message_ar: error.message || deafultErrorMessage,
    });
  }
});
//#endregion




//#region reports
  //#region statememnts
    //#region trial_balance
    app.post("/reports_trialBalance_view", async (req, res) => {
      try {

    //! Permission Ù…Ø¹Ù„Ù‚
    // await permissions(req, "purshases_returns_permission", "delete");
    // if (!permissions) {
    //   return res.status(403).json({
    //     success: false,
    //     message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
    //   });
    // }

    const posted_elements = req.body;
    // const transaction_type = 7
  

      //! sql injection check
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


    const InValidDateFormat = isInValidDateFormat([posted_elements.start_date,posted_elements.end_date]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    //50000


/*
let query1 = `
WITH 
stock_balances as(

SELECT
    -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø¯ÙˆÙ† Ø´Ø±Ø· transaction_type
    SUM(CASE 
	    	WHEN ah.account_type_id = 5 AND th2.datex < $2 then
	    		case
	    			when tb2.item_amount >= 0 then coalesce(tb2.cogs,0)
        			when tb2.item_amount <0 then coalesce(tb2.cogs *-1, 0)
        			else 0
	    		end
        ELSE 0 
        END) AS stock_debit_begining,

    -- Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙƒÙ„ÙØ© Ù…Ø¹ Ø´Ø±Ø· transaction_type

    -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø¯ÙˆÙ† Ø´Ø±Ø· transaction_type
    SUM(CASE 
        	WHEN ah.account_type_id = 5 AND th2.datex BETWEEN $2 AND $3 then
        		case
        			when tb2.item_amount >= 0 then coalesce(tb2.cogs,0)
        			when tb2.item_amount <0 then coalesce(tb2.cogs *-1, 0)
        			else 0
        		end
        	ELSE 0
        END) AS stock_debit_current,

    -- Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙƒÙ„ÙØ© Ù…Ø¹ Ø´Ø±Ø· transaction_type
        
    SUM(CASE 
        	WHEN th2.transaction_type = 2 AND ah2.global_id = 17 AND th2.datex < $2 then
        		case
	        		when coalesce(tb2.debit, 0) > 0 then coalesce(tb2.debit, 0)
	        		when coalesce(tb2.credit, 0) > 0 then coalesce(tb2.credit, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_account_value_begining,
        
            SUM(CASE 
        	WHEN th2.transaction_type IN (3,4) AND ah.account_type_id = 5 AND tb2.item_id is not null AND th2.datex < $2 then
        		case
	    			when  tb2.item_amount > 0 then coalesce(tb2.cogs *-1, 0)
        			when  tb2.item_amount <0 then coalesce(tb2.cogs, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_items_value_begining,
        
        
                    SUM(CASE 
        	WHEN th2.transaction_type = 2 and  ah2.global_id = 17 AND th2.datex BETWEEN $2 AND $3 then
        		case
	        		when coalesce(tb2.debit, 0) > 0 then coalesce(tb2.debit, 0)
	        		when coalesce(tb2.credit, 0) > 0 then coalesce(tb2.credit, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_account_value_current,
        
        
            SUM(CASE 
        	WHEN th2.transaction_type IN (3,4) AND ah.account_type_id = 5 and tb2.item_id is not null AND th2.datex BETWEEN $2 AND $3 then
        		case
	    			when th2.transaction_type IN (3,4) AND ah.account_type_id = 5 AND tb2.item_amount > 0 then coalesce(tb2.cogs *-1,0)
        			when th2.transaction_type IN (3,4) AND ah.account_type_id = 5 AND tb2.item_amount <0 then coalesce(tb2.cogs, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_items_value_current

FROM transaction_body tb2
left JOIN accounts_header ah ON ah.id = tb2.item_id
left join accounts_header ah2 on ah2.id = tb2.account_id
LEFT JOIN transaction_header th2 ON th2.id = tb2.transaction_header_id
WHERE th2.company_id = $1 
AND th2.is_deleted IS null
AND (tb2.item_id is not null or ah2.global_id = 17)
),
previous_profit_query as(
select
	sum(tb2.credit) - sum(tb2.debit) as previous_profit_value
from transaction_body tb2
INNER JOIN accounts_header ah ON ah.id = tb2.account_id
LEFT JOIN transaction_header th2 ON th2.id = tb2.transaction_header_id
where
	ah.company_id = $1 
	AND th2.is_deleted IS null
	and (ah.main_account_id in (4,5) or ah.global_id in (23,16))  -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø±Ø¨Ø§Ø­ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ùˆ Ø§Ù„Ø§Ø±Ø¨Ø§Ø­ Ø§Ù„Ø³Ø§Ø¨Ù‚Ù‡
	AND th2.datex < $2
),
main_trial_balance AS (
    SELECT
        ah.id,
        ah.account_name,
        CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_begining, 0) > 0 then coalesce(sb.stock_debit_begining, 0)
            		else 0
            	end
            WHEN ah.global_id = 23 then -- Ø§Ø±Ø¨Ø§Ø­ ÙØªØ±Ø§Øª Ø³Ø§Ø¨Ù‚Ø©
            	case
             		when ppq.previous_profit_value < 0 then ABS(ppq.previous_profit_value)
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when coalesce(sb.cost_account_value_begining, 0) > 0 then coalesce(sb.cost_account_value_begining, 0)
            		else 0
            	end	
            WHEN ah.main_account_id in (4,5) then 0  -- Ù„Ø§ ÙŠØ¬Ù…Ø¹ Ø¨Ù†ÙˆØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„ Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ù‡            	
            ELSE 
                SUM(CASE WHEN tb.debit IS NOT NULL AND th.datex < $2 THEN tb.debit ELSE 0 END)
        END AS debit_first,
                CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_begining, 0) < 0 then ABS(sb.stock_debit_begining)
            		else 0
            	end
            WHEN ah.global_id = 23 then -- Ø§Ø±Ø¨Ø§Ø­ ÙØªØ±Ø§Øª Ø³Ø§Ø¨Ù‚Ø©
            	case
            		when ppq.previous_profit_value > 0 then ppq.previous_profit_value
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when coalesce(sb.cost_account_value_begining, 0) < 0 then ABS(coalesce(sb.cost_account_value_begining, 0))
            		else 0
            	end	
            	 WHEN ah.main_account_id in (4,5) then 0  -- Ù„Ø§ ÙŠØ¬Ù…Ø¹ Ø¨Ù†ÙˆØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„ Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ù‡   
            ELSE 
                SUM(CASE WHEN tb.credit IS NOT NULL AND th.datex < $2 THEN tb.credit ELSE 0 END)
        END AS credit_first,
        CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_current, 0) > 0 then coalesce(sb.stock_debit_current, 0)
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when (coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)) > 0 then coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)
            		else 0
            	end
            ELSE 
                SUM(CASE WHEN tb.debit IS NOT NULL AND th.datex BETWEEN $2 AND $3 THEN tb.debit ELSE 0 END)
        END AS debit_current,
        CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_current, 0) < 0 then ABS(sb.stock_debit_current)
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when  (coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)) < 0 then ABS((coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)))
            		else 0
            	end
            ELSE 
                SUM(CASE WHEN tb.credit IS NOT NULL AND th.datex BETWEEN $2 AND $3 THEN tb.credit ELSE 0 END)
        END AS credit_current,        
        ah.is_final_account,
        ah.account_no,
        ah.finance_statement,
        ah.cashflow_statement,
        ah.account_type_id,
        ah.account_name_en,
        ah.global_id,
        ah.main_account_id,
        ah.is_inactive,
        ab.parent_id
    FROM
        accounts_header ah
    LEFT JOIN accounts_body ab ON ab.account_id = ah.id
    LEFT JOIN transaction_body tb ON tb.account_id = ah.id
    LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
    LEFT JOIN stock_balances sb ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
    LEFT JOIN previous_profit_query ppq ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ§Ø­Ø¯
    WHERE
        ah.company_id = $1
        AND (ah.account_type_id NOT IN (7, 8, 11) or ah.account_type_id is null)
       -- AND NOT (ah.account_type_id = 5 AND ah.global_id != 12)
        AND ((ah.account_type_id != 5 or ah.account_type_id is null) or ah.global_id = 12)
    GROUP BY
        ah.id, ab.parent_id, sb.stock_debit_begining, sb.cost_items_value_begining, ppq.previous_profit_value, sb.stock_debit_current, sb.cost_items_value_current, sb.cost_account_value_begining, sb.cost_account_value_current
)
select
    mt.id,
    mt.account_name,
          CASE
        WHEN (mt.debit_first + mt.debit_current) > (mt.credit_first + mt.credit_current)
        THEN (mt.debit_first + mt.debit_current) - (mt.credit_first + mt.credit_current)
        ELSE NULL
    END AS debit_end,
        CASE
        WHEN (mt.debit_first + mt.debit_current) < (mt.credit_first + mt.credit_current)
        THEN (mt.credit_first + mt.credit_current) - (mt.debit_first + mt.debit_current)
        ELSE NULL
    END AS credit_end,
   mt.debit_first,
    mt.debit_current,
    mt.credit_first,
    mt.credit_current,
    mt.is_final_account,
    mt.account_no,
    mt.finance_statement,
    mt.cashflow_statement,
    mt.account_type_id,
    mt.account_name_en,
    mt.global_id,
    mt.main_account_id,
    mt.is_inactive,
    mt.parent_id,
    null as padding
from 
	main_trial_balance mt
  order by
        mt.main_account_id asc, mt.parent_id asc, mt.id asc
        ;
        `;
*/



let query1 = `
WITH 
stock_balances as(
SELECT
    -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø¯ÙˆÙ† Ø´Ø±Ø· transaction_type
    SUM(CASE 
	    	WHEN ah.account_type_id = 5 AND th2.datex < $2 then
	    		case
	    			when tb2.item_amount >= 0 then coalesce(tb2.cogs,0)
        			when tb2.item_amount <0 then coalesce(tb2.cogs *-1, 0)
        			else 0
	    		end
        ELSE 0 
        END) AS stock_debit_begining,

    -- Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙƒÙ„ÙØ© Ù…Ø¹ Ø´Ø±Ø· transaction_type

    -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø¯ÙˆÙ† Ø´Ø±Ø· transaction_type
    SUM(CASE 
        	WHEN ah.account_type_id = 5 AND th2.datex BETWEEN $2 AND $3 then
        		case
        			when tb2.item_amount >= 0 then coalesce(tb2.cogs,0)
        			when tb2.item_amount <0 then coalesce(tb2.cogs *-1, 0)
        			else 0
        		end
        	ELSE 0
        END) AS stock_debit_current,

    -- Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙƒÙ„ÙØ© Ù…Ø¹ Ø´Ø±Ø· transaction_type
        
    SUM(CASE 
        	WHEN th2.transaction_type = 2 AND ah2.global_id = 17 AND th2.datex < $2 then
        		case
	        		when coalesce(tb2.debit, 0) > 0 then coalesce(tb2.debit, 0)
	        		when coalesce(tb2.credit, 0) > 0 then coalesce(tb2.credit, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_account_value_begining,
        
            SUM(CASE 
        	WHEN th2.transaction_type IN (3,4) AND ah.account_type_id = 5 AND tb2.item_id is not null AND th2.datex < $2 then
        		case
	    			when  tb2.item_amount > 0 then coalesce(tb2.cogs *-1, 0)
        			when  tb2.item_amount <0 then coalesce(tb2.cogs, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_items_value_begining,
        
        
                    SUM(CASE 
        	WHEN th2.transaction_type = 2 and  ah2.global_id = 17 AND th2.datex BETWEEN $2 AND $3 then
        		case
	        		when coalesce(tb2.debit, 0) > 0 then coalesce(tb2.debit, 0)
	        		when coalesce(tb2.credit, 0) > 0 then coalesce(tb2.credit, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_account_value_current,
        
        
            SUM(CASE 
        	WHEN th2.transaction_type IN (3,4) AND ah.account_type_id = 5 and tb2.item_id is not null AND th2.datex BETWEEN $2 AND $3 then
        		case
	    			when th2.transaction_type IN (3,4) AND ah.account_type_id = 5 AND tb2.item_amount > 0 then coalesce(tb2.cogs *-1,0)
        			when th2.transaction_type IN (3,4) AND ah.account_type_id = 5 AND tb2.item_amount <0 then coalesce(tb2.cogs, 0)
        			else 0
	    		end
        	ELSE 0
        END) AS cost_items_value_current

FROM transaction_body tb2
left JOIN accounts_header ah ON ah.id = tb2.item_id
left join accounts_header ah2 on ah2.id = tb2.account_id
LEFT JOIN transaction_header th2 ON th2.id = tb2.transaction_header_id
WHERE th2.company_id = $1 
AND th2.is_deleted IS null
AND (tb2.item_id is not null or ah2.global_id = 17)
),

fixed_assests_balances as (
SELECT
    SUM(CASE 
            WHEN ah.account_type_id = 6 AND is_accumulated_depreciation IS NULL AND th.datex < $2 THEN COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
            ELSE 0 
        END
    ) AS begening_fixed_assests_cost,

        SUM(CASE 
            WHEN ah.account_type_id = 6 AND is_accumulated_depreciation IS NULL AND th.datex BETWEEN $2 AND $3 THEN COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
            ELSE 0 
        END
    ) AS current_fixed_assests_cost,
    
    SUM(CASE 
            WHEN ah.account_type_id = 6 AND is_accumulated_depreciation IS true AND th.datex < $2 THEN  COALESCE(tb.credit, 0)  - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS begening_fixed_assests_accumulated_depreciation,

        SUM(CASE 
            WHEN ah.account_type_id = 6 AND is_accumulated_depreciation IS true AND th.datex BETWEEN $2 AND $3 THEN  COALESCE(tb.credit, 0)  - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS current_fixed_assests_accumulated_depreciation

FROM transaction_body tb
INNER JOIN accounts_header ah ON ah.id = tb.account_id
LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE ah.company_id = $1
  and ah.is_final_account is true
  AND th.is_deleted IS NULL
),

previous_profit_query as(
select
	sum(tb2.credit) - sum(tb2.debit) as previous_profit_value
from transaction_body tb2
INNER JOIN accounts_header ah ON ah.id = tb2.account_id
LEFT JOIN transaction_header th2 ON th2.id = tb2.transaction_header_id
where
	ah.company_id = $1 
	AND th2.is_deleted IS null
	and (ah.main_account_id in (4,5) or ah.global_id in (23,16))  -- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø±Ø¨Ø§Ø­ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ùˆ Ø§Ù„Ø§Ø±Ø¨Ø§Ø­ Ø§Ù„Ø³Ø§Ø¨Ù‚Ù‡
	AND th2.datex < $2
),
main_trial_balance AS (
    SELECT
        ah.id,
        ah.account_name,
        CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_begining, 0) > 0 then coalesce(sb.stock_debit_begining, 0)
            		else 0
            	end
            WHEN ah.global_id = 23 then -- Ø§Ø±Ø¨Ø§Ø­ ÙØªØ±Ø§Øª Ø³Ø§Ø¨Ù‚Ø©
            	case
             		when ppq.previous_profit_value < 0 then ABS(ppq.previous_profit_value)
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when coalesce(sb.cost_account_value_begining, 0) > 0 then coalesce(sb.cost_account_value_begining, 0)
            		else 0
            	end	
            WHEN ah.global_id = 9 THEN -- Ø§Ù„Ø§ØµÙˆÙ„
            	case
            		when coalesce(fx.begening_fixed_assests_cost, 0) > 0 then coalesce(fx.begening_fixed_assests_cost, 0)
            		else 0
            	end
            WHEN ah.global_id = 10 THEN -- Ø§Ù„Ù…Ø¬Ù…Ø¹    
            	case
            		when coalesce(fx.begening_fixed_assests_accumulated_depreciation, 0) < 0 then ABS(fx.begening_fixed_assests_accumulated_depreciation)
            		else 0
            	end	            	
            WHEN ah.main_account_id in (4,5) then 0  -- Ù„Ø§ ÙŠØ¬Ù…Ø¹ Ø¨Ù†ÙˆØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„ Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ù‡            	
            ELSE 
                SUM(CASE WHEN tb.debit IS NOT NULL AND th.datex < $2 THEN tb.debit ELSE 0 END)
        END AS debit_first,
                CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_begining, 0) < 0 then ABS(sb.stock_debit_begining)
            		else 0
            	end
            WHEN ah.global_id = 23 then -- Ø§Ø±Ø¨Ø§Ø­ ÙØªØ±Ø§Øª Ø³Ø§Ø¨Ù‚Ø©
            	case
            		when ppq.previous_profit_value > 0 then ppq.previous_profit_value
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when coalesce(sb.cost_account_value_begining, 0) < 0 then ABS(coalesce(sb.cost_account_value_begining, 0))
            		else 0
            	end
            WHEN ah.global_id = 9 THEN -- Ø§Ù„Ø§ØµÙˆÙ„
            	case
            		when coalesce(fx.begening_fixed_assests_cost, 0) < 0 then ABS(fx.begening_fixed_assests_cost)
            		else 0
            	end
            WHEN ah.global_id = 10 THEN -- Ø§Ù„Ù…Ø¬Ù…Ø¹    
            	case
            		when coalesce(fx.begening_fixed_assests_accumulated_depreciation, 0) > 0 then fx.begening_fixed_assests_accumulated_depreciation
            		else 0
            	end	             	
            	 WHEN ah.main_account_id in (4,5) then 0  -- Ù„Ø§ ÙŠØ¬Ù…Ø¹ Ø¨Ù†ÙˆØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„ Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ù‡   
            ELSE 
                SUM(CASE WHEN tb.credit IS NOT NULL AND th.datex < $2 THEN tb.credit ELSE 0 END)
        END AS credit_first,
        CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_current, 0) > 0 then coalesce(sb.stock_debit_current, 0)
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when (coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)) > 0 then coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)
            		else 0
            	end
            WHEN ah.global_id = 9 THEN -- Ø§Ù„Ø§ØµÙˆÙ„
            	case
            		when coalesce(fx.current_fixed_assests_cost, 0) > 0 then fx.current_fixed_assests_cost
            		else 0
            	end
            WHEN ah.global_id = 10 THEN -- Ø§Ù„Ù…Ø¬Ù…Ø¹    
            	case
            		when coalesce(fx.current_fixed_assests_accumulated_depreciation, 0) < 0 then ABS(fx.current_fixed_assests_accumulated_depreciation)
            		else 0
            	end	            	
            ELSE 
                SUM(CASE WHEN tb.debit IS NOT NULL AND th.datex BETWEEN $2 AND $3 THEN tb.debit ELSE 0 END)
        END AS debit_current,
        CASE
            WHEN ah.global_id = 12 THEN -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ Ø§Ù„Ù…Ø¯Ø©
            	case
            		when coalesce(sb.stock_debit_current, 0) < 0 then ABS(sb.stock_debit_current)
            		else 0
            	end
            WHEN ah.global_id = 17 THEN -- ØªÙƒÙ„ÙÙ‡ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ù‡
            	case
            		when  (coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)) < 0 then ABS((coalesce(sb.cost_items_value_current, 0) +  coalesce(sb.cost_account_value_current, 0)))
            		else 0
            	end
            WHEN ah.global_id = 9 THEN -- Ø§Ù„Ø§ØµÙˆÙ„
            	case
            		when coalesce(fx.current_fixed_assests_cost, 0) < 0 then ABS(fx.current_fixed_assests_cost)
            		else 0
            	end
            WHEN ah.global_id = 10 THEN -- Ø§Ù„Ù…Ø¬Ù…Ø¹    
            	case
            		when coalesce(fx.current_fixed_assests_accumulated_depreciation, 0) > 0 then fx.current_fixed_assests_accumulated_depreciation
            		else 0
            	end	             	
            ELSE 
                SUM(CASE WHEN tb.credit IS NOT NULL AND th.datex BETWEEN $2 AND $3 THEN tb.credit ELSE 0 END)
        END AS credit_current,        
        ah.is_final_account,
        ah.account_no,
        ah.finance_statement,
        ah.cashflow_statement,
        ah.account_type_id,
        ah.account_name_en,
        ah.global_id,
        ah.main_account_id,
        ah.is_inactive,
        ab.parent_id
    FROM
        accounts_header ah
    LEFT JOIN accounts_body ab ON ab.account_id = ah.id
    LEFT JOIN transaction_body tb ON tb.account_id = ah.id
    LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
    LEFT JOIN stock_balances sb ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
    LEFT JOIN previous_profit_query ppq ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ§Ø­Ø¯
    LEFT JOIN fixed_assests_balances fx ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ§Ø­Ø¯
    WHERE
        ah.company_id = $1
        AND (ah.account_type_id NOT IN (7, 8, 11) or ah.account_type_id is null)
        --AND ((ah.account_type_id != 5 or ah.account_type_id is null) or ah.global_id = 12)
        --AND ((ah.account_type_id != 6 or ah.account_type_id is null) or ah.global_id in (9 ,10))
        AND ((ah.account_type_id NOT IN (5, 6) OR ah.account_type_id IS NULL) OR ah.global_id IN (9, 10, 12)) -- Ø§Ù„Ù…Ø®Ø²ÙˆÙ† ÙˆØ§Ù„Ø§ØµÙˆÙ„ ÙˆØ§Ù„Ù…Ø¬Ù…Ø¹
    GROUP BY
        ah.id, ab.parent_id, sb.stock_debit_begining, sb.cost_items_value_begining, ppq.previous_profit_value, sb.stock_debit_current, sb.cost_items_value_current, sb.cost_account_value_begining, sb.cost_account_value_current,
        fx.begening_fixed_assests_cost, fx.current_fixed_assests_cost, fx.begening_fixed_assests_accumulated_depreciation, fx.current_fixed_assests_accumulated_depreciation
)
select
    mt.id,
    mt.account_name,
          CASE
        WHEN (mt.debit_first + mt.debit_current) > (mt.credit_first + mt.credit_current)
        THEN (mt.debit_first + mt.debit_current) - (mt.credit_first + mt.credit_current)
        ELSE NULL
    END AS debit_end,
        CASE
        WHEN (mt.debit_first + mt.debit_current) < (mt.credit_first + mt.credit_current)
        THEN (mt.credit_first + mt.credit_current) - (mt.debit_first + mt.debit_current)
        ELSE NULL
    END AS credit_end,
   mt.debit_first,
    mt.debit_current,
    mt.credit_first,
    mt.credit_current,
    mt.is_final_account,
    mt.account_no,
    mt.finance_statement,
    mt.cashflow_statement,
    mt.account_type_id,
    mt.account_name_en,
    mt.global_id,
    mt.main_account_id,
    mt.is_inactive,
    mt.parent_id,
    null as padding
from 
	main_trial_balance mt
  order by
        mt.main_account_id asc, mt.parent_id asc, mt.id asc
        ;
        `;
        let params1 = [req.session.company_id, posted_elements.start_date, posted_elements.end_date];

        await db.tx(async (tx) => {
            let trial_balance = await tx.any(query1, params1);
        
            // ÙØµÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ finance_statement
            const financeStatement = trial_balance.filter(row => +row.finance_statement === 1);
            const incomeStatement = trial_balance.filter(row => +row.finance_statement === 2);
        
            const hide_zero = posted_elements.is_hiding_zero_balances;
            let new_array = [];
            let addedAccounts = new Set(); // Ù„ØªØªØ¨Ø¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ØªÙŠ ØªÙ…Øª Ø¥Ø¶Ø§ÙØªÙ‡Ø§
        
            // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø£Ø±ØµØ¯Ø© ØµÙØ±ÙŠØ©
            function checkAllSubAccountsZero(accountsArray, parentId) {
                let subAccounts = accountsArray.filter(item => +item.parent_id === +parentId);
                if (subAccounts.length === 0) return true;
        
                for (const acc of subAccounts) {
                    if (!(+acc.debit_end === 0 && +acc.credit_end === 0)) {
                        return false;
                    }
                    if (!checkAllSubAccountsZero(accountsArray, acc.id)) {
                        return false;
                    }
                }
                return true;
            }
        
            // Ø¯Ø§Ù„Ø© ØªÙƒØ±Ø§Ø±ÙŠØ© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
            async function addSubAccounts(row, array, currentPadding = 0) {
                const id = row.id;
                const is_final_account = row.is_final_account;
        
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ù‚Ø¯ Ø£ÙØ¶ÙŠÙ Ø¨Ø§Ù„ÙØ¹Ù„
                if (!addedAccounts.has(id)) {
                    addedAccounts.add(id); // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨ ÙƒÙ…Ø¶Ø§Ù
        
                    // ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ… padding
                    row.padding = currentPadding;
        
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø±Ø¦ÙŠØ³ÙŠ
                    if (!is_final_account) {
                        const sub_accounts_array = array.filter(item => +item.parent_id === +id) || [];
                        const allColumnsZero = +row.debit_end === 0 && +row.credit_end === 0;
        
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© Ø§Ù„Ø¹Ù…ÙŠÙ‚Ø© Ù‚Ø¨Ù„ Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                        if (hide_zero && checkAllSubAccountsZero(array, id) && (+row.global_id !== 1 && +row.global_id !== 2) && allColumnsZero) {
                            return;
                        }
        
                        // Ø£Ø¶Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                        new_array.push(row);
        
                        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
                        for (const subrow of sub_accounts_array) {
                            await addSubAccounts(subrow, array, currentPadding + 1.5); // 1rem
                        }
                    } else {
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© Ù„Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
                        if (hide_zero) {
                            if (+row.debit_end !== 0 || +row.credit_end !== 0) {
                                new_array.push(row);
                            }
                        } else {
                            new_array.push(row);
                        }
                    }
                }
            }
        
            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù€ trial_balance
            for (const row of financeStatement) {
                await addSubAccounts(row, financeStatement, 0); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„ÙƒÙ„ Ø­Ø³Ø§Ø¨ Ø±Ø¦ÙŠØ³ÙŠ Ù…Ø¹ padding Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ 0
            }
            for (const row of incomeStatement) {
                await addSubAccounts(row, incomeStatement, 0); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„ÙƒÙ„ Ø­Ø³Ø§Ø¨ Ø±Ø¦ÙŠØ³ÙŠ Ù…Ø¹ padding Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ 0
            }
            trial_balance = new_array;
        
            const postedData = { trial_balance };
            res.json(postedData);
        });
        
        
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while reports_trialBalance_view", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: "âŒ Error while reports_trialBalance_view" });
      }
    });



    app.post("/reports_finance_statement_view", async (req, res) => {
      try {

    //! Permission Ù…Ø¹Ù„Ù‚
    // await permissions(req, "purshases_returns_permission", "delete");
    // if (!permissions) {
    //   return res.status(403).json({
    //     success: false,
    //     message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
    //   });
    // }

    const posted_elements = req.body;
    // const transaction_type = 7
  

      //! sql injection check
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


    const InValidDateFormat = isInValidDateFormat([posted_elements.end_date]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    //50000
        let query1 = `
WITH 
stock_balances as (
select
	SUM(CASE 
            WHEN ah.account_type_id = 5 AND tb.item_amount > 0 THEN coalesce(tb.cogs, 0)
            WHEN (ah.account_type_id = 5 OR ah.global_id = 17) AND tb.item_amount < 0 THEN coalesce(tb.cogs * -1, 0)
            ELSE 0 
        END
    ) AS stock_value,

    SUM(CASE 
            WHEN (ah.account_type_id = 5 OR ah.global_id = 17) AND th.transaction_type in (3,4) THEN 
            	case
	    			when tb.item_amount > 0 then coalesce(tb.cogs *-1, 0)
        			when tb.item_amount < 0 then coalesce(tb.cogs, 0) -- Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
        			else 0
	    		end
            ELSE 0 
        END
    ) AS cogs_value
FROM transaction_body tb
INNER JOIN accounts_header ah ON ah.id = tb.item_id
LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE ah.company_id = $1
  AND ah.is_final_account is true
  AND th.is_deleted IS NULL
  AND th.datex <= $2
  AND tb.item_id is not null
),
balances as(
    SELECT
    SUM(CASE 
            WHEN ah.global_id = 16 THEN COALESCE(tb.credit, 0)  - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS profit_account_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 1 AND ah.main_account_id = 4 THEN COALESCE(tb.credit, 0)  - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS revenue_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 1 AND ah.main_account_id = 5 THEN COALESCE(tb.debit, 0)  - COALESCE(tb.credit, 0)
            ELSE 0 
        END
    ) AS expenses_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 6 AND is_accumulated_depreciation IS NULL THEN COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
            ELSE 0 
        END
    ) AS fixed_assests_cost,

    SUM(CASE 
            WHEN ah.account_type_id = 6 AND is_accumulated_depreciation IS TRUE THEN  COALESCE(tb.credit, 0)  - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS fixed_assests_accumulated_depreciation,
    
    SUM(CASE 
            WHEN ah.account_type_id = 2 THEN COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
            ELSE 0 
        END
    ) AS customers_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 3 THEN COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS vendors_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 9 THEN COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
            ELSE 0 
        END
    ) AS cash_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 4 THEN COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS employees_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 10 THEN COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS capital_value
    
FROM transaction_body tb
INNER JOIN accounts_header ah ON ah.id = tb.account_id
LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE ah.company_id = $1
  and ah.is_final_account is true
  AND th.is_deleted IS NULL
  AND th.datex <= $2
  
),
main_trial_balance AS (
    SELECT
        ah.id,
        ah.account_name,
        CASE
            WHEN ah.global_id = 12  THEN sb.stock_value -- Ù‚ÙŠÙ…Ù‡ Ù…Ø®Ø²ÙˆÙ† Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ø©
            WHEN ah.global_id = 9 then  -- Ø§Ù„Ø§ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ©
            	case
            		when ah.main_account_id = 1 then b.fixed_assests_cost
            		when ah.main_account_id != 1 then b.fixed_assests_cost * -1
            		else 0
            	end
            WHEN ah.global_id = 10 then  -- Ø§Ù…Ø¬Ù…Ø¹ Ø§ØµÙˆÙ„ Ø«Ø§Ø¨ØªØ©
            	case
            		when ah.main_account_id = 1 then b.fixed_assests_accumulated_depreciation * -1
            		when ah.main_account_id != 1 then b.fixed_assests_accumulated_depreciation
            		else 0
            	end	
            WHEN ah.global_id = 11 then  -- Ø§Ø§Ù„Ù†Ù‚Ø¯ÙŠØ© ÙˆÙ…Ø§ ÙÙ‰ Ø­ÙƒÙ…Ù‡Ø§
            	case
            		when ah.main_account_id = 1 then b.cash_value
            		when ah.main_account_id != 1 then b.cash_value * -1
            		else 0
            	end	
            WHEN ah.global_id = 13 then  -- Ø§Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡
            	case
            		when ah.main_account_id = 1 then b.customers_value
            		when ah.main_account_id != 1 then b.customers_value * -1
            		else 0
            	end	            	
            WHEN ah.global_id = 14 then  -- Ø§Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†
            	case
            		when ah.main_account_id = 1 then b.vendors_value * -1
            		when ah.main_account_id != 1 then b.vendors_value
            		else 0
            	end
            WHEN ah.global_id = 20 then  -- Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ†
            	case
            		when ah.main_account_id = 1 then b.employees_value * -1
            		when ah.main_account_id != 1 then b.employees_value
            		else 0
            	end	            	
            WHEN ah.global_id = 15 then  -- Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„
            	case
            		when ah.main_account_id = 1 then b.capital_value *-1
            		when ah.main_account_id != 1 then b.capital_value
            		else 0
            	end
            WHEN ah.global_id = 16 then  -- Ø§Ø±Ø¨Ø§Ø­ ÙˆØ®Ø³Ø§Ø¦Ø± Ø§Ù„ÙØªØ±Ù‡
					coalesce(b.profit_account_value, 0) + coalesce(b.revenue_value, 0) - coalesce(b.expenses_value, 0) - coalesce(sb.cogs_value, 0)
            WHEN ah.main_account_id in (4,5) then 0  -- Ù„Ø§ ÙŠØ¬Ù…Ø¹ Ø¨Ù†ÙˆØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø®Ù„ Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¯Ù‡            	
            ELSE 
                SUM(
                case
                	when ah.account_type_id not in (2,3,4,5,6,7,8,9,10) then
                		case
                	    	when ah.main_account_id in (1,5) THEN COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
                		 	when ah.main_account_id in (2,3,4) THEN COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
                		 	else 0
                		end
                end
                 )
        END AS balance,
        ah.is_final_account,
        ah.account_no,
        ah.finance_statement,
        ah.cashflow_statement,
        ah.account_type_id,
        ah.account_name_en,
        ah.global_id,
        ah.main_account_id,
        ah.is_inactive,
        ab.parent_id
    FROM
        accounts_header ah
    LEFT JOIN accounts_body ab ON ab.account_id = ah.id
    LEFT JOIN transaction_body tb ON tb.account_id = ah.id
    LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
    LEFT JOIN balances b ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
    LEFT JOIN stock_balances sb ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
    WHERE
        ah.company_id = $1
        and (ah.global_id != 1 or ah.global_id is null)
        and ah.finance_statement = 1
        AND (ah.account_type_id NOT IN (7, 8, 11) or ah.account_type_id is null)
        AND ((ah.account_type_id != 5 or ah.account_type_id is null) or ah.global_id = 12)
		AND (
    		(ah.account_type_id IS NULL OR ah.account_type_id NOT IN (2, 3, 6, 4, 9, 10)) 
    		OR ah.global_id IN (13, 14, 9, 20, 11, 15)
		)
    GROUP BY
        ah.id, ab.parent_id, b.capital_value, b.employees_value, b.cash_value, b.vendors_value, b.customers_value, b.fixed_assests_accumulated_depreciation, b.fixed_assests_cost, b.expenses_value, b.profit_account_value, b.revenue_value, sb.cogs_value, sb.stock_value
),
main_accounts_totals as (
select
	SUM(CASE 
            WHEN mt.main_account_id = 1 THEN COALESCE(mt.balance, 0)
            ELSE 0 
        END
    ) AS assets_value,
	SUM(CASE 
            WHEN mt.main_account_id = 2 THEN COALESCE(mt.balance, 0)
            ELSE 0 
        END
    ) AS liablities_value,
	SUM(CASE 
            WHEN mt.main_account_id = 3 THEN COALESCE(mt.balance, 0)
            ELSE 0 
        END
    ) AS equity_value
from
	main_trial_balance as mt
)
select
    mt.id,
    mt.account_name,
    case
	    when mt.global_id = 3 then mat.assets_value
	    when mt.global_id = 4 then mat.liablities_value
	    when mt.global_id = 5 then mat.equity_value
	    else balance
    end as balance,
    mt.is_final_account as f,
    mt.account_no,
    mt.finance_statement,
    mt.cashflow_statement,
    mt.account_type_id,
    mt.account_name_en,
    mt.global_id as g,
    mt.main_account_id,
    mt.is_inactive,
    mt.parent_id,
    null as padding
from 
	main_trial_balance mt
left join main_accounts_totals mat on true
  order by
    mt.main_account_id asc, mt.parent_id asc, mt.id asc
      ;
    `;
    let params1 = [req.session.company_id, posted_elements.end_date]
    
    await db.tx(async (tx) => {
      let trial_balance = await tx.any(query1, params1);
    
      const hide_zero = posted_elements.is_hiding_zero_balances;
      let new_array = [];
      let addedAccounts = new Set(); // Ù„ØªØªØ¨Ø¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ØªÙŠ ØªÙ…Øª Ø¥Ø¶Ø§ÙØªÙ‡Ø§
    
      // Ø¯Ø§Ù„Ø© ØªÙƒØ±Ø§Ø±ÙŠØ© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
      async function addSubAccounts(row, trial_balance, currentPadding = 0) {
        const id = row.id;
        const is_final_account = row.is_final_account;
        

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ù‚Ø¯ Ø£ÙØ¶ÙŠÙ Ø¨Ø§Ù„ÙØ¹Ù„
        if (!addedAccounts.has(id)) {
            addedAccounts.add(id); // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨ ÙƒÙ…Ø¶Ø§Ù
          
            // ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ… padding
            row.padding = currentPadding;
              
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
            if (!is_final_account) {
                const sub_accounts_array = trial_balance.filter(item => +item.parent_id === +id) || [];

                if (hide_zero && sub_accounts_array.length === 0 && +row.balance === 0) {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø±ÙˆØ· Ù…ØªØ­Ù‚Ù‚Ø© Ù„Ø§ Ù†Ø¶ÙŠÙ Ø§Ù„Ø­Ø³Ø§Ø¨
                    return;
                }

                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
                if (sub_accounts_array.length > 0) {
                    let areAllSubAccountsZero = true;
                  
                    for (const subrow of sub_accounts_array) {

                        if (+subrow.balance !== 0 || !hide_zero) {
                            areAllSubAccountsZero = false;
                            break;
                        }
                    }
                    
                    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© ØµÙØ±ØŒ Ù„Ø§ ØªØ¶Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                    if (hide_zero && areAllSubAccountsZero) {
                        return;
                    }

                    // Ø£Ø¶Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                    new_array.push(row);
    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
                    for (const subrow of sub_accounts_array) {
                        await addSubAccounts(subrow, trial_balance, currentPadding + 1.5); // 1rem
                    }
                } else {
                    // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ø³Ø§Ø¨Ø§Øª ÙØ±Ø¹ÙŠØ©
                    new_array.push(row);
                }
            } else {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© Ù„Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
                if (hide_zero) {
                    if (+row.balance !== 0) {
                        new_array.push(row);
                    }
                } else {
                    new_array.push(row);
                }
            }
        }
    }
    
    
      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù€ trial_balance
      for (const row of trial_balance) {
        await addSubAccounts(row, trial_balance, 0); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„ÙƒÙ„ Ø­Ø³Ø§Ø¨ Ø±Ø¦ÙŠØ³ÙŠ Ù…Ø¹ padding Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ 0
      }
      trial_balance = new_array;
          
      const postedData = { trial_balance/*, customersDataArray */};
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while reports_trialBalance_view", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage, });
      }
    });


    app.post("/reports_income_statement_view_ar", async (req, res) => {
      try {

    //! Permission Ù…Ø¹Ù„Ù‚
    // await permissions(req, "purshases_returns_permission", "delete");
    // if (!permissions) {
    //   return res.status(403).json({
    //     success: false,
    //     message_ar: "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.",
    //   });
    // }

    const posted_elements = req.body;
    // const transaction_type = 7
  

      //! sql injection check
      const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
      if (hasBadSymbols) {
        return res.json({
          success: false,
          message_ar:
            "Invalid input detected due to prohibited characters. Please review your input and try again.",
        });
      }


    const InValidDateFormat = isInValidDateFormat([posted_elements.start_date, posted_elements.end_date]);
    if (InValidDateFormat) {
      return res.status(400).json({
        success: false,
        message_ar: InValidDateFormat_message_ar,
      });
    }

        //* Start--------------------------------------------------------------

    let query1 = `
WITH 
stock_balances as (
select

    SUM(CASE 
            WHEN ah.account_type_id = 5 AND tb.item_id is not null AND th.transaction_type in (3,4) THEN 
            	case
	    			when tb.item_amount > 0 then coalesce(tb.cogs *-1, 0)
        			when tb.item_amount < 0 then coalesce(tb.cogs, 0) -- Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©
        			else 0
	    		end
            ELSE 0 
        END
    ) AS cogs_items_value,
    
    SUM(CASE 
    	WHEN th.transaction_type = 2 and ah2.global_id = 17 then
        	case
	        	when coalesce(tb.debit, 0) > 0 then coalesce(tb.debit, 0)
	        	when coalesce(tb.credit, 0) > 0 then coalesce(tb.credit, 0)
        		else 0
	    	end
        ELSE 0
    END) AS cost_account_value

FROM transaction_body tb
left JOIN accounts_header ah ON ah.id = tb.item_id
left join accounts_header ah2 on ah2.id = tb.account_id
LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE th.company_id = $1
  and (ah.is_final_account is true OR ah2.is_final_account is true)
  AND th.is_deleted IS NULL
  AND th.datex between $2 and $3
  AND (tb.item_id is not null OR ah2.global_id = 17)
),

balances as(
    SELECT

    SUM(CASE 
            WHEN ah.account_type_id = 1 AND ah.main_account_id = 4 THEN COALESCE(tb.credit, 0)  - COALESCE(tb.debit, 0)
            ELSE 0 
        END
    ) AS revenue_value,
    
    SUM(CASE 
            WHEN ah.account_type_id = 1 AND ah.main_account_id = 5 THEN COALESCE(tb.debit, 0)  - COALESCE(tb.credit, 0)
            ELSE 0 
        END
    ) AS expenses_value
    
FROM transaction_body tb
INNER JOIN accounts_header ah ON ah.id = tb.account_id
LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE ah.company_id = $1
  and ah.is_final_account is true
  AND th.is_deleted IS NULL
  AND th.datex between $2 and $3
),
main_incom_statemnt AS (
    SELECT
        ah.id,
        ah.account_name,
        CASE
            WHEN ah.global_id = 17 then  -- ØªÙƒÙ„ÙØ© Ø§Ù„Ø¨Ø¶Ø§Ø¹Ù‡ Ø§Ù„Ù…Ø¨Ø§Ø¹Ù‡
            	case
            		when ah.main_account_id = 5 then coalesce(sb.cogs_items_value, 0) + COALESCE(sb.cost_account_value)
            		when ah.main_account_id != 5 then (coalesce(sb.cogs_items_value, 0) + COALESCE(sb.cost_account_value)) * -1
            		else 0
            	end           	
            WHEN ah.global_id = 16 then  -- Ø§Ø±Ø¨Ø§Ø­ ÙˆØ®Ø³Ø§Ø¦Ø± Ø§Ù„ÙØªØ±Ù‡
					b.revenue_value - b.expenses_value - sb.cogs_items_value
            WHEN ah.main_account_id in (1,2,3) then 0  -- Ù„Ø§ ÙŠØ¬Ù…Ø¹ Ø¨Ù†ÙˆØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø§Ù„Ù‰              	
            ELSE 
                SUM(
                case
                	when ah.account_type_id not in (2,3,4,5,6,7,8,9,10) then
                		case
                	    	when ah.main_account_id in (1,5) THEN COALESCE(tb.debit, 0) - COALESCE(tb.credit, 0)
                		 	when ah.main_account_id in (2,3,4) THEN COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0)
                		 	else 0
                		end
                end
                 )
        END AS balance,
        ah.is_final_account,
        ah.account_no,
        ah.finance_statement,
        ah.cashflow_statement,
        ah.account_type_id,
        ah.account_name_en,
        ah.global_id,
        ah.main_account_id,
        ah.is_inactive,
        ab.parent_id
    FROM
        accounts_header ah
    LEFT JOIN accounts_body ab ON ab.account_id = ah.id
    LEFT JOIN transaction_body tb ON tb.account_id = ah.id
    LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
    LEFT JOIN balances b ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
    LEFT JOIN stock_balances sb ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
    WHERE
        ah.company_id = $1
        and (ah.global_id != 2 or ah.global_id is null)
        and ah.finance_statement = 2
        AND (ah.account_type_id NOT IN (7, 8, 11) or ah.account_type_id is null)
        AND ((ah.account_type_id != 5 or ah.account_type_id is null) or ah.global_id = 12)
		AND (
    		(ah.account_type_id IS NULL OR ah.account_type_id NOT IN (2, 3, 6, 4, 9, 10)) 
    		OR ah.global_id IN (13, 14, 9, 20, 11, 15)
		)
    GROUP BY
        ah.id, ab.parent_id, b.expenses_value, b.revenue_value, sb.cogs_items_value, sb.cost_account_value
)
select
    mt.id,
    mt.account_name,
    case
	    when mt.global_id = 6 then b.revenue_value
	    when mt.global_id = 7 then b.expenses_value + sb.cogs_items_value
	    else balance
    end as balance,
    mt.is_final_account,
    mt.account_no,
    mt.finance_statement,
    mt.cashflow_statement,
    mt.account_type_id,
    mt.account_name_en,
    mt.global_id,
    mt.main_account_id,
    mt.is_inactive,
    mt.parent_id,
    null as padding
from 
	main_incom_statemnt mt
LEFT JOIN balances b ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
LEFT JOIN stock_balances sb ON true -- Ø±Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙÙ‰ Ø­Ø§Ù„Ù‡ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ­Ø¯
order by
    mt.main_account_id asc, mt.parent_id asc, mt.id asc
    ;
        `;

    let params1 = [req.session.company_id, posted_elements.start_date, posted_elements.end_date]
    
    await db.tx(async (tx) => {
      let trial_balance = await tx.any(query1, params1);
    
      const hide_zero = posted_elements.is_hiding_zero_balances;
      let new_array = [];
      let addedAccounts = new Set(); // Ù„ØªØªØ¨Ø¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ØªÙŠ ØªÙ…Øª Ø¥Ø¶Ø§ÙØªÙ‡Ø§
    
      // Ø¯Ø§Ù„Ø© ØªÙƒØ±Ø§Ø±ÙŠØ© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©


      async function addSubAccounts(row, trial_balance, currentPadding = 0) {
        const id = row.id;
        const is_final_account = row.is_final_account;
        

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ù‚Ø¯ Ø£ÙØ¶ÙŠÙ Ø¨Ø§Ù„ÙØ¹Ù„
        if (!addedAccounts.has(id)) {
            addedAccounts.add(id); // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨ ÙƒÙ…Ø¶Ø§Ù
          
            // ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ… padding
            row.padding = currentPadding;
              
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
            if (!is_final_account) {
                const sub_accounts_array = trial_balance.filter(item => +item.parent_id === +id) || [];

                
                
                if (hide_zero && sub_accounts_array.length === 0 && +row.balance === 0) {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø±ÙˆØ· Ù…ØªØ­Ù‚Ù‚Ø© Ù„Ø§ Ù†Ø¶ÙŠÙ Ø§Ù„Ø­Ø³Ø§Ø¨
                    return;
                }

                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
                if (sub_accounts_array.length > 0) {
                    let areAllSubAccountsZero = true;
                  
                    for (const subrow of sub_accounts_array) {

                        if (+subrow.balance !== 0 || !hide_zero) {
                            areAllSubAccountsZero = false;
                            break;
                        }
                    }
                    
                    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© ØµÙØ±ØŒ Ù„Ø§ ØªØ¶Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                    if (hide_zero && areAllSubAccountsZero) {
                        return;
                    }

                    // Ø£Ø¶Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                    new_array.push(row);
    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
                    for (const subrow of sub_accounts_array) {
                        await addSubAccounts(subrow, trial_balance, currentPadding + 1.5); // 1rem
                    }
                } else {
                    // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ø³Ø§Ø¨Ø§Øª ÙØ±Ø¹ÙŠØ©
                    new_array.push(row);
                }
            } else {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø£Ø±ØµØ¯Ø© Ø§Ù„ØµÙØ±ÙŠØ© Ù„Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
                if (hide_zero) {
                    if (+row.balance !== 0) {
                        new_array.push(row);
                    }
                } else {
                    new_array.push(row);
                }
            }
        }
    }
    
    
      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù€ trial_balance
      for (const row of trial_balance) {
        await addSubAccounts(row, trial_balance, 0); // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„ÙƒÙ„ Ø­Ø³Ø§Ø¨ Ø±Ø¦ÙŠØ³ÙŠ Ù…Ø¹ padding Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ 0
      }
      trial_balance = new_array;
          
      const postedData = { trial_balance/*, customersDataArray */};
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while reports_trialBalance_view", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage, });
      }
    });
   
    app.post("/get_accounts_data_for_report_account_statement", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        // await permissions(req, "purshases_returns_permission", "add");
        // if (!permissions) {
        //   return;
        // }
    
        
        const posted_elements = req.body;
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    

        // const InValidDateFormat = isInValidDateFormat([posted_elements.start_date, posted_elements.end_date]);
        // if (InValidDateFormat) {
        //   return res.status(400).json({
        //     success: false,
        //     message_ar: InValidDateFormat_message_ar,
        //   });
        // }

        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        // const transaction_type = 7

        let query1 = `
        SELECT
          A.id,
          A.account_name,
          A.account_type_id,
          COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
          NULL AS is_accumulated_depreciation
        FROM
          accounts_header A
        WHERE
          A.company_id = $1
          AND is_final_account = true
          AND (global_id != 8 OR global_id IS NULL)
        
        UNION ALL
        
        SELECT
          A.id,
          'Ù…Ø¬Ù…Ø¹ Ø§Ù‡Ù„Ø§Ùƒ - ' || A.account_name AS account_name,
          A.account_type_id,
          COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
          true AS is_accumulated_depreciation
        FROM
          accounts_header A
        WHERE
          A.company_id = $1
          AND is_final_account = true
          AND (global_id != 8 OR global_id IS NULL)
          AND A.account_type_id = 6;
        `;
        let params1 = [req.session.company_id];

        let query2 = `select id, account_type_name
          from account_type
          where id IN (1, 2, 3, 4, 6, 9, 10)
          order by order_asc ASC;`;  // in (1,2 ) ya3ny = 1 or 2 
    await db.tx(async (tx) => {
    
      const accounts = await tx.any(query1, params1);
      const accounts_types = await tx.any(query2)

      const postedData = {accounts, accounts_types};
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get_accounts_data_for_report_account_statement", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: "âŒ Error while get_data_for_purshasesInvoiceToreturns" });
      }
    });


    app.post("/report_account_statement_view_ar", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        // await permissions(req, "purshases_returns_permission", "add");
        // if (!permissions) {
        //   return;
        // }
    
        
        const posted_elements = req.body;
        
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    

        const InValidDateFormat = isInValidDateFormat([posted_elements.start_date, posted_elements.end_date]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }

        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

       // const transaction_type = 7
        
        //! check
        let quer001 = ` select id, account_name, account_type_id, global_id, main_account_id from accounts_header where id = $1 and company_id = $2;`;
        let result = await db.oneOrNone(quer001, [posted_elements.x, req.session.company_id])

        if (!result || !result.account_name || result.account_name === ''){
          await block_user(req,'Sras01')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });  
        }
    


        //! ğŸŸ¡ fixed assests
        let fixed_assests_where = ''
        let fixed_assests_status = posted_elements.other_obj
        fixed_assests_status = fixed_assests_status ? fixed_assests_status.fixed_assests : false
        if (fixed_assests_status){
          if (fixed_assests_status === 'fixed_assest_only'){
            fixed_assests_where = ' AND tb.is_accumulated_depreciation is null'
          } else if (fixed_assests_status === 'accumulated_depreciation_only'){
            fixed_assests_where =  ' AND tb.is_accumulated_depreciation is true'
          } else if (fixed_assests_status === 'mixed'){
            fixed_assests_where ='' // get all
          }
        }
  
        
        
        let normal_query = `
       WITH previous_balance AS (
    SELECT 
        ah.id AS account_id,
        ah.main_account_id,
        case 
        	when ah.main_account_id in (1,5) then
        		COALESCE(SUM(COALESCE(tb.debit, 0)), 0) - COALESCE(SUM(COALESCE(tb.credit, 0)), 0)
        	when ah.main_account_id in (2,3,4) then
        		COALESCE(SUM(COALESCE(tb.credit, 0)), 0) - COALESCE(SUM(COALESCE(tb.debit, 0)), 0)
        	else 0
        end AS balance
    FROM 
        accounts_header ah
        LEFT JOIN transaction_body tb ON ah.id = tb.account_id
        LEFT JOIN transaction_header th ON tb.transaction_header_id = th.id
    WHERE 
        ah.id = $1
        and ah.company_id = $4
        and th.company_id = $4
        AND (th.datex IS NULL OR th.datex < $2)
        AND th.is_deleted is null
    GROUP BY 
        ah.id
),
transaction_details AS (
    SELECT 
        ROW_NUMBER() OVER (ORDER BY th.datex ASC, th.id ASC) AS serial_number,
        th.id AS x,
        th.datex,
        th.transaction_type as type,
        th.reference,
       	CONCAT(
        	tt.doc_prefix, '-',
        	SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        	LPAD(CAST(th.reference AS TEXT), 5, '0'), ' / ', -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    		tt.transaction_type_name
        ) AS referenceconcat,
        tb.row_note,
        ah.main_account_id,
        th.transaction_type,
        COALESCE(tb.debit, 0) AS debit,
        COALESCE(tb.credit, 0) AS credit
    FROM 
        accounts_header ah
        JOIN transaction_body tb ON ah.id = tb.account_id
        JOIN transaction_header th ON tb.transaction_header_id = th.id
        LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
    WHERE 
        ah.id = $1
        and ah.company_id = $4
        and th.company_id = $4
        AND th.datex BETWEEN $2 AND $3
        AND th.is_deleted is null
        ${fixed_assests_where}
    UNION ALL
    SELECT 
        0 AS serial_number,  -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø£ÙˆÙ„ ÙˆØ§Ø­Ø¯
        0 AS x,
        $2 AS datex, -- ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØªØ±Ø©
        NULL AS type,
        NULL AS reference,
        'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚' AS referenceconcat,
        null AS row_note,
        pb.main_account_id,
        NULL AS transaction_type,
        case
	        when pb.main_account_id in (1,5) and pb.balance >= 0 then pb.balance
        	else 0	
        end AS debit,
        case
	        when pb.main_account_id in (2,3,4) and pb.balance <= 0 then pb.balance
        	else 0
        end AS credit
    FROM 
        previous_balance pb
),
cumulative_balance AS (
    SELECT 
        serial_number,
        x,
        datex,
        type,
        reference,
        referenceconcat,
        row_note,
        transaction_type,
        debit,
        credit,
        case
        	when td.main_account_id in (1,5) then SUM(debit - credit) OVER (ORDER BY serial_number ASC)
        	when td.main_account_id in (2,3,4) then SUM(credit - debit) OVER (ORDER BY serial_number ASC)
        end AS cumulative_balance
    FROM 
        transaction_details td
        
)
SELECT 
    x,
    datex,
    type,
    reference,
    referenceconcat,
    row_note,
    transaction_type,
    debit,
    credit,
    cumulative_balance AS balance
FROM 
    cumulative_balance
ORDER BY 
    serial_number DESC;
      ;
    `;
  
    let normal_params = [posted_elements.x, posted_elements.start_date, posted_elements.end_date, req.session.company_id]
    

  
    
        //! ğŸŸ¡ cogs
        let is_cogs = false;
        if (result.global_id && +result.global_id === 17){
          is_cogs = true
        }

        let cogs_account_query = `
       WITH previous_balance AS (
    SELECT 
    SUM(CASE 
	    	when ah1.global_id = 17 then
	    		coalesce(tb.debit, 0) - coalesce(tb.credit, 0)
            WHEN ah2.account_type_id = 5 AND th.transaction_type in (3,4) THEN 
            	case
	    			when coalesce(tb.item_amount,0) > 0 then coalesce(tb.cogs *-1, 0) -- Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
        			when coalesce(tb.item_amount,0) < 0 then coalesce(tb.cogs, 0) -- Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
        			else 0
	    		end
            ELSE 0 
        END
    ) AS balance
    FROM 
        transaction_body tb
        LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
        LEFT JOIN accounts_header ah1 ON ah1.id = tb.account_id
        LEFT JOIN accounts_header ah2 ON ah2.id = tb.item_id
    WHERE 
        th.company_id = $1
        AND (th.datex IS NULL OR th.datex < $2)
        and (th.transaction_type in (3,4) or (th.transaction_type = 2 and ah1.global_id = 17))
        and th.is_deleted is null
        and (tb.item_id is not null or ah1.global_id = 17)
),
transaction_details AS (
    SELECT
        ROW_NUMBER() OVER (ORDER BY th.datex ASC, th.id ASC) AS serial_number,
        th.id AS x,
        th.datex,
        th.transaction_type as type,
        th.reference,
       	CONCAT(
        	tt.doc_prefix, '-',
        	SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        	LPAD(CAST(th.reference AS TEXT), 5, '0'), ' / ', -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    		tt.transaction_type_name
        ) AS referenceconcat,
        tb.row_note,
        null as main_account_id,
        th.transaction_type,
        case
        	when ah1.global_id = 17 then
        		COALESCE(tb.debit, 0)
        	WHEN ah2.account_type_id = 5 AND th.transaction_type in (3,4) then
        		case
        			when coalesce(tb.item_amount,0) < 0 then coalesce(tb.cogs, 0) -- Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
        			else 0
        		end
        	else 0	
        end AS debit,
                case
        	when ah1.global_id = 17 then
        		COALESCE(tb.credit, 0)
        	WHEN ah2.account_type_id = 5 AND th.transaction_type in (3,4) then
        		case
        			when coalesce(tb.item_amount,0) > 0 then coalesce(tb.cogs * -1, 0) -- Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
        			else 0
        		end
        	else 0	
        end AS credit
    FROM         
        transaction_body tb
        LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id        
		LEFT JOIN accounts_header ah1 ON ah1.id = tb.account_id
        LEFT JOIN accounts_header ah2 ON ah2.id = tb.item_id
        LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
    WHERE 
        th.company_id = $1
        AND th.datex BETWEEN $2 AND $3
        and (th.transaction_type in (3,4) or (th.transaction_type = 2 and ah1.global_id = 17))
        and th.is_deleted is null
        and (tb.item_id is not null or ah1.global_id = 17)
    UNION ALL
    SELECT 
        0 AS serial_number,  -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø£ÙˆÙ„ ÙˆØ§Ø­Ø¯
        0 AS x,
        $2 AS datex, -- ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØªØ±Ø©
        NULL AS type,
        NULL AS reference,
        'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚' AS referenceconcat,
        null AS row_note,
        null as main_account_id,
        NULL AS transaction_type,
        case
	        when pb.balance >= 0 then pb.balance
        	else 0	
        end AS debit,
        case
	        when pb.balance < 0 then pb.balance
        	else 0
        end AS credit
    FROM 
        previous_balance pb
),
cumulative_balance AS (
    SELECT
        serial_number,
        x,
        datex,
        type,
        reference,
        referenceconcat,
        row_note,
        transaction_type,
        debit,
        credit,
        	SUM(debit - credit) OVER (ORDER BY serial_number ASC) cumulative_balance
    FROM 
        transaction_details td
)
SELECT 
    x,
    datex,
    type,
    reference,
    referenceconcat,
    row_note,
    transaction_type,
    debit,
    credit,
    cumulative_balance AS balance
FROM 
    cumulative_balance
ORDER BY 
    serial_number DESC;
      ;
    `;
    let cogs_account_params = [req.session.company_id, posted_elements.start_date, posted_elements.end_date]

let query1;
let params1;

    query1 = is_cogs ? cogs_account_query : normal_query;
    params1 = is_cogs ? cogs_account_params : normal_params;


    await db.tx(async (tx) => {
    
      const account_statement = await tx.any(query1, params1);
      const account_name = result.account_name

      const postedData = {account_statement, account_name};      
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get_data_for_purshasesInvoiceToreturns", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage,});
      }
    });



    //#endregion end trial balace
  //#endregion end statements


  //#region stock

    app.post("/get_location_data", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        await permissions(req, "purshases_returns_permission", "add"); // Ù…Ø¹Ù„Ù‚
        if (!permissions) {
          return;
        }
    
        
        const posted_elements = req.body;
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        const transaction_type = 7
    
    
        let query1 = `
         -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
    select
      id as id,
      account_name as account_name
    from
      accounts_header 
    WHERE company_id = $1 
      AND account_type_id = 7
      AND is_inactive IS NULL
    order by
        id ASC
      ;
    `;
    let params1 = [req.session.company_id]


    
    await db.tx(async (tx) => {
    
      const itemslocationsArray = await tx.any(query1, params1);
      // const salesmanArray = await tx.any(query2, params2);
    
      const postedData = { itemslocationsArray};
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get_location_data", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage, });
      }
    });


    app.post("/get_stock_report", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        await permissions(req, "purshases_returns_permission", "add"); // Ù…Ø¹Ù„Ù‚
        if (!permissions) {
          return;
        }
    
        
        const posted_elements = req.body;
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    
        const InValidDateFormat = isInValidDateFormat([posted_elements.end_date]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }

        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
       

        const locations_array = posted_elements.locations_array || [];
    
        if (locations_array.length === 0 ){
          return res.json({
            success: false,
            message_ar: 'âŒ Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ù…Ø®Ø²ÙˆÙ† Ø§Ùˆ Ø§ÙƒØ«Ø± Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­'
          });
        }
        
        // ğŸ”¹ Ø¬Ù„Ø¨ Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
        let query1 = `
        SELECT id, account_name
        FROM accounts_header 
        WHERE company_id = $1 
          AND account_type_id = 7
          AND is_inactive IS NULL;
        `;
        
        const rows = await db.any(query1, [req.session.company_id]) || [];
        
        if (rows.length === 0) {
          return res.json({
            success: false,
            message_ar: 'âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…ÙˆØ§Ù‚Ø¹ Ù…Ø®Ø²ÙˆÙ† Ù…ÙØ¹Ø±ÙÙ‡'
          });
        }
        
        let checkedAll = posted_elements.checkedAll
        if (!checkedAll){
          if (rows.length === posted_elements.locations_array.length){
            checkedAll = true
          }else{
            checkedAll = false
          }
        }
        // ğŸ”¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø±Ø³Ù„Ø©
        const validIds = new Set(rows.map(row => +row.id));
        const allExist = locations_array.every(loc => validIds.has(loc));
        
        if (!allExist) {
          return res.json({
            success: false,
            message_ar: "âŒ Ø¨Ø¹Ø¶ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¶Ù…Ù† Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø§Ù„Ù…Ø¹Ø±ÙØ©."
          });
        }
        
// ğŸ”¹ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Map
const rowsMap = new Map(rows.map(r => [+r.id, r.account_name]));

let columns_st = locations_array.map(loc => {
  const loc_name = rowsMap.get(+loc);
  return `,COALESCE(SUM(CASE WHEN tb.item_location_id_tb = ${loc} THEN tb.item_amount END), 0) AS "${loc_name}"`;
}).join('');

let report_query = `
SELECT 
    tb.item_id, 
    ah.account_name
    ${columns_st}
    ,COALESCE(SUM(tb.item_amount), 0) AS total_balance
FROM transaction_body tb
LEFT JOIN accounts_header ah ON ah.id = tb.item_id
LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE 
    tb.item_location_id_tb IN (${locations_array.join(',')}) 
    AND ah.company_id = $1
    AND th.is_deleted IS NULL
    AND th.datex <= $2
GROUP BY tb.item_id, ah.account_name
${posted_elements.is_hiding_zero_balances ? `HAVING (${locations_array.map(loc => `COALESCE(SUM(CASE WHEN tb.item_location_id_tb = ${loc} THEN tb.item_amount END), 0)`).join(' + ')}) <> 0` : ''}
ORDER BY tb.item_id;
`;

await db.tx(async (tx) => {
  let report = await db.any(report_query, [req.session.company_id, posted_elements.end_date]);

  // ğŸ”¹ Ø¥Ø²Ø§Ù„Ø© total_balance Ù…Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† checkedAll === false
  if (!checkedAll) {
    report = report.map(row => {
      const { total_balance, ...rest } = row; // Ø¥Ø²Ø§Ù„Ø© `total_balance`
      return rest;
    });
  }

  const postedData = { report };
  res.json(postedData);
});

await last_activity(req);

      } catch (error) {
        await last_activity(req)
        console.error("Error while get_location_data", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage, });
      }
    });

    app.post("/get_items_movement_data_for_report", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        // await permissions(req, "purshases_returns_permission", "add");
        // if (!permissions) {
        //   return;
        // }
    
        
        const posted_elements = req.body;
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    

        // const InValidDateFormat = isInValidDateFormat([posted_elements.start_date, posted_elements.end_date]);
        // if (InValidDateFormat) {
        //   return res.status(400).json({
        //     success: false,
        //     message_ar: InValidDateFormat_message_ar,
        //   });
        // }

        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");
    
        // const transaction_type = 7

        let query1 = `
        SELECT
          A.id,
          A.account_name,
          A.account_type_id,
          COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
          NULL AS is_accumulated_depreciation
        FROM
          accounts_header A
        WHERE
          A.company_id = $1
          AND is_final_account = true
          AND (global_id != 8 OR global_id IS NULL)
        
        UNION ALL
        
        SELECT
          A.id,
          'Ù…Ø¬Ù…Ø¹ Ø§Ù‡Ù„Ø§Ùƒ - ' || A.account_name AS account_name,
          A.account_type_id,
          COALESCE(A.item_unite, 'Ø§Ù„ÙƒÙ…ÙŠØ©') AS item_unite,
          true AS is_accumulated_depreciation
        FROM
          accounts_header A
        WHERE
          A.company_id = $1
          AND is_final_account = true
          AND (global_id != 8 OR global_id IS NULL)
          AND A.account_type_id = 6;
        `;
        let params1 = [req.session.company_id];

        let query2 = `select id, account_type_name
          from account_type
          where id IN (5)
          order by order_asc ASC;`;  // in (1,2 ) ya3ny = 1 or 2 


          let query3 = `
          -- Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
     select
       id as id,
       account_name as account_name
     from
       accounts_header 
     WHERE company_id = $1 
       AND account_type_id = 7
     ORDER BY
        id ASC
       ;
     `;
     let params3 = [req.session.company_id]

    await db.tx(async (tx) => {
    
      const accounts = await tx.any(query1, params1);
      const accounts_types = await tx.any(query2)
      const locations = await tx.any(query3, params3)

      const postedData = {accounts, accounts_types, locations};
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get_accounts_data_for_report_account_statement", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: "âŒ Error while get_data_for_purshasesInvoiceToreturns" });
      }
    });


    app.post("/report_item_movement_view_ar", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        // await permissions(req, "purshases_returns_permission", "add");
        // if (!permissions) {
        //   return;
        // }
    
        
        const posted_elements = req.body;
        
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    

        const InValidDateFormat = isInValidDateFormat([posted_elements.start_date, posted_elements.end_date]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }

        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

       // const transaction_type = 7
        
        //! check

        let quer001 = ` select id, account_name, account_type_id, global_id, main_account_id from accounts_header where id = $1 and company_id = $2 AND account_type_id = 5 AND is_final_account is true;`;
        let result = await db.oneOrNone(quer001, [posted_elements.x, req.session.company_id])

        if (!result || !result.account_name || result.account_name === ''){
          await block_user(req,'Srimva01')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });  
        }
    
        console.log(posted_elements);
        
        let item_location = posted_elements.item_location || false
        
       /*
        let item_location_name = ''
        if (posted_elements.other_obj && posted_elements.other_obj.item_location_name){
          item_location_name = posted_elements.other_obj.item_location_name
          const result = await db.oneOrNone(`select id from accounts_header where account_name = $1 AND company_id = $2 AND account_type_id = 7`, [item_location_name, req.session.company_id])
          if (result && result.id){
            item_location = result.id
          }
        }
*/

  /*      
        let item_location_where = ''
        let item_location_status = posted_elements.item_location
        item_location_status = item_location_status ? item_location_status.item_location : false
        
        if (item_location_status){
          if (item_location_status === 'fixed_assest_only'){
            item_location_where = `AND tb.item_location_id_tb = ${item_location_status}`
          } else {
            item_location_where =  ''
          }
        }
  */


        let item_location_where = ''

        if (item_location){
          const result = await db.oneOrNone(`select count(id) as count_location_id from accounts_header where account_type_id = 7 AND company_id = $1`, [req.session.company_id])
          if (!result || result.count_location_id === 0){
            await block_user(req,'Srimva02')
            return res.json({
              success: false,
              xx: true,
              message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
            });  
          }else {
            item_location_where = `AND tb.item_location_id_tb = ${item_location}`
          }
        }


        let query1 = `
       WITH previous_balance AS (
SELECT 
    ah.id,
    COALESCE(SUM(tb.item_amount), 0) AS balance
FROM 
    accounts_header ah
    LEFT JOIN transaction_body tb ON tb.item_id = ah.id
    LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE 
    ah.id = $1
    AND th.company_id = $4
    and th.is_including_items is true
    AND th.datex < $2
    AND tb.item_amount IS NOT null
    ${item_location_where}
GROUP BY 
    ah.id
),
transaction_details AS (
    SELECT
        ROW_NUMBER() OVER (ORDER BY th.datex ASC, th.id ASC) AS serial_number,
        th.id AS x,
        th.datex,
        th.transaction_type as type,
        th.reference,
       	CONCAT(
        	tt.doc_prefix, '-',
        	SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        	LPAD(CAST(th.reference AS TEXT), 5, '0'), ' / ', -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    		tt.transaction_type_name
        ) AS referenceconcat,
        tb.row_note,
        ah.main_account_id,
        th.transaction_type,
CASE 
    WHEN COALESCE(tb.item_amount, 0) > 0 THEN tb.item_amount 
    ELSE 0 
END AS debit,
CASE 
    WHEN COALESCE(tb.item_amount, 0) < 0 THEN ABS(tb.item_amount) 
    ELSE 0 
END AS credit
    FROM 
        accounts_header ah
        JOIN transaction_body tb on tb.item_id = ah.id
        JOIN transaction_header th ON th.id = tb.transaction_header_id
        LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
    WHERE 
        ah.id = $1
        and th.company_id = $4
        AND th.datex BETWEEN $2 AND $3
        and th.is_including_items is true
        AND tb.item_amount IS NOT null
        ${item_location_where}
    UNION ALL
    SELECT 
        0 AS serial_number,  -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø£ÙˆÙ„ ÙˆØ§Ø­Ø¯
        0 AS x,
        $2 AS datex, -- ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØªØ±Ø©
        NULL AS type,
        NULL AS reference,
        'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚' AS referenceconcat,
        null AS row_note,
        null as main_account_id,
        NULL AS transaction_type,
        case
	        when  pb.balance >= 0 then pb.balance
        	else 0	
        end AS debit,
        case
	        when pb.balance <= 0 then pb.balance
        	else 0
        end AS credit
    FROM 
        previous_balance pb
),
cumulative_balance AS (
    SELECT
        serial_number,
        x,
        datex,
        type,
        reference,
        referenceconcat,
        row_note,
        transaction_type,
        debit,
        credit,
        SUM(debit - credit) OVER (ORDER BY serial_number ASC) AS cumulative_balance
    FROM 
        transaction_details td
)
SELECT 
    x,
    datex,
    type,
    reference,
    referenceconcat,
    row_note,
    transaction_type,
    debit,
    credit,
    cumulative_balance AS balance
FROM 
    cumulative_balance
ORDER BY 
    serial_number DESC;
      ;
    `;
    
    let params1 = [posted_elements.x, posted_elements.start_date, posted_elements.end_date, req.session.company_id]
    

    
    await db.tx(async (tx) => {
    
      const account_statement = await tx.any(query1, params1);
      const account_name = result.account_name

      const postedData = {account_statement, account_name};      
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get_data_for_purshasesInvoiceToreturns", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage,});
      }
    });

    app.post("/report_stock_cost_and_items_view_ar", async (req, res) => {
      try {
        //! Permission Ù…Ø¹Ù„Ù‚
        // await permissions(req, "purshases_returns_permission", "add");
        // if (!permissions) {
        //   return;
        // }
    
        
        const posted_elements = req.body;
        
        const hasBadSymbols = sql_anti_injection(...Object.values(posted_elements));
    
        if (hasBadSymbols) {
          return res.json({
            success: false,
            message_ar:
              "âŒ Invalid input detected due to prohibited characters. Please review your input and try again.",
          });
        }
    

        const InValidDateFormat = isInValidDateFormat([posted_elements.start_date, posted_elements.end_date]);
        if (InValidDateFormat) {
          return res.status(400).json({
            success: false,
            message_ar: InValidDateFormat_message_ar,
          });
        }

        turn_EmptyValues_TO_null(posted_elements);
        //* Start--------------------------------------------------------------
        // const rows = await db.any("SELECT e.id, e.employee_name FROM employees e");

       // const transaction_type = 7
        
        //! check

        let quer001 = ` select id, account_name, account_type_id, global_id, main_account_id from accounts_header where id = $1 and company_id = $2 AND account_type_id = 5 AND is_final_account is true;`;
        let result = await db.oneOrNone(quer001, [posted_elements.x, req.session.company_id])

        if (!result || !result.account_name || result.account_name === ''){
          await block_user(req,'Srimva01')
          return res.json({
            success: false,
            xx: true,
            message_ar: 'ğŸ”´ ØªÙ… ØªØ¬Ù…ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù†Ø¸Ø±Ø§ Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§ÙƒÙˆØ§Ø¯ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠÙ‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          });  
        }
    


    let query1 = `
  WITH previous_balance AS (
SELECT 
    ah.id,
    COALESCE(SUM(tb.item_amount), 0) AS amount,
    COALESCE(SUM(
        CASE 
            WHEN COALESCE(tb.item_amount, 0) >= 0 THEN COALESCE(tb.cogs, 0)
            WHEN COALESCE(tb.item_amount, 0) < 0 THEN COALESCE(tb.cogs * -1, 0)
            ELSE 0
        END
    ), 0) AS cogs
FROM 
    accounts_header ah
    LEFT JOIN transaction_body tb ON tb.item_id = ah.id
    LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE 
    ah.id = $1
    AND th.company_id = $4
    AND th.is_including_items IS true
    AND th.transaction_type NOT IN (12)
    AND th.datex < $2
    AND tb.item_amount IS NOT NULL
GROUP BY 
    ah.id
),
transaction_details AS (
    SELECT
        ROW_NUMBER() OVER (ORDER BY th.datex ASC, th.id ASC) AS serial_number,
        th.id AS x,
        th.datex,
        th.transaction_type as type,
        th.reference,
       	CONCAT(
        	tt.doc_prefix, '-',
        	SUBSTRING(th.datex, 1, 4), '-',  -- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø³Ù†Ø© Ù…Ù† datex
        	LPAD(CAST(th.reference AS TEXT), 5, '0'), ' / ', -- ØªØ­ÙˆÙŠÙ„ reference Ø¥Ù„Ù‰ Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ØµÙØ§Ø±
    		tt.transaction_type_name
        ) AS referenceconcat,
        tb.row_note,
        ah.main_account_id,
        th.transaction_type,
    	COALESCE(tb.item_amount, 0) AS amount,
    	COALESCE(
    		case
    			when COALESCE(tb.item_amount, 0) >=0 then COALESCE(tb.cogs, 0)
    			when COALESCE(tb.item_amount, 0) <0 then COALESCE(tb.cogs * -1, 0)
    		end
    	,0) as cogs
    FROM 
        accounts_header ah
        JOIN transaction_body tb on tb.item_id = ah.id
        JOIN transaction_header th ON th.id = tb.transaction_header_id
        LEFT JOIN transaction_type tt ON tt.id = th.transaction_type
    WHERE 
        ah.id = $1
        and th.company_id = $4
        AND th.datex BETWEEN $2 AND $3
        AND th.is_including_items is true
        AND th.transaction_type NOT IN (12)
        AND tb.item_amount IS NOT null
    UNION ALL
    SELECT 
        0 AS serial_number,  -- Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø£ÙˆÙ„ ÙˆØ§Ø­Ø¯
        0 AS x,
        $2 AS datex, -- ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØªØ±Ø©
        NULL AS type,
        NULL AS reference,
        'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚' AS referenceconcat,
        null AS row_note,
        null as main_account_id,
        NULL AS transaction_type,
	    pb.amount AS amount,
	    pb.cogs AS cogs
    FROM 
        previous_balance pb
),
cumulative_balance AS (
    SELECT
        serial_number,
        x,
        datex,
        type,
        reference,
        referenceconcat,
        row_note,
        transaction_type,
        amount,
        COALESCE(ABS(COALESCE(cogs, 0)) / NULLIF(ABS(COALESCE(amount, 0)), 0), 0) AS avg,
        cogs,
        SUM(amount) OVER (ORDER BY serial_number ASC) AS cumulative_amount,
        SUM(cogs) OVER (ORDER BY serial_number ASC) AS cumulative_cogs
    FROM 
        transaction_details td
)
SELECT 
    x,
    datex,
    type,
    reference,
    referenceconcat,
    row_note,
    transaction_type,
    amount,
    avg,
    cogs,
    cumulative_amount AS total_amount,
    COALESCE(ABS(COALESCE(cumulative_cogs, 0)) / NULLIF(ABS(COALESCE(cumulative_amount, 0)), 0), 0) AS total_avg,
    cumulative_cogs AS total_cogs
FROM 
    cumulative_balance
ORDER BY
    serial_number DESC
    ;
 `;
    let params1 = [posted_elements.x, posted_elements.start_date, posted_elements.end_date, req.session.company_id]
    

    
    await db.tx(async (tx) => {
    
      const account_statement = await tx.any(query1, params1);
      const account_name = result.account_name

      const postedData = {account_statement, account_name};      
      res.json(postedData);
    })
    
    
        await last_activity(req)
      } catch (error) {
        await last_activity(req)
        console.error("Error while get_data_for_purshasesInvoiceToreturns", error);
        res.join;
        res
          .status(500)
          .json({ success: false, message_ar: error.message || deafultErrorMessage,});
      }
    });
  //#endregion stock
//#endregion end reports


//!====================================================================================================================================


async function check_itemAmounts_for_all_location(datex, items_array, locations_array, req, tx) {

  const query = `

  WITH previous_balance AS (
    SELECT 
        ah1.id,
        ah1.account_name as item_name,
        tb.item_location_id_tb,
        ah2.account_name as location_name,
        COALESCE(SUM(tb.item_amount), 0) AS amount
    FROM 
         transaction_body tb
        LEFT JOIN accounts_header ah1 ON ah1.id = tb.item_id
        LEFT JOIN accounts_header ah2 ON ah2.id = tb.item_location_id_tb
        LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
    WHERE 
        th.company_id = $1
      AND th.is_including_items IS true
      AND th.datex < $2
      AND tb.item_amount IS NOT null
      AND ah1.id IN (${items_array.join(',')}) -- AND ah1.id IN (195,189)
      AND tb.item_location_id_tb IN (${locations_array.join(',')}) --AND tb.item_location_id_tb IN (23,104)
    GROUP BY 
        ah1.id, tb.item_location_id_tb, ah2.account_name
    ),
    transaction_details AS (
        select
          ah1.id,
          ah1.account_name as item_name,
            th.id AS th_id,
            tb.item_location_id_tb as location_id,
            ah2.account_name as location_name,
            th.datex,
            th.transaction_type,
            tb.debit,
            tb.credit,
          COALESCE(tb.item_amount, 0) AS amount
        FROM 
            transaction_body tb
            left join accounts_header ah1 on ah1.id =  tb.item_id
            left join accounts_header ah2 on ah2.id =  tb.item_location_id_tb
            left join transaction_header th ON th.id = tb.transaction_header_id
        WHERE 
            th.company_id = $1
            AND th.datex >= $2
            AND th.is_including_items is true
          AND tb.item_amount IS NOT null
          AND ah1.id IN (${items_array.join(',')}) -- AND ah1.id IN (195,189)
          AND tb.item_location_id_tb IN (${locations_array.join(',')}) -- AND tb.item_location_id_tb IN (23,104)
        UNION ALL
        SELECT 
            0 AS id,
            pb.item_name,
            0 as th_id,
            pb.item_location_id_tb as location_id,
            pb.location_name,
            $2 AS datex, -- ØªØ§Ø±ÙŠØ® Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØªØ±Ø©
            0 AS transaction_type,
            0 as debit,
            0 as credit,
          pb.amount AS amount
        FROM 
            previous_balance pb
    ),
    order_data as (
    select
      ROW_NUMBER() OVER (ORDER by
            id asc, location_id asc, datex ASC,
        CASE 
            -- ğŸŸ¢ Ø£ÙˆÙ„Ù‹Ø§: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØ¶ÙŠÙ Ù„Ù„Ù…Ø®Ø²ÙˆÙ†
            WHEN transaction_type = 0 THEN 1  -- Ø§
          WHEN transaction_type = 6 THEN 2  -- Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª
            WHEN transaction_type = 2 AND (amount > 0 OR debit > 0) THEN 3  -- Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨ÙŠ ÙŠØ¶ÙŠÙ Ù…Ø®Ø²ÙˆÙ†
            WHEN transaction_type = 31 AND amount > 0 THEN 4  -- ØªØµÙ†ÙŠØ¹ - Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ù†Ù‡Ø§Ø¦ÙŠ
            WHEN transaction_type = 12 AND amount > 0 THEN 5  -- ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²ÙˆÙ† - Ø¥Ø¶Ø§ÙØ©  ( Ø¨Ø³ Ù…Ø´ Ø¨ÙŠØ£Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„ØªÙƒÙ„ÙÙ‡ )
    
            -- ğŸ”µ Ø«Ø§Ù†ÙŠÙ‹Ø§: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªÙ‚Ù„Ù„ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª
            WHEN transaction_type = 7 THEN 6  -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª
            WHEN transaction_type = 2 AND (amount < 0 OR credit > 0) THEN 7  -- Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨ÙŠ ÙŠØ³Ø­Ø¨ Ù…Ø®Ø²ÙˆÙ†
            WHEN transaction_type = 31 AND amount < 0 THEN 8  -- ØªØµÙ†ÙŠØ¹ - Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ù…ÙˆØ§Ø¯ Ø®Ø§Ù…
            WHEN transaction_type = 12 AND amount < 0 THEN 9  -- ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²ÙˆÙ† - Ø®ØµÙ…  ( Ø¨Ø³ Ù…Ø´ Ø¨ÙŠØ£Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„ØªÙƒÙ„ÙÙ‡ )
    
    
            -- ğŸ”´ Ø«Ø§Ù„Ø«Ù‹Ø§: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØ³Ø­Ø¨ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (COGS)
            WHEN transaction_type = 3 THEN 10  -- Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
            WHEN transaction_type = 4 THEN 11  -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª
    
            -- âºï¸ Ø£Ø®ÙŠØ±Ù‹Ø§: Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ§Øª Ø£Ø®Ø±Ù‰ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©
            ELSE 12  
        END ASC,
            id ASC) AS serial_number,
      id,
      item_name,
      location_id,
      location_name,
      datex,
      th_id,
      transaction_type,
      amount
    from 	
      transaction_details
      
    )
        SELECT
            serial_number,
            id,
            item_name,
            location_id,
            location_name,
            datex,
            transaction_type,
            amount,
            SUM(amount) OVER (
              PARTITION BY id, location_id 
              ORDER BY serial_number ASC
          ) AS cumulative_balance
        FROM 
            order_data od
        --order by
          --serial_number DESC    -- Ø´ØºØ§Ù„ ÙƒÙˆÙŠØ³ Ø¨Ø³ Ø³ÙŠØ¨Ù‡ Ø¹Ø´Ø§Ù† Ø¯Ø§Ù„Ø© ÙØ§ÙŠÙ†Ø¯ Ù‡ØªØ¬ÙŠØ¨ Ø§ÙˆÙ„ Ù†ØªÙŠØ¬Ù‡ ØªÙ‚Ø§Ø¨Ù„Ù‡Ø§ ÙÙ„Ø§Ø²Ù… Ù†Ø±ØªØ¨Ù‡ ØµØ­
  `;

  const params = [req.session.company_id, datex];

  const cumulative_array = await tx.any(query, params) || [];
  
  let result = true

  if (cumulative_array.length > 0){
    const negative_row = cumulative_array.find(item => +item.cumulative_balance < 0)
    if (negative_row){
      result = `Ø³ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ ÙƒÙ…ÙŠØ© Ø³Ø§Ù„Ø¨Ø© Ù„Ù„ØµÙ†Ù '${negative_row.item_name}'  ÙÙ‰ Ù…ÙˆÙ‚Ø¹  '${negative_row.location_name}'  ÙÙ‰ ØªØ§Ø±ÙŠØ®  '${negative_row.datex}'`
    }

  }

  return result;
}

async function update_items_cogs(items_array,datex, req, tx) {
  
  if (!items_array){
    return
  }


  if (!Array.isArray(items_array) || items_array.length === 0) {
    throw new Error(
      'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ '
    );
    return;
  }

  await update_cogs_part1(items_array,datex, req, tx)

  const last_array =  await update_cogspart2(items_array,datex, req, tx)

  if (last_array.length > 0) {
    await update_cogs_part1(last_array,datex, req, tx)
  }
}

async function update_cogs_part1(items_array,datex, req, tx) {
  
  const query0 = `
  SELECT
    tb.item_id,
    SUM(tb.item_amount ) AS Current_amount,
    SUM(
        CASE
        WHEN tb.item_amount < 0 THEN -tb.cogs-- ØªØ®ÙÙŠØ¶ ÙÙŠ Ø§Ù„ØªÙƒÙ„ÙØ©
        ELSE tb.cogs -- Ø²ÙŠØ§Ø¯Ø© ÙÙŠ Ø§Ù„ØªÙƒÙ„ÙØ©		
        END			
    ) AS value
FROM
    transaction_body tb
INNER JOIN transaction_header th ON th.id = tb.transaction_header_id
inner join accounts_header ah on ah.id = tb.item_id
where
    ah.account_type_id = 5
    and th.datex < $1
    AND th.company_id = $2
    AND tb.item_id IN (${items_array.join(',')})
    AND th.is_deleted IS NULL
    AND th.is_including_items IS TRUE
    AND NOT (th.transaction_type IN (3,4) AND th.datex = $1) -- Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
GROUP by
tb.item_id
;`

  const started_balance = await tx.any(query0,[datex, req.session.company_id])  //! dayman 5aly el datex $1 3ashan mortpt be be el arkam fe ele est3lam 
    

const query1 = `
SELECT 
      tb.id,
      th.transaction_type,
      th.datex,
      tb.debit,
      tb.credit,
      tb.item_amount,
      tb.item_id,
      tb.cogs,
      tb.is_production_item
  FROM
      transaction_body tb
  LEFT JOIN 
      transaction_header th ON th.id = tb.transaction_header_id
  WHERE 
      th.company_id = $1
      AND th.is_deleted IS NULL
      AND tb.item_id is not null
      AND tb.item_id IN (${items_array.join(",")})
      --and tb.is_production_item is null
      AND th.datex >= $2
ORDER BY 
    th.datex ASC, 
    CASE 
        -- ğŸŸ¢ Ø£ÙˆÙ„Ù‹Ø§: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØ¶ÙŠÙ Ù„Ù„Ù…Ø®Ø²ÙˆÙ†
        WHEN th.transaction_type = 6 THEN 1  -- Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª
        WHEN th.transaction_type = 2 AND (tb.item_amount > 0 OR tb.debit > 0) THEN 2  -- Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨ÙŠ ÙŠØ¶ÙŠÙ Ù…Ø®Ø²ÙˆÙ†
        WHEN th.transaction_type = 31 AND tb.item_amount > 0 THEN 3  -- ØªØµÙ†ÙŠØ¹ - Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ù†Ù‡Ø§Ø¦ÙŠ
        WHEN th.transaction_type = 12 AND tb.item_amount > 0 THEN 4  -- ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²ÙˆÙ† - Ø¥Ø¶Ø§ÙØ©  ( Ø¨Ø³ Ù…Ø´ Ø¨ÙŠØ£Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„ØªÙƒÙ„ÙÙ‡ )

        -- ğŸ”µ Ø«Ø§Ù†ÙŠÙ‹Ø§: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªÙ‚Ù„Ù„ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª
        WHEN th.transaction_type = 7 THEN 5  -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª
        WHEN th.transaction_type = 2 AND (tb.item_amount < 0 OR tb.credit > 0) THEN 6  -- Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨ÙŠ ÙŠØ³Ø­Ø¨ Ù…Ø®Ø²ÙˆÙ†
        WHEN th.transaction_type = 31 AND tb.item_amount < 0 THEN 7  -- ØªØµÙ†ÙŠØ¹ - Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ù…ÙˆØ§Ø¯ Ø®Ø§Ù…
        WHEN th.transaction_type = 12 AND tb.item_amount < 0 THEN 8  -- ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø®Ø²ÙˆÙ† - Ø®ØµÙ…  ( Ø¨Ø³ Ù…Ø´ Ø¨ÙŠØ£Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„ØªÙƒÙ„ÙÙ‡ )


        -- ğŸ”´ Ø«Ø§Ù„Ø«Ù‹Ø§: Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØ³Ø­Ø¨ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (COGS)
        WHEN th.transaction_type = 3 THEN 9  -- Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
        WHEN th.transaction_type = 4 THEN 10  -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª

        -- âºï¸ Ø£Ø®ÙŠØ±Ù‹Ø§: Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ§Øª Ø£Ø®Ø±Ù‰ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©
        ELSE 11  
    END ASC,
    tb.id ASC
      ;
`;

  // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  const items_transactions_array = await tx.any(query1,[req.session.company_id,datex]);
  
  let updatedRecords = [];

  for (const item_id of items_array){
  
  // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù‚ÙŠÙ…
  let old_cogs = 0;
    
  let started_balances = []
  let started_amount = 0
  let started_value = 0
  started_balances = started_balance.find(item => +item.item_id === +item_id);
  
  if (started_balances){
    started_amount = +started_balances.current_amount || 0;
    started_value = +started_balances.value || 0;
  }


  const item_transaction_arry = items_transactions_array.filter(item => +item.item_id === +item_id)  

for (const row of item_transaction_arry) {
    
const type = +row.transaction_type
let cogs = 0;


  const row_amount = Math.abs(row.item_amount)

  if (type === 6 || (type === 2 && row.debit && !row.credit) || (type === 31 && row.is_production_item)){ // ÙØ§ØªÙˆØ±Ø© Ù…Ø´ØªØ±ÙŠØ§Øª Ø§Ùˆ Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ Ù…Ø¯ÙŠÙ† Ø§Ùˆ ØµÙ†Ù Ù…ØµÙ†Ø¹ ÙŠØ§Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù†Ù‡ Ù…Ø´ØªØ±ÙŠØ§Øª
    cogs = +row.debit
    started_amount += +row_amount;
    started_value += +cogs;

    
    if (!(type === 31 && row.is_production_item)){
      updatedRecords.push({ id: row.id, cogs});
    }

  }else if(type === 7 || (type === 2 && row.credit && !row.debit)){ // Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ Ø¯Ø§Ø¦Ù†
    cogs = +row.credit
    started_amount -= +row_amount;
    started_value -= +cogs;
    updatedRecords.push({ id: row.id, cogs});
  }else if(type === 3 || (type === 31 && !row.is_production_item)){ // ÙØ§ØªÙˆØ±Ø© Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ùˆ Ø§ØµÙ†Ø§Ù Ù…Ø³ØªÙ‡Ù„ÙƒÙ‡ ÙÙ‰ ÙØ§ØªÙˆØ±Ù‡ ØªØµÙ†ÙŠØ¹
 
    if(+started_value === 0 || +started_amount === 0 || +row_amount === 0){
      cogs = 0  
    }else{
      cogs = parseFloat(((started_value / started_amount) * row_amount).toFixed(2));
    }
    started_amount -= +row_amount;
    started_value -= cogs;


    updatedRecords.push({ id: row.id, cogs});
  }else if(type === 4){ // Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª
    if(+started_value === 0 || +started_amount === 0 || +row_amount === 0){
      cogs = 0  
    }else{
      cogs = parseFloat(((started_value / started_amount) * Math.abs(row_amount)).toFixed(2))
    }
    started_amount += +row_amount;
    started_value += cogs; // Ø¹Ù…Ù„Ù†Ø§ Ø¯Ù‰ Ø¨Ø§Ù„Ø³Ø§Ù„Ø¨ Ù„Ø§Ù†Ù‰ Ø¶Ø±Ø¨Øª Ø§Ù„ÙƒÙˆØ¬Ø² ÙÙˆÙ‚ Ø¨Ø§Ù„Ø³Ø§Ù„Ø¨  ÙˆØ¨Ø§Ù„ØªØ§Ù„Ù‰ Ù‡ÙŠØ¯ÙŠÙ†Ù‰ Ø²Ø§Ø¦Ø¯
    updatedRecords.push({id: row.id, cogs});
  }
  
  old_cogs += cogs;
}
}

// console.table(updatedRecords);
turn_EmptyValues_TO_null(updatedRecords)
 /* old
const queries = updatedRecords.map(
  ({ id, cogs }) =>
      `UPDATE transaction_body SET cogs = ${cogs} WHERE id = ${id}`
);
await tx.batch(queries.map((query) => tx.none(query)));
*/

if (updatedRecords.length > 0) {
  const ids = updatedRecords.map(({ id }) => id);

  
  const cases = updatedRecords
    .map(({ id, cogs }, index) => `WHEN id = $${index + 1} THEN ${cogs}`)
    .join(" ");

    
  const query = `
    UPDATE transaction_body
    SET cogs = CASE ${cases} END
    WHERE id IN (${ids.map((_, i) => `$${i + 1}`).join(", ")})
  `;

  await tx.none(query, ids);
}

}

async function update_cogspart2(items_array,datex, req, tx) {
  
//! update production_items after everything is done
let query2 = `
WITH balances AS (
    SELECT
        th.id AS transaction_header_id,
        SUM(
            COALESCE(tb.credit, 0) - COALESCE(tb.debit, 0) + COALESCE(tb.cogs, 0)
        ) AS new_total_cost
    FROM transaction_header th
    INNER JOIN transaction_body tb ON tb.transaction_header_id = th.id
    WHERE
        th.company_id = $1
        AND (
            th.transaction_type = 31 
            AND th.id IN (
                SELECT DISTINCT tb2.transaction_header_id
                FROM transaction_body tb2
                WHERE tb2.item_id IN (${items_array.join(',')})
                    AND tb.is_production_item IS NULL
            )
        )
        AND th.datex >= $2
    GROUP BY th.id
)
UPDATE transaction_body tb
SET 
    cogs = balances.new_total_cost,
    debit = balances.new_total_cost
FROM balances
WHERE tb.transaction_header_id = balances.transaction_header_id 
    AND tb.is_production_item = TRUE
RETURNING tb.item_id;
`;

let updatedItems = await tx.manyOrNone(query2, [req.session.company_id, datex]);

// Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£ØµÙ†Ø§Ù ÙÙŠ Ù…ØµÙÙˆÙØ©
let updatedItemsArray = updatedItems.map(row => Number(row.item_id)) || [];

return updatedItemsArray 

}



//! 
/*
-- Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù„Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª  Ø§Ù„ØªÙƒÙ„Ù‚Ù‡
       
select
	ah.id as account_id,
	ah.account_name,
	th.id as th_id,
	th.datex,
	th.transaction_type,
	tb.debit,
	tb.credit,
	tb.item_amount,
	tb.cogs
from
	transaction_body tb
left join transaction_header th on th.id = tb.transaction_header_id
left join accounts_header ah on ah.id = tb.item_id
where
	th.is_including_items is true
	and tb.item_amount is not null
  and th.company_id = $1
  ORDER BY 
      th.datex ASC,
      CASE th.transaction_type -- Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø®ØµØµ Ù„Ù€ transaction_type
        WHEN 6 THEN 1 -- Ù…Ø´ØªØ±ÙŠØ§Øª
        WHEN 7 THEN 2 -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª
        WHEN 31 THEN 3 -- ØªØµÙ†ÙŠØ¹
        WHEN 2 THEN 4 -- Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ ( Ù…Ø´ØªØ±ÙŠØ§Øª ÙˆÙ…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª )
        WHEN 4 THEN 5 -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª
        WHEN 3 THEN 6 -- Ù…Ø¨ÙŠØ¹Ø§Øª
        ELSE 7 -- Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£Ø®Ø±Ù‰ ØªÙƒÙˆÙ† ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
      END ASC,
      tb.id ASC
    



    -- Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ù…ÙŠØ²Ø§Ù† Ø§Ù„Ø§ÙˆÙ„ Ø§Ù„Ø§Ø³Ø§Ø³ Ø¨ØªØ§Ø¹ Ø§Ù„ØªØ¬Ù…ÙŠØ¹ ÙÙ‚Ø· 
    SELECT
    ah.id,
    ah.account_name,
    -- Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„ØªØ§Ø±ÙŠØ® $2
    SUM(CASE WHEN tb.debit IS NOT NULL AND th.datex < $2 THEN tb.debit ELSE 0 END) AS debit_first,
    SUM(CASE WHEN tb.credit IS NOT NULL AND th.datex < $2 THEN tb.credit ELSE 0 END) AS credit_first,
    -- Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª ÙÙŠ Ø§Ù„ÙØªØ±Ø© Ø¨ÙŠÙ† Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠÙ† $2 Ùˆ $3
    SUM(CASE WHEN tb.debit IS NOT NULL AND th.datex BETWEEN $2 AND $3 THEN tb.debit ELSE 0 END) AS debit_now,
    SUM(CASE WHEN tb.credit IS NOT NULL AND th.datex BETWEEN $2 AND $3 THEN tb.credit ELSE 0 END) AS credit_now,
    ah.is_final_account,
    ah.account_no,
    ah.finance_statement,
    ah.cashflow_statement,
    ah.account_type_id,
    ah.account_name_en,
    ah.global_id,
    ah.main_account_id,
    ah.is_inactive,
    ab.parent_id
FROM
    accounts_header ah
LEFT JOIN accounts_body ab ON ab.account_id = ah.id
LEFT JOIN transaction_body tb ON tb.account_id = ah.id
LEFT JOIN transaction_header th ON th.id = tb.transaction_header_id
WHERE
    ah.company_id = $1
GROUP BY
    ah.id, ab.parent_id;
   
   
   
   ------------------------------------------
   
   
	
*/


//! Ø§Ø³ØªØ¹Ù„Ø§Ù… 


//*-- server----------------------------------------------
//#region started server functions



/*

DO $$ 
DECLARE 
    tbl_name text := 'accounts_body';  -- ØªØ­Ø¯ÙŠØ¯ Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…ØªØºÙŠØ±
    max_id BIGINT; 
    seq_name text;
BEGIN 
    -- ØªØ­Ø¯ÙŠØ¯ Ø£Ø¹Ù„Ù‰ Ù‚ÙŠÙ…Ø© ÙÙŠ Ø§Ù„Ø¹Ù…ÙˆØ¯ 'id' Ø£Ùˆ ØªØ¹ÙŠÙŠÙ† 1 Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙØ§Ø±ØºÙ‹Ø§
    EXECUTE format('SELECT COALESCE(MAX(id), 0) + 1 FROM %I', tbl_name) 
    INTO max_id; 

    -- ØªØ­Ø¯ÙŠØ¯ Ø§Ø³Ù… Ø§Ù„ØªØ³Ù„Ø³Ù„
    seq_name := format('%I_id_seq', tbl_name);

    -- Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ³Ù„Ø³Ù„ Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„
    IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = seq_name) THEN
        -- Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ³Ù„Ø³Ù„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
        EXECUTE format('CREATE SEQUENCE %I START WITH %s', seq_name, max_id);
    ELSE
        -- Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ³Ù„Ø³Ù„ Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†Ù‡ Ø¥Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        EXECUTE format('ALTER SEQUENCE %I RESTART WITH %s', seq_name, max_id);
    END IF;

    -- ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¹Ù…ÙˆØ¯ Ù„Ø¥Ø¶Ø§ÙØ© ØªØ³Ù„Ø³Ù„ ÙƒÙ‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ØªØºÙŠØ± `tbl_name`
    EXECUTE format('ALTER TABLE %I ALTER COLUMN id SET DEFAULT nextval(''%I'')', tbl_name, seq_name);

    -- Ø±Ø¨Ø· Ø§Ù„ØªØ³Ù„Ø³Ù„ Ø¨Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ØªØºÙŠØ± `tbl_name`
    EXECUTE format('ALTER SEQUENCE %I OWNED BY %I.id', seq_name, tbl_name);
END $$;

*/


/*
-- Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ù‰ Ø¨ÙŠØ¬ÙŠØ¨ items_array + Ø§ÙˆÙ…Ø± Ø§Ù„ØªØµÙ†Ø¹ÙŠ
SELECT 
    tb.id,
    th.transaction_type,
    th.datex,
    tb.debit,
    tb.credit,
    tb.item_amount,
    tb.item_id,
    tb.cogs,
    tb.is_production_item
FROM
    transaction_body tb
LEFT JOIN 
    transaction_header th ON th.id = tb.transaction_header_id
WHERE 
    th.company_id = $1
    AND th.is_deleted IS NULL
    AND (
        -- Ø¬Ù„Ø¨ Ø§Ù„ØµÙÙˆÙ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø£Ø­Ø¯ Ø¹Ù†Ø§ØµØ± items_array
        tb.item_id IN (${items_array.join(',')}) 
        
        -- Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø­Ø±ÙƒØ© transaction_type = 31 Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¨Ù‡Ø§ Ø£Ø­Ø¯ Ø§Ù„Ø¹Ù†Ø§ØµØ±
        OR (
            th.transaction_type = 31 
            AND th.id IN (
                SELECT DISTINCT tb2.transaction_header_id
                FROM transaction_body tb2
                WHERE tb2.item_id IN (${items_array.join(',')})
            )
        )
    )
    AND th.datex >= $2
  ORDER BY 
      th.datex ASC,
      CASE th.transaction_type -- Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø®ØµØµ Ù„Ù€ transaction_type
        WHEN 6 THEN 1 -- Ù…Ø´ØªØ±ÙŠØ§Øª
        WHEN 7 THEN 2 -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª
        WHEN 31 THEN 3 -- ØªØµÙ†ÙŠØ¹
        WHEN 2 THEN 4 -- Ù‚ÙŠØ¯ Ù…Ø­Ø§Ø³Ø¨Ù‰ ( Ù…Ø´ØªØ±ÙŠØ§Øª ÙˆÙ…Ø±ØªØ¬Ø¹ Ù…Ø´ØªØ±ÙŠØ§Øª )
        WHEN 4 THEN 5 -- Ù…Ø±ØªØ¬Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª
        WHEN 3 THEN 6 -- Ù…Ø¨ÙŠØ¹Ø§Øª
        ELSE 7 -- Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£Ø®Ø±Ù‰ ØªÙƒÙˆÙ† ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
      END ASC,
      tb.id ASC

*/



//! 1: put all is_active to false for all users
async function make_all_users_is_active_to_false() {
  // we use this function in the begining of server start
  await db.none(`UPDATE users SET is_active = false`);
}

//#endregion End - sstarted server functions

//******************************************************************** */

server.listen(port, () => {
  console.log(`server is runing on http://localhost:${port}`);

  //! Ø§ÙˆØ§Ù…Ø± ØªÙ†ÙØ° Ù…Ø¨Ø´Ø±Ù‡ Ø¨Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙŠØ±ÙØ±
  make_all_users_is_active_to_false();
  //test_trial_balance() // Ù…Ø¹Ù„Ù‚
  //accept_request(request_id, int_company_numbers, int_users_numbers, '2025-02-13', '2025-12-31')
  //accept_request(9, 5, 5, '2025-02-13', '2025-12-31')
  //change_user_password(user_id, 'password')
  //change_user_password(36, '12344321')
});
